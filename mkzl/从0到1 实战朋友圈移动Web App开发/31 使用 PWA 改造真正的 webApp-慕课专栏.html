<html><head><meta charset="utf-8"><title>31 使用 PWA 改造真正的 webApp-慕课专栏</title>
			<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
			<meta name="renderer" content="webkit">
			<meta property="qc:admins" content="77103107776157736375">
			<meta property="wb:webmaster" content="c4f857219bfae3cb">
			<meta http-equiv="Access-Control-Allow-Origin" content="*">
			<meta http-equiv="Cache-Control" content="no-transform ">
			<meta http-equiv="Cache-Control" content="no-siteapp">
			<link rel="apple-touch-icon" sizes="76x76" href="https://www.imooc.com/static/img/common/touch-icon-ipad.png">
			<link rel="apple-touch-icon" sizes="120x120" href="https://www.imooc.com/static/img/common/touch-icon-iphone-retina.png">
			<link rel="apple-touch-icon" sizes="152x152" href="https://www.imooc.com/static/img/common/touch-icon-ipad-retina.png">
			<link href="https://moco.imooc.com/captcha/style/captcha.min.css" rel="stylesheet">
			<link rel="stylesheet" href="https://www.imooc.com/static/moco/v1.0/dist/css/moco.min.css?t=201907021539" type="text/css">
			<link rel="stylesheet" href="https://www.imooc.com/static/lib/swiper/swiper-3.4.2.min.css?t=201907021539">
			<link rel="stylesheet" href="https://static.mukewang.com/static/css/??base.css,common/common-less.css?t=2.5,column/zhuanlanChapter-less.css?t=2.5,course/inc/course_tipoff-less.css?t=2.5?v=201907051055" type="text/css">
			<link charset="utf-8" rel="stylesheet" href="https://www.imooc.com/static/lib/ueditor/themes/imooc/css/ueditor.css?v=201907021539"><link rel="stylesheet" href="https://www.imooc.com/static/lib/baiduShare/api/css/share_style0_16.css?v=6aba13f0.css"></head>
			<body><div id="main">


<div class="main-con hide-menu">
    <!-- 左侧菜单 & 索引 -->
    
    <div class="right-content" style="padding-left: 0px;">
        <div class="container clearfix" id="top" style="width: 1134px; display: block;">
            
            
            <div class="center_con js-center_con l" style="width: 1134px;">
                <div class="article-con">
                                            <!-- 买过的阅读 -->
                        

                    
                    <div class="art-title" style="margin-top: 0px;">
                        31 使用 PWA 改造真正的 webApp
                    </div>
                    <div class="art-info clearfix">
                        
                        <span class="l">
                            更新时间：2019-09-30 09:48:17
                        </span>
                    </div>
                    <div class="art-top">
                                                <img src="https://img4.mukewang.com/5d41350400011e9e06400359.jpg" alt="">
                                                                        <div class="famous-word-box">
                            <img src="https://www.imooc.com/static/img/column/bg-l.png" alt="" class="bg1 bg">
                            <img src="https://www.imooc.com/static/img/column/bg-r.png" alt="" class="bg2 bg">
                            <div class="famous-word">只有在那崎岖的小路上不畏艰险奋勇攀登的人,才有希望达到光辉的顶点。<p class="author">——马克思</p></div>
                        </div>
                                            </div>
                    <div class="art-content js-lookimg">
                        <div id="article_content">
                            <div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">随着互联网技术的发展，web应用已经越来越流行，技术的发展越来越迅速，尤其是移动互联网的到来使得HTML5技术，hybrid混合开发，更加火爆起来，但是web应用没能摆脱PC时代的一些根本性的问题，所需的资源依赖网络下载，用户体验始终要依赖浏览器，这让web应用和Native应用相比尤其在移动手机端的体验，总让人感觉"不正规"，而PWA技术的到来，让下一代web应用终于步入正轨！</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">本章节完整源代码地址，大家可以事先浏览一下：</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><a href="https://github.com/lvming6816077/wecircleCode/blob/master/app/src/registerServiceWorker.js">Github-registerServiceWorker.js</a><br>
<a href="https://github.com/lvming6816077/wecircleCode/blob/master/app/vue.config.js">Github-vue.config.js</a><br>
<a href="https://github.com/lvming6816077/wecircleCode/blob/master/app/public/sw-my.js">Github-sw-my.js</a></p>
</div><div class="cl-preview-section"><h3 id="什么是pwa？">什么是PWA？</h3>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><img class="" src="https://img.mukewang.com/5cde62180001811206400377.png" data-original="//img.mukewang.com/5cde62180001811206400377.png" alt="图片描述"><br>
PWA(progressing web app)，渐进式网页应用程序，是Google在2016年GoogleI/O大会上提出的下一代web应用模型，并在随后的日子里迅速发展。<br>
一个 PWA 应用首先是一个网页, 可以通过 Web 技术编写出一个网页应用. 随后借助于 App Manifest 和 Service Worker 来实现 PWA 的安装和离线等功能。</p>
</div><div class="cl-preview-section"><h3 id="pwa的特点">PWA的特点</h3>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;"><strong>渐进式</strong>：适用于选用任何浏览器的所有用户，因为它是以渐进式增强作为核心宗旨来开发的。</li>
<li style="font-size: 20px; line-height: 38px;"><strong>自适应</strong>：适合任何机型：桌面设备、移动设备、平板电脑或任何未来设备。</li>
<li style="font-size: 20px; line-height: 38px;"><strong>连接无关性</strong>：能够借助于服务工作线程在离线或低质量网络状况下工作。</li>
<li style="font-size: 20px; line-height: 38px;"><strong>离线推送</strong>：使用推送消息通知，能够让我们的应用像 Native App 一样，提升用户体验。</li>
<li style="font-size: 20px; line-height: 38px;"><strong>及时更新</strong>：在服务工作线程更新进程的作用下时刻保持最新状态。</li>
<li style="font-size: 20px; line-height: 38px;"><strong>安全性</strong>：通过 HTTPS 提供，以防止窥探和确保内容不被篡改。</li>
</ul>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">对于我们移动端来讲，用简单的一句话来概况一个PWA应用就是，我们开发的H5页面增加可以添加至屏幕的功能，点击主屏幕图标可以实现启动动画以及隐藏地址栏实现离线缓存功能，即使用户手机没有网络，依然可以使用一些离线功能。<br>
这些特点和功能不正是我们目前针对移动web的优化方向吗，有了这些特性将使得 Web 应用渐进式接近原生 App，真正实现秒开优化。</p>
</div><div class="cl-preview-section"><h3 id="service-worker">Service Worker</h3>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">Service Worker 是一个 基于HTML5 API ，也是PWA技术栈中最重要的特性， 它在 Web Worker 的基础上加上了持久离线缓存和网络代理能力，结合Cache API面向提供了JavaScript来操作浏览器缓存的能力，这使得Service Worker和PWA密不可分。</p>
</div><div class="cl-preview-section"><h4 id="service-worker概述：" style="font-size: 26px;">Service Worker概述：</h4>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">一个独立的执行线程，单独的作用域范围，单独的运行环境，有自己独立的context上下文。</li>
<li style="font-size: 20px; line-height: 38px;">一旦被 install，就永远存在，除非被手动 unregister。即使Chrome（浏览器）关闭也会在后台运行。利用这个特性可以实现离线消息推送功能。</li>
<li style="font-size: 20px; line-height: 38px;">处于安全性考虑，必须在 HTTPS 环境下才能工作。当然在本地调试时，使用localhost则不受HTTPS限制。</li>
<li style="font-size: 20px; line-height: 38px;">提供拦截浏览器请求的接口，可以控制打开的作用域范围下所有的页面请求。需要注意的是一旦请求被Service Worker接管，意味着任何请求都由你来控制，一定要做好容错机制，保证页面的正常运行。</li>
<li style="font-size: 20px; line-height: 38px;">由于是独立线程，Service Worker不能直接操作页面 DOM。但可以通过事件机制来处理。例如使用postMessage。</li>
</ul>
</div><div class="cl-preview-section"><h4 id="service-worker生命周期：" style="font-size: 26px;">Service Worker生命周期：</h4>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">注册（register）：这里一般指在浏览器解析到JavaScript有注册Service Worker时的逻辑，即调用navigator.serviceWorker.register()时所处理的事情。</li>
<li style="font-size: 20px; line-height: 38px;">安装中( installing )：这个状态发生在 Service Worker 注册之后，表示开始安装。</li>
<li style="font-size: 20px; line-height: 38px;">安装后( installed/waiting )：Service Worker 已经完成了安装，这时会触发install事件，在这里一般会做一些静态资源的离线缓存。如果还有旧的Service Worker正在运行，会进入waiting状态，如果你关闭当前浏览器，或者调用self.skipWaiting()，方法表示强制当前处在 waiting 状态的 Service Worker 进入 activate 状态。</li>
<li style="font-size: 20px; line-height: 38px;">激活( activating )：表示正在进入activate状态，调用self.clients.claim())会来强制控制未受控制的客户端，例如你的浏览器开了多个含有Service Worker的窗口，会在不切的情况下，替换旧的 Service Worker 脚本不再控制着这些页面，之后会被停止。此时会触发activate事件。</li>
<li style="font-size: 20px; line-height: 38px;">激活后( activated )：在这个状态表示Service Worker激活成功，在activate事件回调中，一般会清除上一个版本的静态资源缓存，或者其他更新缓存的策略。这代表Service Worker已经可以处理功能性的事件fetch (请求)、sync (后台同步)、push (推送)，message（操作dom）。</li>
<li style="font-size: 20px; line-height: 38px;">废弃状态 ( redundant )：这个状态表示一个 Service Worker 的生命周期结束。</li>
</ul>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">整个流程可以用下图解释：<br>
<img class="" src="https://img.mukewang.com/5cde7eab0001dc6a04320672.png" data-original="//img.mukewang.com/5cde7eab0001dc6a04320672.png" alt="图片描述"></p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">Service Worker支持的事件：<br>
<img class="" src="https://img.mukewang.com/5cde7ef0000144c605730167.png" data-original="//img.mukewang.com/5cde7ef0000144c605730167.png" alt="图片描述"></p>
</div><div class="cl-preview-section"><h4 id="service-worker浏览器兼容性：" style="font-size: 26px;">Service Worker浏览器兼容性：</h4>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><img class="" src="https://img.mukewang.com/5ce038830001b4b021701184.png" data-original="//img.mukewang.com/5ce038830001b4b021701184.png" alt="图片描述"><br>
Service Worker作为一个新的技术，那么就必然会有浏览器兼容性问题，从图上可以看到对于大部分的Android来说支持性还是很不错的，尤其是Chrome for Android，但是对于iOS系统而言11.3之前是不支持Service Worker的，这可能也是Service Worker没能普及开来的一个原因，但是好消息是苹果宣布后续会持续更新对Service Worker的支持，那么前景还是很值得期待的。</p>
</div><div class="cl-preview-section"><h3 id="开始改造我们的wecircle应用：">开始改造我们的wecircle应用：</h3>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">先看下我们的改造效果：<br>
<img class="" src="https://img.mukewang.com/5d404f980001d2a402080341.gif" data-original="//img.mukewang.com/5d404f980001d2a402080341.gif" alt="图片描述"></p>
</div><div class="cl-preview-section"><h4 id="添加manifest.json配置页面参数：" style="font-size: 26px;">添加manifest.json配置页面参数：</h4>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">添加到桌面快捷方式功能本身是PWA应用的一部分，他让我们的应用看起来更像是一个Web App，我们在前端项目的 public 文件夹下新建 manifest.json 文件：</p>
</div><div class="cl-preview-section"><pre class="  language-json"><code class="prism  language-json"><span class="token punctuation">{</span>
    <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"WECIRCLE"</span><span class="token punctuation">,</span>
    <span class="token string">"short_name"</span><span class="token punctuation">:</span> <span class="token string">"WECIRCLE"</span><span class="token punctuation">,</span>
    <span class="token string">"icons"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>
        <span class="token punctuation">{</span>
          <span class="token string">"src"</span><span class="token punctuation">:</span> <span class="token string">"./img/icons/android-chrome-192x192.png"</span><span class="token punctuation">,</span>
          <span class="token string">"sizes"</span><span class="token punctuation">:</span> <span class="token string">"192x192"</span><span class="token punctuation">,</span>
          <span class="token string">"type"</span><span class="token punctuation">:</span> <span class="token string">"image/png"</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span>
          <span class="token string">"src"</span><span class="token punctuation">:</span> <span class="token string">"./img/icons/android-chrome-512x512.png"</span><span class="token punctuation">,</span>
          <span class="token string">"sizes"</span><span class="token punctuation">:</span> <span class="token string">"512x512"</span><span class="token punctuation">,</span>
          <span class="token string">"type"</span><span class="token punctuation">:</span> <span class="token string">"image/png"</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token string">"start_url"</span><span class="token punctuation">:</span> <span class="token string">"./index.html"</span><span class="token punctuation">,</span>
    <span class="token string">"display"</span><span class="token punctuation">:</span> <span class="token string">"standalone"</span><span class="token punctuation">,</span>
    <span class="token string">"background_color"</span><span class="token punctuation">:</span> <span class="token string">"#000000"</span><span class="token punctuation">,</span>
    <span class="token string">"theme_color"</span><span class="token punctuation">:</span> <span class="token string">"#181818"</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">其中：</p>
</div><div class="cl-preview-section"><ol>
<li style="font-size: 20px; line-height: 38px;"><strong>name</strong>：指定了 Web App 的名称，也就是保存到桌面图标的名称。</li>
<li style="font-size: 20px; line-height: 38px;"><strong>short_name</strong>：当 name 名称过长时，将会使用 short_name 来代替name显示，也就是 Web App 的简称。</li>
<li style="font-size: 20px; line-height: 38px;"><strong>start_url</strong>：指定了用户打开该 Web App 时加载的URL。相对URL会相对于 manifest.json 。这里我们指定了 index.html 作为 Web App 的启动页。</li>
<li style="font-size: 20px; line-height: 38px;"><strong>display</strong>：指定了应用的显示模式，它有四个值可以选择：<br>
<code>fullscreen</code>：全屏显示，会尽可能将所有的显示区域都占满。<br>
<code>standalone</code>：浏览器相关UI（如导航栏、工具栏等）将会被隐藏，因此看起来更像一个Native App。<br>
<code>minimal-ui</code>：显示形式与standalone类似，浏览器相关UI会最小化为一个按钮，不同浏览器在实现上略有不同。<br>
<code>browser</code>：一般来说，会和正常使用浏览器打开样式一致。<br>
这里需要说明一下的是当一些系统的浏览器不支持fullscreen时将会显示成 standalone 的效果，当不支持 standalone 属性时，将会显示成 minimal-ui 的效果，以此类推。</li>
<li style="font-size: 20px; line-height: 38px;"><strong>icons</strong>：指定了应用的桌面图标和启动页图像，用数组表示：<br>
<code>sizes</code>：图标的大小。通过指定大小，系统会选取最合适的图标展示在相应位置上。<br>
<code>src</code>：图标的文件路径。相对路径是相对于 manifest.json 文件，也可以使用绝对路径例如http://xxx.png。<br>
<code>type</code>：图标的图片类型。<br>
浏览器会从 icons 中选择最接近 128dp(px = dp * (dpi / 160)) 的图片作为启动画面图像。</li>
<li style="font-size: 20px; line-height: 38px;"><strong>background_color</strong>：指定了启动画面的背景颜色，采用相同的颜色可以实现从启动画面到首页的平稳过渡，也可以用来改善页面资源正在加载时的用户体验，结合icons属性，可以定义背景颜色+图片icon的启动页效果，类似与Native App的splash screen效果：<img class="" src="https://img.mukewang.com/5ce03fc60001202705880950.png" data-original="//img.mukewang.com/5ce03fc60001202705880950.png" alt="图片描述"></li>
<li style="font-size: 20px; line-height: 38px;"><strong>theme_color</strong>：指定了 Web App 的主题颜色。可以通过该属性来控制浏览器 UI 的颜色。比如状态栏、内容页中状态栏、地址栏的颜色。</li>
</ol>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">当然，这里我们只是列举我我们项目中用到的 manifest.json 相关属性的讲解，更多的参数配置可以参考<a href="https://developer.mozilla.org/en-US/docs/Web/Manifest">MDN</a>，当然如果你觉得这些配置太过于繁琐，也可以用<a href="https://tomitm.github.io/appmanifest/">Web App Manifest Generator</a>来实现可视化的配置。</p>
</div><div class="cl-preview-section"><h4 id="配置ios系统的页面参数：" style="font-size: 26px;">配置iOS系统的页面参数：</h4>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">理想很丰满，现实却很骨感，manifest.json 那么强大但是也逃不过浏览器兼容性问题，正如下图 manifest.json 的兼容性：<img class="" src="https://img.mukewang.com/5ce040b60001474f21960980.png" data-original="//img.mukewang.com/5ce040b60001474f21960980.png" alt="图片描述"><br>
由于iOS系统对 manifest.json 是属于部分支持，所以我们需要在head里给配置而外的 meta 属性才能让iOS系统更加完善：</p>
</div><div class="cl-preview-section"><pre class=" language-html"><code class="prism  language-html"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>apple-mobile-web-app-capable<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>yes<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>apple-mobile-web-app-title<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>WECIRCLE<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>apple-touch-icon<span class="token punctuation">"</span></span> <span class="token attr-name">sizes</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>76x76<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>./img/icons/apple-touch-icon-76x76-1.png<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>apple-touch-icon<span class="token punctuation">"</span></span> <span class="token attr-name">sizes</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>152x152<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>./img/icons/apple-touch-icon-152x152.png-1<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>apple-touch-icon<span class="token punctuation">"</span></span> <span class="token attr-name">sizes</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>180x180<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>./img/icons/apple-touch-icon-180x180.png-1<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;"><strong>apple-touch-icon</strong>:指定了应用的图标，类似与manifest.json文件的icons配置，也是支持sizes属性，来供不同场景的选择。</li>
<li style="font-size: 20px; line-height: 38px;"><strong>apple-mobile-web-app-capable</strong>：类似于 manifest.json 中的display的功能，通过设置为yes可以进入standalone模式，目前来说iOS系统还支持这个模式。</li>
<li style="font-size: 20px; line-height: 38px;"><strong>apple-mobile-web-app-title</strong>：指定了应用的名称。</li>
<li style="font-size: 20px; line-height: 38px;"><strong>apple-mobile-web-app-status-bar-style</strong>：指定了iOS移动设备的状态栏(status bar)的样式，有Default，Black，Black-translucent可以设置。</li>
</ul>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">采用iOS12.0测试下来看，<code>apple-touch-icon</code>，<code>apple-mobile-web-app-status-bar-style</code>是真实生效的，而 manifest.json 的 icons 则不会被iOS系统识别，下面是iOS系统safari保存到桌面操作的截图：<br>
<img class="" src="https://img.mukewang.com/5ce0441c0001f63907501334.jpg" data-original="//img.mukewang.com/5ce0441c0001f63907501334.jpg" alt="图片描述"><br>
在Android的Chrome中：<br>
<img class="" src="https://img.mukewang.com/5cfe8e8200017a1505400960.jpg" data-original="//img.mukewang.com/5cfe8e8200017a1505400960.jpg" alt="图片描述"><br>
最后，别忘了将manifest.json文件在html中进行引入：</p>
</div><div class="cl-preview-section"><pre class="  language-html"><code class="prism  language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>manifest<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>manifest.json<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
</code></pre>
</div><div class="cl-preview-section"><h4 id="注册和使用service-worker的缓存功能：" style="font-size: 26px;">注册和使用Service Worker的缓存功能：</h4>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">第一步，我们需要将Service Worker进行注册：<br>
在前端项目public文件夹下的index.html中添加如下代码：</p>
</div><div class="cl-preview-section"><pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">'serviceWorker'</span> <span class="token keyword">in</span> navigator<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'load'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    navigator<span class="token punctuation">.</span>serviceWorker<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token string">'/sw-my.js'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>scope<span class="token punctuation">:</span> <span class="token string">'/'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>registration<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 注册成功</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'ServiceWorker registration successful with scope: '</span><span class="token punctuation">,</span> registration<span class="token punctuation">.</span>scope<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 注册失败:(</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'ServiceWorker registration failed: '</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">采用<code>serviceWorkerContainer.register()</code>来注册Service Worker，这里要做好容错判断，保证某些机型在不支持Service Worker的情况下可以正常运行，而不会报错。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">另外需要注意的是只有在https下，navigator里才会有serviceWorker这个对象。<br>
第二步，在前端项目public文件夹下新建<code>sw-my.js</code>，并定义需要缓存的文件路径：</p>
</div><div class="cl-preview-section"><pre class="  language-javascript"><code class="prism  language-javascript"><span class="token comment">// 定义需要缓存的文件</span>
<span class="token keyword">var</span> cacheFiles <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token string">'./lib/weui/weui.min.js'</span><span class="token punctuation">,</span>
  <span class="token string">'./lib/slider/slider.js'</span><span class="token punctuation">,</span>
  <span class="token string">'./lib/weui/weui.min.css'</span>
<span class="token punctuation">]</span>
<span class="token comment">// 定义缓存的key值</span>
<span class="token keyword">var</span> cacheName <span class="token operator">=</span> <span class="token string">'20190301'</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">第三步，监听install事件，来进行相关文件的缓存操作：</p>
</div><div class="cl-preview-section"><pre class="  language-javascript"><code class="prism  language-javascript"><span class="token comment">// 监听install事件，安装完成后，进行文件缓存</span>
self<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'install'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Service Worker 状态： install'</span><span class="token punctuation">)</span>

  <span class="token comment">// 找到key对应的缓存并且获得可以操作的cache对象</span>
  <span class="token keyword">var</span> cacheOpenPromise <span class="token operator">=</span> caches<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>cacheName<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>cache<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 将需要缓存的文件加进来</span>
    <span class="token keyword">return</span> cache<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>cacheFiles<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token comment">// 将promise对象传给event</span>
  e<span class="token punctuation">.</span><span class="token function">waitUntil</span><span class="token punctuation">(</span>cacheOpenPromise<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">我们在<code>sw-my.js</code>里面采用的标准的web worker的编程方式，由于运行在另一个全局上下文中（<code>self</code>），这个全局上下文不同于window，所以我们采用<code>self.addEventListener()</code>。<br>
<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache">Cache API</a>是由Service Worker提供用来操作缓存的的接口，这些接口基于Promise来实现，包括了<code>Cache</code>和<code>Cache Storage</code>，Cache直接和请求打交道，为缓存的 Request / Response  对象对提供存储机制，CacheStorage 表示 Cache 对象的存储实例，我们可以直接使用全局的caches属性访问Cache API。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><img class="" src="https://img.mukewang.com/5ce048b9000176b304980802.png" data-original="//img.mukewang.com/5ce048b9000176b304980802.png" alt="图片描述"></p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">Cache相关API说明：</p>
</div><div class="cl-preview-section"><pre><code>Cache.match(request, options) 返回一个 Promise对象，resolve的结果是跟 Cache 对象匹配的第一个已经缓存的请求。
Cache.matchAll(request, options) 返回一个Promise 对象，resolve的结果是跟Cache对象匹配的所有请求组成的数组。
Cache.addAll(requests)接收一个URL数组，检索并把返回的response对象添加到给定的Cache对象。
Cache.delete(request, options)搜索key值为request的Cache 条目。如果找到，则删除该Cache 条目，并且返回一个resolve为true的Promise对象；如果未找到，则返回一个resolve为false的Promise对象。
Cache.keys(request, options)返回一个Promise对象，resolve的结果是Cache对象key值组成的数组。
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">第三步，监听fetch事件来使用缓存数据：</p>
</div><div class="cl-preview-section"><pre class="  language-javascript"><code class="prism  language-javascript">self<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'fetch'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'现在正在请求：'</span> <span class="token operator">+</span> e<span class="token punctuation">.</span>request<span class="token punctuation">.</span>url<span class="token punctuation">)</span>

  e<span class="token punctuation">.</span><span class="token function">respondWith</span><span class="token punctuation">(</span>
    <span class="token comment">// 判断当前请求是否需要缓存</span>
    caches<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>request<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>cache<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 有缓存就用缓存，没有就从新发请求获取</span>
      <span class="token keyword">return</span> cache <span class="token operator">||</span> <span class="token function">fetch</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>request<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
      <span class="token comment">// 缓存报错还直接从新发请求获取</span>
      <span class="token keyword">return</span> <span class="token function">fetch</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>request<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">上一步我们将相关的资源进行了缓存，那么接下来就要使用这些缓存，这里同样要做好容错逻辑，记住一旦请求被Service Worker接管，浏览器的默认请求就不再生效了，意思就是请求的发与不发，出错与否全部由自己的代码控制，这里一定要做好兼容，当缓存失效或者发生内部错误时，及时调用fetch重新在发起请求。<br>
正如上面提到的Service Worker的生命周期，fetch事件的触发，必须依赖Service Worker进入<code>activated</code>状态，于是来到第四步。<br>
第四步，监听activate事件来更新缓存数据：<br>
使用缓存一个必不可少的步骤就是更新缓存，如果缓存无法更新，那么将毫无意义。<br>
我们在<code>sw-my.js</code>中添加如下代码：</p>
</div><div class="cl-preview-section"><pre class="  language-javascript"><code class="prism  language-javascript"><span class="token comment">// 监听activate事件，激活后通过cache的key来判断是否更新cache中的静态资源</span>
self<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'activate'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Service Worker 状态： activate'</span><span class="token punctuation">)</span>
  <span class="token keyword">var</span> cachePromise <span class="token operator">=</span> caches<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>keys<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 遍历当前scope使用的key值</span>
    <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span>keys<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果新获取到的key和之前缓存的key不一致，就删除之前版本的缓存</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">!==</span> cacheName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> caches<span class="token punctuation">.</span><span class="token keyword">delete</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  e<span class="token punctuation">.</span><span class="token function">waitUntil</span><span class="token punctuation">(</span>cachePromise<span class="token punctuation">)</span>
  <span class="token comment">// 保证第一次加载fetch触发</span>
  <span class="token keyword">return</span> self<span class="token punctuation">.</span>clients<span class="token punctuation">.</span><span class="token function">claim</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">每当已安装的Service Worker页面被打开时，便会触发Service Worker脚本更新。</li>
<li style="font-size: 20px; line-height: 38px;">当上次脚本更新写入Service Worker数据库的时间戳与本次更新超过24小时，便会触发Service Worker脚本更新。</li>
<li style="font-size: 20px; line-height: 38px;">当sw-my.js文件改变时，便会触发Service Worker脚本更新。</li>
</ul>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">更新流程与安装类似，只是在更新安装成功后不会立即进入<code>active</code>状态，更新后的Service Worker会和原始的Service Worker共同存在，并运行它的<code>install</code>，一旦新Service Worker安装成功，它会进入wait状态，需要等待旧版本的Service Worker进/线程终止。<br>
<code>self.skipWaiting()</code>可以阻止等待，让新Service Worker安装成功后立即激活。<br>
<code>self.clients.claim()</code>方法来让没被控制的 clients 受控，也就是设置本身为activate的Service Worker。<br>
<img class="" src="https://img.mukewang.com/5ce04ca1000105a108660383.png" data-original="//img.mukewang.com/5ce04ca1000105a108660383.png" alt="图片描述"></p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">打开Chrome控制台，点击Application，查看Service Worker状态：<br>
<img class="" src="https://img.mukewang.com/5ce04f2b000130dc15560976.png" data-original="//img.mukewang.com/5ce04f2b000130dc15560976.png" alt="图片描述"></p>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">status表示当前Service Worker的状态。</li>
<li style="font-size: 20px; line-height: 38px;">clients表示当前几个窗口连接这个Service Worker。</li>
</ul>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这里需要说明是，如果你的浏览器开了多个窗口，那么如果在不调用<code>self.skipWaiting()</code>的情况下，必须将窗口关闭在打开才能使Service Worker更新成功。</p>
</div><div class="cl-preview-section"><h4 id="采用offline-plugin插件完善service-worker：" style="font-size: 26px;">采用offline-plugin插件完善Service Worker：</h4>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">上面的我们写的Service Worker逻辑虽然已经完成，但是还有一些不完善的地方，比如，我们每次构建完之后，每个文件的md5都会改变，所以我们每次在写缓存文件列表时，都需要手动的的修改:</p>
</div><div class="cl-preview-section"><pre class="  language-javascript"><code class="prism  language-javascript"><span class="token keyword">var</span> cacheFiles <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token string">'./static/js/vendor.d70d8829.js'</span>
  <span class="token string">'./static/js/app.d70d8869.js'</span>
<span class="token punctuation">]</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这带来的一定的复杂性，那么接下来就利用webpack的<a href="https://github.com/NekR/offline-plugin">offline-plugin</a>插件来帮助我们完善这些事情，自动生成sw-my.js。</p>
</div><div class="cl-preview-section"><ol>
<li style="font-size: 20px; line-height: 38px;">安装offline-plugin插件：<pre class=" language-bash"><code class="prism  language-bash"><span class="token function">npm</span> <span class="token function">install</span> offline-plugin --save
</code></pre>
</li>
<li style="font-size: 20px; line-height: 38px;">在<code>vue.config.js</code>里配置：<pre class=" language-javascript"><code class="prism  language-javascript">  configureWebpack<span class="token punctuation">:</span> <span class="token punctuation">{</span>
   plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>
     <span class="token keyword">new</span> <span class="token class-name">OfflinePlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
       <span class="token comment">// 要求触发ServiceWorker事件回调</span>
       ServiceWorker<span class="token punctuation">:</span> <span class="token punctuation">{</span>
         events<span class="token punctuation">:</span> <span class="token boolean">true</span>
       <span class="token punctuation">}</span><span class="token punctuation">,</span>
       <span class="token comment">// 更更新策略选择全部更新</span>
       updateStrategy<span class="token punctuation">:</span> <span class="token string">'all'</span><span class="token punctuation">,</span>
       <span class="token comment">// 除去一些不需要缓存的文件</span>
       excludes<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'**/.*'</span><span class="token punctuation">,</span> <span class="token string">'**/*.map'</span><span class="token punctuation">,</span> <span class="token string">'**/*.gz'</span><span class="token punctuation">,</span> <span class="token string">'**/*.png'</span><span class="token punctuation">,</span> <span class="token string">'**/*.jpg'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>

       <span class="token comment">// 添加index.html的更新</span>
       <span class="token function">rewrites</span> <span class="token punctuation">(</span>asset<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>asset<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'index.html'</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token keyword">return</span> <span class="token string">'./index.html'</span>
         <span class="token punctuation">}</span>

         <span class="token keyword">return</span> asset
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span><span class="token punctuation">)</span>
   <span class="token punctuation">]</span>
 <span class="token punctuation">}</span>
</code></pre>
</li>
<li style="font-size: 20px; line-height: 38px;">在前端项目src目录新建<code>registerServiceWorker.js</code>里面对Service Worker进行注册：<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> OfflinePluginRuntime <span class="token keyword">from</span> <span class="token string">'offline-plugin/runtime'</span>
OfflinePluginRuntime<span class="token punctuation">.</span><span class="token function">install</span><span class="token punctuation">(</span><span class="token punctuation">{</span>

  onUpdateReady<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 更新完成之后，调用applyUpdate即skipwaiting()方法</span>
    OfflinePluginRuntime<span class="token punctuation">.</span><span class="token function">applyUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  onUpdated<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">//弹一个确认框</span>
    weui<span class="token punctuation">.</span><span class="token function">confirm</span><span class="token punctuation">(</span><span class="token string">'发现新版本，是否更新？'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span> 
      <span class="token comment">// 刷新一下页面</span>
      window<span class="token punctuation">.</span>location<span class="token punctuation">.</span><span class="token function">reload</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>

    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
        title<span class="token punctuation">:</span> <span class="token string">''</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
</li>
</ol>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><img class="" src="https://img.mukewang.com/5cfe8f0900010d3f05400960.jpg" data-original="//img.mukewang.com/5cfe8f0900010d3f05400960.jpg" alt="图片描述"></p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这里说明一下：</p>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">选择了offline-plugin插件之后呢，之前我们手写的注册Service Worker和Service Worker缓存相关逻辑都可以去掉了，因为offline-plugin会帮我们做这些事情。</li>
<li style="font-size: 20px; line-height: 38px;">offline-plugin插件会自动扫描webpack构建出来的dist目录里的文件，对这些文件配置缓存列表，正如上面插件里面的配置。</li>
<li style="font-size: 20px; line-height: 38px;"><code>excludes</code>：指定了一些不需要缓存的文件列表，例如我们不希望对图片资源进行缓存，并且支持正则表达式的方式。</li>
<li style="font-size: 20px; line-height: 38px;"><code>updateStrategy</code>：指定了缓存策略选择全部更新，另外一种是增量更新<code>changed</code>。</li>
<li style="font-size: 20px; line-height: 38px;"><code>event：true</code>指定了要触发Service Worker事件的回调，这个<code>main.js</code>里的配置是相对应的，只有这里设置成true，那边的回调才会触发。</li>
<li style="font-size: 20px; line-height: 38px;">我们在<code>main.js</code>里的配置是为了，当Service Worker有更新时，立刻进行更新，而不让Service Worker进入wait状态，这和上面我们讲到的Service Worker更新流程相对应。当让更多的offline-plugin相关配置，也可以去官网看<a href="https://github.com/NekR/offline-plugin/blob/master/docs/options.md">文档</a>。</li>
</ul>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">OK，到这里我们的PWA改造就已经完成了，我们在执行npm run build命令之后，就会生成对应<code>的sw.js</code>文件，部署之后，我们就可以将页面保存到桌面，并且拥有了离线缓存，这看起来就像是一个Native App。这个文件名默认叫做<code>sw.js</code>，就可以替换我们之前手写的<code>sw-my.js</code>了。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">除此之外，我们在PC端的Chrome也可以选择使用安装到桌面的功能，这让我们的程序应用看起来更像是一个桌面应用：<br>
<img class="" src="https://img.mukewang.com/5ce151fd0001161124081450.png" data-original="//img.mukewang.com/5ce151fd0001161124081450.png" alt="图片描述"></p>
</div><div class="cl-preview-section"><h3 id="小结">小结</h3>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">本章节主要讲解了PWA的相关知识，以及将我们的项目改成成一个PWA应用。<br>
相关知识点：</p>
</div><div class="cl-preview-section"><ol>
<li style="font-size: 20px; line-height: 38px;">PWA应用的概念以及PWA应用的特性。</li>
<li style="font-size: 20px; line-height: 38px;">Service Worker的兼容性以及生命周期和事件等基本概念。</li>
<li style="font-size: 20px; line-height: 38px;">manifest.json文件的各个配置项作用。</li>
<li style="font-size: 20px; line-height: 38px;">拦截<code>fetch</code>事件，缓存前端静态资源文件的原理。</li>
<li style="font-size: 20px; line-height: 38px;">结合offline-plugin插件，将项目改造成PWA应用。</li>
</ol>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">本章节完整源代码地址：</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><a href="https://github.com/lvming6816077/wecircleCode/blob/master/app/src/registerServiceWorker.js">Github-registerServiceWorker.js</a><br>
<a href="https://github.com/lvming6816077/wecircleCode/blob/master/app/vue.config.js">Github-vue.config.js</a><br>
<a href="https://github.com/lvming6816077/wecircleCode/blob/master/app/public/sw-my.js">Github-sw-my.js</a></p>
</div>}
                        </div>
                    </div>
                                            <!-- 买过的阅读 -->
                        <div class="art-next-prev clearfix">
                                                                                                <!-- 已买且开放 或者可以试读 -->
                                    <a href="/read/42/article/675">
                                                                    <div class="prev l clearfix">
                                        <div class="icon l">
                                            <i class="imv2-arrow3_l"></i>
                                        </div>
                                        <p>
                                            30 页面转场动画
                                        </p>
                                    </div>
                                </a>
                                                                                                                            <!-- 已买且开放 或者可以试读 -->
                                    <a href="/read/42/article/677">
                                                                    <div class="next r clearfix">
                                        <p>
                                            32 模拟真实APP完成消息推送
                                        </p>
                                        <div class="icon r">
                                            <i class="imv2-arrow3_r"></i>
                                        </div>

                                    </div>
                                </a>
                                                    </div>
                                    </div>
                <div class="comments-con js-comments-con" id="coments_con">
                </div>

                
            </div>
            
            
            

        </div>
    </div>
</div>

<div class="modal modal-jiaQun-new hide" id="modal-jiaQun">
    <div class="inner" style="">
        <div class="modal-close js-close-jiaQun">
            <i class="imv2-close"></i>
        </div>
        <div class="content">
            <img src="https://img.mukewang.com/5d5a700d0001363505400600.jpg">
            <div class="right-info">
                <div class="title">
                    扫码加入慕课前端核心用户群
                </div>
                <div class="desc">
                                            <p class="mb6">验证信息：<span id="joincode">1907231049307411</span><span class="copy js-copy-joincode">复制</span></p>
                                        <p class="mb6">QQ讨论群号：722466314</p>
                                            <p>QQ群URL：<a href="https://jq.qq.com/?_wv=1027&amp;k=5l9EFfc" target="_blank">点击访问</a></p>
                                    </div>
            </div>
            <p class="tip">若遇到搜索不到QQ群或加群失败，请联系客服邮箱:kf@imooc.com</p>
        </div>
    </div>
</div>
 
<!-- 专栏介绍页专栏评价 -->

<!-- 专栏介绍页底部三条评价 -->

<!-- 专栏阅读页弹层目录和介绍页页面目录 -->

<!-- 专栏阅读页发布回复 -->

<!-- 专栏阅读页发布评论 -->

<!-- 专栏阅读页底部评论 -->

<!-- 专栏阅读 单个 评论 -->

<!-- 新增回复和展开三条以外回复 -->

<!-- 立即订阅的弹窗 -->












</div></body></html>