<html><head><meta charset="utf-8"><title>39 专题1：LRU Cache 最近最少使用算法-慕课专栏</title>
			<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
			<meta name="renderer" content="webkit">
			<meta property="qc:admins" content="77103107776157736375">
			<meta property="wb:webmaster" content="c4f857219bfae3cb">
			<meta http-equiv="Access-Control-Allow-Origin" content="*">
			<meta http-equiv="Cache-Control" content="no-transform ">
			<meta http-equiv="Cache-Control" content="no-siteapp">
			<link rel="apple-touch-icon" sizes="76x76" href="https://www.imooc.com/static/img/common/touch-icon-ipad.png">
			<link rel="apple-touch-icon" sizes="120x120" href="https://www.imooc.com/static/img/common/touch-icon-iphone-retina.png">
			<link rel="apple-touch-icon" sizes="152x152" href="https://www.imooc.com/static/img/common/touch-icon-ipad-retina.png">
			<link href="https://moco.imooc.com/captcha/style/captcha.min.css" rel="stylesheet">
			<link rel="stylesheet" href="https://www.imooc.com/static/moco/v1.0/dist/css/moco.min.css?t=201907021539" type="text/css">
			<link rel="stylesheet" href="https://www.imooc.com/static/lib/swiper/swiper-3.4.2.min.css?t=201907021539">
			<link rel="stylesheet" href="https://static.mukewang.com/static/css/??base.css,common/common-less.css?t=2.5,column/zhuanlanChapter-less.css?t=2.5,course/inc/course_tipoff-less.css?t=2.5?v=201907051055" type="text/css">
			<link charset="utf-8" rel="stylesheet" href="https://www.imooc.com/static/lib/ueditor/themes/imooc/css/ueditor.css?v=201907021539"><link rel="stylesheet" href="https://www.imooc.com/static/lib/baiduShare/api/css/share_style0_16.css?v=6aba13f0.css"></head>
			<body><div id="main">


<div class="main-con hide-menu">
    <!-- 左侧菜单 & 索引 -->
    
    <div class="right-content" style="padding-left: 0px;">
        <div class="container clearfix" id="top" style="width: 1134px; display: block;">
            
            
            <div class="center_con js-center_con l" style="width: 1134px;">
                <div class="article-con">
                                            <!-- 买过的阅读 -->
                        

                    
                    <div class="art-title" style="margin-top: 0px;">
                        39 专题1：LRU Cache 最近最少使用算法
                    </div>
                    <div class="art-info clearfix">
                        
                        <span class="l">
                            更新时间：2019-10-14 09:25:20
                        </span>
                    </div>
                    <div class="art-top">
                                                <img src="https://img1.mukewang.com/5d48d65c0001b12106400359.jpg" alt="">
                                                                        <div class="famous-word-box">
                            <img src="https://www.imooc.com/static/img/column/bg-l.png" alt="" class="bg1 bg">
                            <img src="https://www.imooc.com/static/img/column/bg-r.png" alt="" class="bg2 bg">
                            <div class="famous-word">梦想只要能持久，就能成为现实。我们不就是生活在梦想中的吗？<p class="author">——丁尼生</p></div>
                        </div>
                                            </div>
                    <div class="art-content js-lookimg">
                        <div id="article_content">
                            <div class="cl-preview-section"><h2 id="什么是-lru-cache" style="font-size: 30px;">什么是 LRU Cache</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">LRU Cache 算法是 Least Recently Used，也就是最近最少使用算法。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">对于一个操作系统来说，我们的缓存是有限的，所以有的时候我们必须要舍弃掉一些 <code>object</code> 来增加当前程序的运行效率。LRU Cache 算法的概念是：当缓存空间满了的时候，将最近最少使用的数据从缓存空间中删除以增加可用的缓存空间来缓存新的数据。这个算法的核心是一个缓存列表，当我们在缓存中的数据被访问的时候，这个数据就会被提到列表的头部，这样的话列表尾部的数据就是不会经常被访问的数据。当缓存空间不足的时候，就会删除列表尾部的数据来提升程序运行效率。</p>
</div><div class="cl-preview-section"><h2 id="设计一个-lru-cache" style="font-size: 30px;">设计一个 LRU Cache</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">大多数注重算法能力的公司都会考相关的数据结构设计，<code>LRU Cache</code> 这个经典问题首当其冲，今天我就带着大家来实现一下它：</p>
</div><div class="cl-preview-section"><h4 id="lru-cache-的核心是什么？" style="font-size: 26px;"><code>LRU Cache</code> 的核心是什么？</h4>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><code>LRU cache</code> 相当于要维护一个跟时间顺序相关的数据结构，那么能找到最早更新元素的数据结构有 <code>queue</code>、<code>heap</code> 和 <code>LinkedList</code> 这几种：</p>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;"><code>queue</code> ：队列是先进先出的数据结构，我们确实知道哪一个元素是先进去的，哪一个元素是后进去的。</li>
<li style="font-size: 20px; line-height: 38px;"><code>heap</code> ：我们可以通过维护一个丢入时间 <code>time</code> 来确定哪一个元素是先进去的，哪一个元素是后进去的。</li>
<li style="font-size: 20px; line-height: 38px;"><code>LinkedList</code> ：链表有头部和尾部，我们自然而然可以利用头部来始终存放最新的元素（即最近使用的那个元素）</li>
</ul>
</div><div class="cl-preview-section"><h4 id="选择哪一种？" style="font-size: 26px;">选择哪一种？</h4>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">我们知道一旦某个中间进去的元素突然被调用后，我们就应该将它的位置更新到头部。频繁更新位置对于 <code>queue</code> 来说时间消耗太多，因此排除；</li>
<li style="font-size: 20px; line-height: 38px;">有时候我们要删除某一个很久不用的元素。如果用 <code>heap</code> 的话我们可能需要遍历所有的元素才能找到 time 为最早的那个节点，除非我们同时维护一个最小堆。但是每次更新元素位置还是需要 <code>O(lgN)</code> 的时间来调整，远不如 <code>LinkedList</code> 快；</li>
<li style="font-size: 20px; line-height: 38px;"><code>LinkedList</code> 对于插入删除元素只需要 <code>O(1)</code> 的时间，但是我们还需要能够快速地访问到指定需要被更新的元素。这一点 <code>LinkedList</code> 要用 <code>O(n)</code> 遍历，但是我们可以通过一个字典来对应 <code>key</code> 和 <code>node</code> 的信息，这样就可以用 <code>O(1)</code> 的时间来找到对应元素了；</li>
<li style="font-size: 20px; line-height: 38px;">再进一步，由于要随时删除指定的 <code>node</code>，我们还需要将该 <code>node</code> 前的 <code>node</code> 与其后方的 <code>node</code> 相连，所以会有一个找指定 <code>node</code> 前面一个 <code>node</code> 的需求。双向链表 <code>Doubly LinkedList</code> 就可以用 <code>O(1)</code> 时间来实现这个需求，所以我们确定使用<strong>双向链表 <code>Doubly LinkedList</code> 来完成一个<code>LRU Cache</code></strong>。</li>
</ul>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">确定了要使用的数据结构之后，我们来捋一捋接下来的思路：</p>
</div><div class="cl-preview-section"><h5 id="、lru-cache-整体设计：" style="font-size: 20px; line-height: 38px;">1、<code>LRU Cache</code> 整体设计：</h5>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><code>LRU Cache</code> 里面维护一个 <code>cache</code> 字典对应 <code>key</code> 和 <code>node</code> 的信息。一个 <code>cap</code> 表示最大容量，一个双向链表，其中 <code>head.next</code> 是 <code>most recently</code> （最近使用）的 <code>node</code>，<code>tail.prev</code> 是 <code>least recently</code>（最近最少使用） 的 <code>node</code>（即 <code>LRU</code> 容量满了会被删除的那个 <code>node</code>）。</p>
</div><div class="cl-preview-section"><h5 id="、对于-get-方法：" style="font-size: 20px; line-height: 38px;">2、对于 <code>get</code> 方法：</h5>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">如果 <code>key</code> 在 <code>cache</code> 字典中，说明 <code>node</code> 在链表中
<ul>
<li style="font-size: 20px; line-height: 38px;">根据 <code>key</code> 从 <code>cache</code> 字典中拿到对应的 <code>node</code>，从双向链表中删除这个 <code>node</code>，再向双向链表中重新插入这个 <code>node</code>（插入逻辑包含了更新到最新的位置）</li>
</ul>
</li>
<li style="font-size: 20px; line-height: 38px;">如果不在直接返回 <code>-1</code></li>
</ul>
</div><div class="cl-preview-section"><h5 id="、对于-put-方法：" style="font-size: 20px; line-height: 38px;">3、对于 <code>put</code> 方法：</h5>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">如果 <code>key</code> 在 <code>cache</code> 字典中，说明 <code>node</code> 在链表中
<ul>
<li style="font-size: 20px; line-height: 38px;">根据 <code>key</code> 从 <code>cache</code> 字典中拿到对应的 <code>node</code>，从双向链表中删除这个 <code>node</code>，再向双向链表中重新插入这个 <code>node</code>（插入逻辑包含了更新到最新的位置）</li>
</ul>
</li>
<li style="font-size: 20px; line-height: 38px;">如果 <code>key</code> 不在 <code>cache</code> 字典中，说明是一个新的 <code>node</code>
<ul>
<li style="font-size: 20px; line-height: 38px;">如果此时容量还没满的话：
<ul>
<li style="font-size: 20px; line-height: 38px;">生成新 <code>node</code>，插入双向链表中，同时放入 <code>cache</code> 中</li>
</ul>
</li>
<li style="font-size: 20px; line-height: 38px;">如果此时容量满了的话：
<ul>
<li style="font-size: 20px; line-height: 38px;">从双向链表中删除 <code>tail.prev</code>，即 <code>least recently</code> 的 <code>node</code></li>
<li style="font-size: 20px; line-height: 38px;">从 <code>cache</code> 中删除这个 <code>node</code> 的信息</li>
<li style="font-size: 20px; line-height: 38px;">生成新 <code>node</code>，插入双向链表中，放入 <code>cache</code> 中</li>
</ul>
</li>
</ul>
</li>
</ul>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">其中 <code>逻辑3</code> 中如果 <code>key</code> 不在 <code>cache</code> 字典中的这一段代码可以优化，</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">生成新 <code>node</code>，插入链表中，放入 <code>cache</code> 中这一步是重复的。</p>
</div><div class="cl-preview-section"><blockquote>
<p style="font-size: 20px; line-height: 38px;">其中 <code>逻辑3</code> 中如果 <code>key</code> 不在 <code>cache</code> 字典中的这一段代码可以优化。</p>
<p style="font-size: 20px; line-height: 38px;">优化的原因：生成新 <code>node</code>，插入链表中，放入 <code>cache</code> 中这一步是重复的。<br>
优化的方法：定义一个insert方法，当要执行这一步操作的时候直接调用即可。</p>
</blockquote>
</div><div class="cl-preview-section"><h2 id="具体代码实现" style="font-size: 30px;">具体代码实现</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">下面是用 <code>Python</code>、 <code>Java</code> 和 <code>Go</code> 实现的代码，直接提交到 <a href="https://leetcode.com/problems/lru-cache/">LeetCode</a> 对应题目也可以 <code>Accept</code> 哟:</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><em><strong>Python beats 95.66%</strong></em></p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>key <span class="token operator">=</span> key
        self<span class="token punctuation">.</span>val <span class="token operator">=</span> val
        self<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> <span class="token boolean">None</span>
        self<span class="token punctuation">.</span>prev <span class="token operator">=</span> <span class="token boolean">None</span>
        
        
<span class="token keyword">class</span> <span class="token class-name">LRUCache</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> capacity<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        :type capacity: int
        """</span>
        self<span class="token punctuation">.</span>cache <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
        self<span class="token punctuation">.</span>cap <span class="token operator">=</span> capacity
        self<span class="token punctuation">.</span>head <span class="token operator">=</span> Node<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>tail <span class="token operator">=</span> Node<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>head<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>tail
        self<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>prev <span class="token operator">=</span> self<span class="token punctuation">.</span>head

    <span class="token comment"># 从双向链表中删除这个 node</span>
    <span class="token keyword">def</span> <span class="token function">remove</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        n <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token builtin">next</span>
        p <span class="token operator">=</span> node<span class="token punctuation">.</span>prev
        p<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> n
        n<span class="token punctuation">.</span>prev <span class="token operator">=</span> p
        node<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> <span class="token boolean">None</span>
        node<span class="token punctuation">.</span>prev <span class="token operator">=</span> <span class="token boolean">None</span>
    
    <span class="token comment"># 向双向链表中插入 node，并放到最新位置</span>
    <span class="token keyword">def</span> <span class="token function">insert</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        n <span class="token operator">=</span> self<span class="token punctuation">.</span>head<span class="token punctuation">.</span><span class="token builtin">next</span>
        self<span class="token punctuation">.</span>head<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> node
        node<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> n
        n<span class="token punctuation">.</span>prev <span class="token operator">=</span> node
        node<span class="token punctuation">.</span>prev <span class="token operator">=</span> self<span class="token punctuation">.</span>head
        
    
    <span class="token keyword">def</span> <span class="token function">get</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        :type key: int
        :rtype: int
        """</span>
	<span class="token comment"># 如果 key 在 cache 字典中，说明 node在链表中</span>
        <span class="token keyword">if</span> key <span class="token keyword">in</span> self<span class="token punctuation">.</span>cache<span class="token punctuation">:</span>
	    <span class="token comment"># 根据 key 从 cache 字典中拿到对应的 node</span>
            node <span class="token operator">=</span> self<span class="token punctuation">.</span>cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
	    <span class="token comment"># 从双向链表中删除这个node</span>
            self<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>node<span class="token punctuation">)</span>
	    <span class="token comment"># 再向双向链表中重新插入这个 node（插入逻辑包含了更新到最新的位置）</span>
            self<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>node<span class="token punctuation">)</span>
            <span class="token keyword">return</span> node<span class="token punctuation">.</span>val
        <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token comment"># 如果不在直接返回 -1</span>
            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>
        

    <span class="token keyword">def</span> <span class="token function">put</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        :type key: int
        :type value: int
        :rtype: void
        """</span>
	<span class="token comment"># 如果 key 在 cache 字典中，说明 node 在链表中</span>
        <span class="token keyword">if</span> key <span class="token keyword">in</span> self<span class="token punctuation">.</span>cache<span class="token punctuation">:</span>
	    <span class="token comment"># 根据 key 从 cache 字典中拿到对应的 node</span>
            node <span class="token operator">=</span> self<span class="token punctuation">.</span>cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
	    <span class="token comment"># 更新 node 的 val</span>
            node<span class="token punctuation">.</span>val <span class="token operator">=</span> value
	    <span class="token comment"># 从双向链表中删除这个 `node`</span>
            self<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>node<span class="token punctuation">)</span>
	    <span class="token comment"># 再向双向链表中重新插入这个 node（插入逻辑包含了更新到最新的位置）</span>
            self<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>node<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token comment"># 如果 key 不在 cache 字典中，说明是一个新的 node</span>
	    <span class="token comment"># 如果此时容量满了的话，我们需要先删除 least recently 的 node</span>
            <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>cache<span class="token punctuation">)</span> <span class="token operator">==</span> self<span class="token punctuation">.</span>cap<span class="token punctuation">:</span>
                delete_node <span class="token operator">=</span> self<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>prev 
                <span class="token keyword">del</span> self<span class="token punctuation">.</span>cache<span class="token punctuation">[</span>delete_node<span class="token punctuation">.</span>key<span class="token punctuation">]</span>
                self<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>delete_node<span class="token punctuation">)</span>
            <span class="token comment"># 生成新 node</span>
            node <span class="token operator">=</span> Node<span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
	    <span class="token comment"># 插入双向链表中</span>
            self<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>node<span class="token punctuation">)</span>
	    <span class="token comment"># 同时放入 cache 中</span>
            self<span class="token punctuation">.</span>cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> node
            
            
<span class="token comment"># Your LRUCache object will be instantiated and called as such:</span>
<span class="token comment"># obj = LRUCache(capacity)</span>
<span class="token comment"># param_1 = obj.get(key)</span>
<span class="token comment"># obj.put(key,value)</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><em><strong>Java beats 85.25%</strong></em></p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashMap<span class="token punctuation">;</span>
<span class="token comment">/**
 * 维护一个类似双向链表的数据结构，包含前驱、后继以及 K-V 结构
 */</span>
<span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>
    Node next<span class="token punctuation">;</span>
    Node prev<span class="token punctuation">;</span>
    <span class="token keyword">int</span> key<span class="token punctuation">;</span>
    <span class="token keyword">int</span> val<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">LRUCache</span> <span class="token punctuation">{</span>
    <span class="token comment">// HashMap 保证插入结点和查找结点的时间复杂度为 O(1)</span>
    HashMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Node<span class="token operator">&gt;</span> map<span class="token punctuation">;</span>
    <span class="token comment">// head.next 是 most recently 的结点</span>
    Node head<span class="token punctuation">;</span>
    <span class="token comment">// tail.prev 是 least recently 的结点</span>
    Node tail<span class="token punctuation">;</span>
    <span class="token comment">// capacity 表示最大容量</span>
    <span class="token keyword">int</span> capacity<span class="token punctuation">;</span>
    <span class="token comment">// count 表示当前已有结点数</span>
    <span class="token keyword">int</span> count<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">LRUCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>
        map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        tail <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        head<span class="token punctuation">.</span>next <span class="token operator">=</span> tail<span class="token punctuation">;</span>
        tail<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果 key 在 HashMap 中，先拿到该结点，删除结点，再插入结点。</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Node node <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">remove</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">insert</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">.</span>val<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 如果不在就返回 -1</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果 key 在 HashMap 中，和 get 类似，也是先拿到该结点，删除结点，再插入结点。</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Node node <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
            node<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>
            <span class="token function">remove</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">insert</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果 key 不在 HashMap 中，那么是一个新的结点，直接插入即可。</span>
            Node node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">insert</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 在 map 中移除结点前，先将双向链表的指针指向进行修改</span>
            Node prev <span class="token operator">=</span> node<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>
            Node next <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> null<span class="token punctuation">;</span>
            node<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>
            next<span class="token punctuation">.</span>prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>
            prev<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>
            map<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
            count<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Node next <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        head<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>
        node<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>
        next<span class="token punctuation">.</span>prev <span class="token operator">=</span> node<span class="token punctuation">;</span>
        node<span class="token punctuation">.</span>prev <span class="token operator">=</span> head<span class="token punctuation">;</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>key<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        count<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token comment">// 如果结点数超过可允许容量，将 least recently 的结点移除</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&gt;</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">remove</span><span class="token punctuation">(</span>tail<span class="token punctuation">.</span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><em><strong>Go beats 50.00%</strong></em></p>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go"><span class="token keyword">type</span> Node <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	key<span class="token punctuation">,</span> val   <span class="token builtin">int</span>
	next<span class="token punctuation">,</span> prev <span class="token operator">*</span>Node
<span class="token punctuation">}</span>

<span class="token keyword">type</span> LRUCache <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	capa  <span class="token builtin">int</span>
	cache <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token operator">*</span>Node
	head  <span class="token operator">*</span>Node
	tail  <span class="token operator">*</span>Node
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">remove</span><span class="token punctuation">(</span>node <span class="token operator">*</span>Node<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 从双向链表中删除这个 node</span>
	n <span class="token operator">:=</span> node<span class="token punctuation">.</span>next
	p <span class="token operator">:=</span> node<span class="token punctuation">.</span>prev
	p<span class="token punctuation">.</span>next <span class="token operator">=</span> n
	n<span class="token punctuation">.</span>prev <span class="token operator">=</span> p
	node<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token boolean">nil</span>
	node<span class="token punctuation">.</span>prev <span class="token operator">=</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">insert</span><span class="token punctuation">(</span>this <span class="token operator">*</span>LRUCache<span class="token punctuation">,</span> node <span class="token operator">*</span>Node<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 向双向链表中插入 node，并放到最新位置</span>
	n <span class="token operator">:=</span> this<span class="token punctuation">.</span>head<span class="token punctuation">.</span>next
	this<span class="token punctuation">.</span>head<span class="token punctuation">.</span>next <span class="token operator">=</span> node

	node<span class="token punctuation">.</span>next <span class="token operator">=</span> n
	n<span class="token punctuation">.</span>prev <span class="token operator">=</span> node
	node<span class="token punctuation">.</span>prev <span class="token operator">=</span> this<span class="token punctuation">.</span>head
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">Constructor</span><span class="token punctuation">(</span>capacity <span class="token builtin">int</span><span class="token punctuation">)</span> LRUCache <span class="token punctuation">{</span>
	this <span class="token operator">:=</span> LRUCache<span class="token punctuation">{</span>
		capa<span class="token punctuation">:</span>  capacity<span class="token punctuation">,</span>
		cache<span class="token punctuation">:</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token operator">*</span>Node<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
		head<span class="token punctuation">:</span>  <span class="token operator">&amp;</span>Node<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
		tail<span class="token punctuation">:</span>  <span class="token operator">&amp;</span>Node<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
	<span class="token punctuation">}</span>
	this<span class="token punctuation">.</span>head<span class="token punctuation">.</span>next <span class="token operator">=</span> this<span class="token punctuation">.</span>tail
	this<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>prev <span class="token operator">=</span> this<span class="token punctuation">.</span>head
	<span class="token keyword">return</span> this
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>this <span class="token operator">*</span>LRUCache<span class="token punctuation">)</span> <span class="token function">Get</span><span class="token punctuation">(</span>key <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> node<span class="token punctuation">,</span> ok <span class="token operator">:=</span> this<span class="token punctuation">.</span>cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span> ok <span class="token punctuation">{</span> <span class="token comment">// 如果 `key` 在 `cache` 字典中，说明 `node` 在链表中</span>
		<span class="token function">remove</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token comment">// 从双向链表中删除这个 `node`</span>
		<span class="token function">insert</span><span class="token punctuation">(</span>this<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token comment">// 再向双向链表中重新插入这个 `node`（插入逻辑包含了更新到最新的位置）</span>
		<span class="token keyword">return</span> node<span class="token punctuation">.</span>val
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token comment">// 如果不在直接返回 `-1`</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>this <span class="token operator">*</span>LRUCache<span class="token punctuation">)</span> <span class="token function">Put</span><span class="token punctuation">(</span>key <span class="token builtin">int</span><span class="token punctuation">,</span> value <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> node<span class="token punctuation">,</span> ok <span class="token operator">:=</span> this<span class="token punctuation">.</span>cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span> ok <span class="token punctuation">{</span> <span class="token comment">// 如果 `key` 在 `cache` 字典中，说明 `node` 在链表中</span>
		node<span class="token punctuation">.</span>val <span class="token operator">=</span> value <span class="token comment">// 更新 node 的 val</span>
		<span class="token function">remove</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token comment">// 从双向链表中删除这个 `node`</span>
		<span class="token function">insert</span><span class="token punctuation">(</span>this<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token comment">// 再向双向链表中重新插入这个 `node`（插入逻辑包含了更新到最新的位置）</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 如果 `key` 不在 `cache` 字典中，说明是一个新的 `node`</span>
		<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>this<span class="token punctuation">.</span>cache<span class="token punctuation">)</span> <span class="token operator">==</span> this<span class="token punctuation">.</span>capa <span class="token punctuation">{</span>
			deleteNode <span class="token operator">:=</span> this<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>prev
			<span class="token function">delete</span><span class="token punctuation">(</span>this<span class="token punctuation">.</span>cache<span class="token punctuation">,</span> deleteNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span>
			<span class="token function">remove</span><span class="token punctuation">(</span>deleteNode<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
		node <span class="token operator">:=</span> <span class="token operator">&amp;</span>Node<span class="token punctuation">{</span> <span class="token comment">// 生成新 `node`</span>
			key<span class="token punctuation">:</span> key<span class="token punctuation">,</span>
			val<span class="token punctuation">:</span> value<span class="token punctuation">,</span>
		<span class="token punctuation">}</span>
		<span class="token function">insert</span><span class="token punctuation">(</span>this<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token comment">// 插入双向链表中</span>
		this<span class="token punctuation">.</span>cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> node <span class="token comment">// 同时放入 `cache` 中</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><h2 id="总结" style="font-size: 30px;">总结</h2>
</div><div class="cl-preview-section"><ol>
<li style="font-size: 20px; line-height: 38px;">看到一个问题我们要先问自己哪个地方是需要我们突破的，比如今天的难点就在于，如何通过我们想要实现的数据结构的所有特点来选取所需要的基础数据结构，这种能力也称为 <code>未知变已知</code> 的能力；</li>
<li style="font-size: 20px; line-height: 38px;">运用我们知道的最基本的数据结构的优劣势来思考该如何设计一个新的数据结构；</li>
<li style="font-size: 20px; line-height: 38px;">先不要着手于代码编写，可以在草稿纸上先画一下图，写一下之后的逻辑；</li>
<li style="font-size: 20px; line-height: 38px;">运用好已有的一些语言包来快速且准确地实现之前确定的逻辑；</li>
<li style="font-size: 20px; line-height: 38px;">此时代码可以 <code>work</code>，看看有没有值得优化的点，必要的话可以进行重构（参照代码可读性、代码可维护性、代码可扩展性、代码的效率），不要怕麻烦，要知道哪怕只是运行速度提高了一秒，对于自己也是一个巨大的进步；</li>
<li style="font-size: 20px; line-height: 38px;">做到这一步就已经 <code>over average</code> 了，一定是个大大的 <code>hire</code> 在等着你！</li>
</ol>
</div>}
                        </div>
                    </div>
                                            <!-- 买过的阅读 -->
                        <div class="art-next-prev clearfix">
                                                                                                <!-- 已买且开放 或者可以试读 -->
                                    <a href="/read/44/article/759">
                                                                    <div class="prev l clearfix">
                                        <div class="icon l">
                                            <i class="imv2-arrow3_l"></i>
                                        </div>
                                        <p>
                                            38 猫和老鼠
                                        </p>
                                    </div>
                                </a>
                                                                                                                            <!-- 已买且开放 或者可以试读 -->
                                    <a href="/read/44/article/762">
                                                                    <div class="next r clearfix">
                                        <p>
                                            40 专题2：二叉树遍历
                                        </p>
                                        <div class="icon r">
                                            <i class="imv2-arrow3_r"></i>
                                        </div>

                                    </div>
                                </a>
                                                    </div>
                                    </div>
                <div class="comments-con js-comments-con" id="coments_con">
                </div>

                
            </div>
            
            
            

        </div>
    </div>
</div>

<div class="modal modal-jiaQun-new hide" id="modal-jiaQun">
    <div class="inner" style="">
        <div class="modal-close js-close-jiaQun">
            <i class="imv2-close"></i>
        </div>
        <div class="content">
            <img src="https://img4.mukewang.com/5dad751a00019e3605400602.jpg">
            <div class="right-info">
                <div class="title">
                    扫码加入慕课前沿技术核心用户群
                </div>
                <div class="desc">
                                            <p class="mb6">验证信息：<span id="joincode">1908100602141755</span><span class="copy js-copy-joincode">复制</span></p>
                                        <p class="mb6">QQ讨论群号：853923473</p>
                                            <p>QQ群URL：<a href="https://jq.qq.com/?_wv=1027&amp;k=5CPxzEa" target="_blank">点击访问</a></p>
                                    </div>
            </div>
            <p class="tip">若遇到搜索不到QQ群或加群失败，请联系客服邮箱:kf@imooc.com</p>
        </div>
    </div>
</div>
 
<!-- 专栏介绍页专栏评价 -->

<!-- 专栏介绍页底部三条评价 -->

<!-- 专栏阅读页弹层目录和介绍页页面目录 -->

<!-- 专栏阅读页发布回复 -->

<!-- 专栏阅读页发布评论 -->

<!-- 专栏阅读页底部评论 -->

<!-- 专栏阅读 单个 评论 -->

<!-- 新增回复和展开三条以外回复 -->

<!-- 立即订阅的弹窗 -->












</div></body></html>