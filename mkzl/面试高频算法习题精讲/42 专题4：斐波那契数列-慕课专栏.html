<html><head><meta charset="utf-8"><title>42 专题4：斐波那契数列-慕课专栏</title>
			<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
			<meta name="renderer" content="webkit">
			<meta property="qc:admins" content="77103107776157736375">
			<meta property="wb:webmaster" content="c4f857219bfae3cb">
			<meta http-equiv="Access-Control-Allow-Origin" content="*">
			<meta http-equiv="Cache-Control" content="no-transform ">
			<meta http-equiv="Cache-Control" content="no-siteapp">
			<link rel="apple-touch-icon" sizes="76x76" href="https://www.imooc.com/static/img/common/touch-icon-ipad.png">
			<link rel="apple-touch-icon" sizes="120x120" href="https://www.imooc.com/static/img/common/touch-icon-iphone-retina.png">
			<link rel="apple-touch-icon" sizes="152x152" href="https://www.imooc.com/static/img/common/touch-icon-ipad-retina.png">
			<link href="https://moco.imooc.com/captcha/style/captcha.min.css" rel="stylesheet">
			<link rel="stylesheet" href="https://www.imooc.com/static/moco/v1.0/dist/css/moco.min.css?t=201907021539" type="text/css">
			<link rel="stylesheet" href="https://www.imooc.com/static/lib/swiper/swiper-3.4.2.min.css?t=201907021539">
			<link rel="stylesheet" href="https://static.mukewang.com/static/css/??base.css,common/common-less.css?t=2.5,column/zhuanlanChapter-less.css?t=2.5,course/inc/course_tipoff-less.css?t=2.5?v=201907051055" type="text/css">
			<link charset="utf-8" rel="stylesheet" href="https://www.imooc.com/static/lib/ueditor/themes/imooc/css/ueditor.css?v=201907021539"><link rel="stylesheet" href="https://www.imooc.com/static/lib/baiduShare/api/css/share_style0_16.css?v=6aba13f0.css"></head>
			<body><div id="main">


<div class="main-con hide-menu">
    <!-- 左侧菜单 & 索引 -->
    
    <div class="right-content" style="padding-left: 0px;">
        <div class="container clearfix" id="top" style="width: 1134px; display: block;">
            
            
            <div class="center_con js-center_con l" style="width: 1134px;">
                <div class="article-con">
                                            <!-- 买过的阅读 -->
                        

                    
                    <div class="art-title" style="margin-top: 0px;">
                        42 专题4：斐波那契数列
                    </div>
                    <div class="art-info clearfix">
                        
                        <span class="l">
                            更新时间：2019-10-14 10:04:40
                        </span>
                    </div>
                    <div class="art-top">
                                                <img src="https://img2.mukewang.com/5da3d7a500019b8806400359.jpg" alt="">
                                                                        <div class="famous-word-box">
                            <img src="https://www.imooc.com/static/img/column/bg-l.png" alt="" class="bg1 bg">
                            <img src="https://www.imooc.com/static/img/column/bg-r.png" alt="" class="bg2 bg">
                            <div class="famous-word">成功的奥秘在于目标的坚定。<p class="author">——迪斯雷利</p></div>
                        </div>
                                            </div>
                    <div class="art-content js-lookimg">
                        <div id="article_content">
                            <div class="cl-preview-section"><h3 id="什么是斐波那契数列？">什么是斐波那契数列？</h3>
</div><div class="cl-preview-section"><blockquote>
<p style="font-size: 20px; line-height: 38px;">斐波那契数列（Fibonacci sequence），又称<a href="https://baike.baidu.com/item/%E9%BB%84%E9%87%91%E5%88%86%E5%89%B2/115896">黄金分割</a>数列、因<a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%A6%E5%AE%B6/1210991">数学家</a>列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“<a href="https://baike.baidu.com/item/%E5%85%94%E5%AD%90%E6%95%B0%E5%88%97/6849441">兔子数列</a>”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波那契数列以如下被以<a href="https://baike.baidu.com/item/%E9%80%92%E6%8E%A8/1740695">递推</a>的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=3，n∈N*）在现代物理、准晶体结构、化学等领域，斐波纳契数列都有直接的应用</p>
<p style="font-size: 20px; line-height: 38px;">​																																							        ----以上来自维基百科</p>
</blockquote>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">上面的内容来自维基百科对于斐波那契数列的定义，大家在学校中应该都学习过斐波那契数列。在编程中斐波那契数列也是一道非常经典的面试题，下面我们来看几个问题来实践一下。</p>
</div><div class="cl-preview-section"><h4 id="问题一" style="font-size: 26px;">问题一</h4>
</div><div class="cl-preview-section"><pre><code>递推方程 f(n) = f(n - 1) + f(n - 2) ，已知 f(1) = 1，f(2) = 1，求第n项 （n &lt;= 30）
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">解析：</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">如果递归求这个问题，将会重复计算大量的状态，出现指数级的时间复杂度。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">当然可以使用递推的方式来解决这个方程。这里来一步一步理解记忆化搜素。</p>
</div><div class="cl-preview-section"><h5 id="理解函数" style="font-size: 20px; line-height: 38px;">理解函数</h5>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">一个代码片段，将输入的数据通过计算转成输出的数据。函数同样可以表示成y=f(x)，x表示输入数据，也就是状态，y表示函数的输出结果。所有x组成的集合叫状态空间。类比于数学上的函数，函数应当有以下特点：<br>
<code>唯一性：同一个状态x，函数值是唯一的</code><br>
这就要求我们尽可能将函数设计成跟环境无关的，只跟状态相关。</p>
</div><div class="cl-preview-section"><h5 id="理解递归" style="font-size: 20px; line-height: 38px;">理解递归</h5>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">很多人理解递归局限在代码调用代码中，于是很难理解递归什么时候跳出来，变量的值如何变。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">举个函数调用，上下文切换的例子：</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">假设说你要修电脑，先要用螺丝刀把机箱给打开，然后。。。<br>
等等，螺丝刀呢？没有螺丝刀咋办，买呗，于是你就把电脑丢下，跑出去买了一个螺丝刀。<br>
买回来之后，继续把机箱打开，发现内存条坏了，于是你就把电脑丢下，跑出去买了一个内存条（这里有个细节，机箱你是打开的，有两种做法，一种是打开着的机箱丢在地上，等买完内存条再回来继续，一种是把打开着的机箱装回去，等买完内存条再回来重新拆）。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">根据这个例子，再想一下什么是递归。递归本身就是个多层函数调用，只不过函数的代码都一样。大家理解递归调用，其实可以理解成，当前函数调用了<code>其他</code>的函数。函数调用就是，计算父任务时，需要子任务一，于是代码中把父任务挂起，先执行子任务，等到子任务执行完之后，再把结果返回到父任务这里。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">所以不管是递归，还是函数调用，都是有上下文的。每次调用，状态和环境变量都不一样。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">基于上下文的理解，大家可以尝试一下把前中后序遍历的代码从递归改成，用一个栈模拟递归，可以加深对上下文的理解。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><img class="" src="https://yudaer.oss-cn-hangzhou.aliyuncs.com/pic/1.png" data-original="https://yudaer.oss-cn-hangzhou.aliyuncs.com/pic/1.png" alt=""><br>
图为函数调用</p>
</div><div class="cl-preview-section"><h5 id="记忆化搜索" style="font-size: 20px; line-height: 38px;">记忆化搜索</h5>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">看上图，是第6项斐波那契数列的调用图，可以看出，计算第6项需要计算第4项的结果，计算第5项也需要计算第4项的结果，为了避免重复计算，我们需要将计算第4项的结果缓存起来，以便重复使用。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">递归过程中将函数的调用缓存起来，叫做记忆化搜索。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">记忆化搜索有个条件：需要遵循函数与环境无关的原则，也是说，一个函数参数必须唯一对应一个返回值，否则不能缓存。</p>
</div><div class="cl-preview-section"><pre><code>int cache[N]; //n如果有确切的范围，并且n比较小时，我们可以开个数组来存储函数值，存取函数值只有o(1)的复杂度
// map&lt;int, int&gt; cache; //如果没有确切的范围，或者n比较大时，我们需要利用映射数据结构来存储函数值，比如红黑树、哈希表
memset(cache, -1, sizeof(cache)); //-1表示cache还没计算过
int f(int n) {
    if (n &lt;= 2) {
        return 1;
    }
    if (cache[n] != -1) {
        return cache[n];    
    }
    return cache[n] = f(n - 1) + f(n - 2);
}
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">上面是个c++代码，如果用python写，那就更简单了，在函数上写个注解<code>@lru_cache(maxsize=N)</code>即可。</p>
</div><div class="cl-preview-section"><h4 id="问题二" style="font-size: 26px;">问题二</h4>
</div><div class="cl-preview-section"><pre><code>递推方程 f(n) = f(n - 1) + f(n - 2) ，已知 f(1) = 1，f(2) = 1，求第n项 （n &lt;= 80）
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">解析：</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">注意数据范围，n从30加到80。这个问题跟上一个问题解法一样，只是注意坑点，f(n)超过int的存储范围，因此需要使用64位整型，java为long，而python本身支持大整数计算，直接忽略这个坑点。</p>
</div><div class="cl-preview-section"><h4 id="问题三" style="font-size: 26px;">问题三</h4>
</div><div class="cl-preview-section"><pre><code>递推方程 f(n) = f(n - 1) + f(n - 2) ，已知 f(1) = 1，f(2) = 1，求第n项 （n &lt;= 10000），结果对10^9 + 7取模
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">解析：</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">注意数据范围，n从30加到10000。这个问题仍然跟上一个问题的解法一样，由于记忆化搜索复杂度是o(n)，对于10000范围内，妥妥的没问题。</p>
</div><div class="cl-preview-section"><h4 id="问题四" style="font-size: 26px;">问题四</h4>
</div><div class="cl-preview-section"><pre><code>递推方程 f(n) = f(n - 1) + f(n - 2) ，已知 f(1) = 1，f(2) = 1，求第n项 （n &lt;= 10^18），结果对10^9 + 7取模
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">解析：</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">n的数据范围超级大，达到10^18，已经无法用记忆化搜索或者递推来做，这就需要另一种做法。</p>
</div><div class="cl-preview-section"><h5 id="快速幂算法" style="font-size: 20px; line-height: 38px;">快速幂算法</h5>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">问题：<strong>求解<img class="" src="https://yudaer.oss-cn-hangzhou.aliyuncs.com/pic/5.gif" data-original="https://yudaer.oss-cn-hangzhou.aliyuncs.com/pic/5.gif" alt="">的值，b &lt;= 10 ^ 18。</strong></p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">循环b次，不断累乘a的做法肯定是行不通的，因为b特别大。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">我们推导一下：</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">当b为偶数时，令b = 2c ，</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">那么<img class="" src="https://yudaer.oss-cn-hangzhou.aliyuncs.com/pic/4.gif" data-original="https://yudaer.oss-cn-hangzhou.aliyuncs.com/pic/4.gif" alt="">，我们只需要求<img class="" src="https://yudaer.oss-cn-hangzhou.aliyuncs.com/pic/6.gif" data-original="https://yudaer.oss-cn-hangzhou.aliyuncs.com/pic/6.gif" alt="">，就可以以o(1)的时间复杂度得到<img class="" src="https://yudaer.oss-cn-hangzhou.aliyuncs.com/pic/7.gif" data-original="https://yudaer.oss-cn-hangzhou.aliyuncs.com/pic/7.gif" alt="；"></p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">当b为奇数时，令b = 2c  + 1，</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">那么<img class="" src="https://yudaer.oss-cn-hangzhou.aliyuncs.com/pic/8.gif" data-original="https://yudaer.oss-cn-hangzhou.aliyuncs.com/pic/8.gif" alt="">，我们同样只需要求<img class="" src="https://yudaer.oss-cn-hangzhou.aliyuncs.com/pic/6.gif" data-original="https://yudaer.oss-cn-hangzhou.aliyuncs.com/pic/6.gif" alt="">，就可以以o(1)的时间复杂度得到<img class="" src="https://yudaer.oss-cn-hangzhou.aliyuncs.com/pic/7.gif" data-original="https://yudaer.oss-cn-hangzhou.aliyuncs.com/pic/7.gif" alt=""></p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">不断地求解子问题，从而得到<img class="" src="https://yudaer.oss-cn-hangzhou.aliyuncs.com/pic/7.gif" data-original="https://yudaer.oss-cn-hangzhou.aliyuncs.com/pic/7.gif" alt="">的结果。由于子问题<img class="" src="https://yudaer.oss-cn-hangzhou.aliyuncs.com/pic/6.gif" data-original="https://yudaer.oss-cn-hangzhou.aliyuncs.com/pic/6.gif" alt="">的c是问题a^ b的b的一半，因此这个算法复杂度是o(log b)。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">代码：</p>
</div><div class="cl-preview-section"><pre class="  language-c"><code class="prism ++  language-c"><span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span>  <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span> <span class="token keyword">return</span> a <span class="token operator">%</span> k<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token comment">//求解a ^ (b / 2)</span>
    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//求解 (a ^ (b / 2)) ^ 2</span>
    ret <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span> ret <span class="token operator">*</span> ret <span class="token operator">%</span> k<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//处理b是奇数的情况，多乘了一次a</span>
        ret <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span> ret <span class="token operator">*</span>a <span class="token operator">%</span> k<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><h5 id="斐波那契数列的快速幂算法" style="font-size: 20px; line-height: 38px;">斐波那契数列的快速幂算法</h5>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">将递推方程转化一下：</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><img class="" src="https://yudaer.oss-cn-hangzhou.aliyuncs.com/pic/9.gif" data-original="https://yudaer.oss-cn-hangzhou.aliyuncs.com/pic/9.gif" alt=""></p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">大家应该能够理解矩阵的吧，矩阵上一行表示f(n) = f(n - 1) + f(n - 2)，下一行表示f(n-1) = f(n-1)。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">那么我们将这个转化后的递推方程，转化成矩阵的幂：</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><img class="" src="https://yudaer.oss-cn-hangzhou.aliyuncs.com/pic/11.gif" data-original="https://yudaer.oss-cn-hangzhou.aliyuncs.com/pic/11.gif" alt=""></p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">套用上面介绍的快速幂算法，我们可以很快求出矩阵的n次幂。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">至此斐波那契数列的4个问题，都解决：</p>
</div><div class="cl-preview-section"><pre class="  language-c"><code class="prism ++  language-c">Matrix <span class="token function">mod</span><span class="token punctuation">(</span>Matrix<span class="token operator">&amp;</span> A<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
Matrix <span class="token function">multiply</span><span class="token punctuation">(</span>Matrix<span class="token operator">&amp;</span> A<span class="token punctuation">,</span> Matrix<span class="token operator">&amp;</span> B<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">pow</span><span class="token punctuation">(</span>Matrix<span class="token operator">&amp;</span> A<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span>  <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">mod</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    Matrix ret <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ret <span class="token operator">=</span> <span class="token function">multiply</span><span class="token punctuation">(</span>ret<span class="token punctuation">,</span> ret<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ret <span class="token operator">=</span> <span class="token function">multiply</span><span class="token punctuation">(</span>ret<span class="token punctuation">,</span> a<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><h4 id="拓展-fibonacci-的dp版本" style="font-size: 26px;">拓展 Fibonacci 的DP版本</h4>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">对于DP的不同理解造成不同的写法。记忆化通常会增加你的时间复杂度，从而增加空间复杂度（例如，使用制表法，你可以自由地放弃计算，例如使用Fib的制表法可以使用O（1）空间，而使用Fib的制表法则可以使用O（N）堆栈空间）。</p>
</div><div class="cl-preview-section"><blockquote>
<p style="font-size: 20px; line-height: 38px;">详细可以参考下面两份文档：</p>
<p style="font-size: 20px; line-height: 38px;"><a href="https://awjin.me/algos-js/dp/tab-memo.html">Dynamic programming and memoization: bottom-up vs top-down approaches</a></p>
<p style="font-size: 20px; line-height: 38px;"><a href="http://www.geeksforgeeks.org/tabulation-vs-memoizatation/">Tabulation vs Memoizatation</a></p>
</blockquote>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">top-down(memorize)：</li>
</ul>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">def</span> <span class="token function">memorize_fib</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># n为第几个Fibonacci数</span>
    memo <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">}</span>
    <span class="token keyword">if</span> n <span class="token keyword">in</span> memo<span class="token punctuation">:</span>
        <span class="token keyword">return</span> memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> memorize_fib<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token operator">+</span> memorize_fib<span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>memorize_fib<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 输出3</span>
</code></pre>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">bottom up(tabulation)：</li>
</ul>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">def</span> <span class="token function">tabulation_fib</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># n为第几个Fibonacci数</span>
    fib <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span>
    <span class="token keyword">if</span> n <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> fib<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> k <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        fib<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> fib<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> fib<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
        fib<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> fib<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> fib<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> fib<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>
    <span class="token keyword">return</span> fib<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>tabulation_fib<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 输出3</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这里memo用dict，用array也一样。当然用bottom up还有一点，可以只存每次最后两个数，可以save space.，这样就只用到constant space，还可以直接借用工具。</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">import</span> functools


@functools<span class="token punctuation">.</span>lru_cache<span class="token punctuation">(</span>maxsize<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">fib</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> n <span class="token operator">&lt;=</span> <span class="token number">2</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token number">1</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> fib<span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> fib<span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span>


<span class="token keyword">print</span><span class="token punctuation">(</span>fib<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 55=</span>
</code></pre>
</div><div class="cl-preview-section"><h3 id="小结">小结</h3>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这节课我们认识了下斐波那契数列，同学们可以自己动手实现一下，这个知识点在面试的时候还是很常见的。我在很多家公司的面试题中都有看到过，大家一定要掌握。</p>
</div>}
                        </div>
                    </div>
                                            <!-- 买过的阅读 -->
                        <div class="art-next-prev clearfix">
                                                                                                <!-- 已买且开放 或者可以试读 -->
                                    <a href="/read/44/article/764">
                                                                    <div class="prev l clearfix">
                                        <div class="icon l">
                                            <i class="imv2-arrow3_l"></i>
                                        </div>
                                        <p>
                                            41 专题3：二分算法
                                        </p>
                                    </div>
                                </a>
                                                                                                                            <!-- 已买且开放 或者可以试读 -->
                                    <a href="/read/44/article/763">
                                                                    <div class="next r clearfix">
                                        <p>
                                            43 专题5：大整数
                                        </p>
                                        <div class="icon r">
                                            <i class="imv2-arrow3_r"></i>
                                        </div>

                                    </div>
                                </a>
                                                    </div>
                                    </div>
                <div class="comments-con js-comments-con" id="coments_con">
                </div>

                
            </div>
            
            
            

        </div>
    </div>
</div>

<div class="modal modal-jiaQun-new hide" id="modal-jiaQun">
    <div class="inner" style="">
        <div class="modal-close js-close-jiaQun">
            <i class="imv2-close"></i>
        </div>
        <div class="content">
            <img src="https://img1.mukewang.com/5dad751a00019e3605400602.jpg">
            <div class="right-info">
                <div class="title">
                    扫码加入慕课前沿技术核心用户群
                </div>
                <div class="desc">
                                            <p class="mb6">验证信息：<span id="joincode">1908100602141755</span><span class="copy js-copy-joincode">复制</span></p>
                                        <p class="mb6">QQ讨论群号：853923473</p>
                                            <p>QQ群URL：<a href="https://jq.qq.com/?_wv=1027&amp;k=5CPxzEa" target="_blank">点击访问</a></p>
                                    </div>
            </div>
            <p class="tip">若遇到搜索不到QQ群或加群失败，请联系客服邮箱:kf@imooc.com</p>
        </div>
    </div>
</div>
 
<!-- 专栏介绍页专栏评价 -->

<!-- 专栏介绍页底部三条评价 -->

<!-- 专栏阅读页弹层目录和介绍页页面目录 -->

<!-- 专栏阅读页发布回复 -->

<!-- 专栏阅读页发布评论 -->

<!-- 专栏阅读页底部评论 -->

<!-- 专栏阅读 单个 评论 -->

<!-- 新增回复和展开三条以外回复 -->

<!-- 立即订阅的弹窗 -->












</div></body></html>