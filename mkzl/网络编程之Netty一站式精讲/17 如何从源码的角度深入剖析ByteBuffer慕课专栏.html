<html><head><meta charset="utf-8"><title> 17 如何从源码的角度深入剖析ByteBuffer-慕课专栏</title>
			<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
			<meta name="renderer" content="webkit">
			<meta property="qc:admins" content="77103107776157736375">
			<meta property="wb:webmaster" content="c4f857219bfae3cb">
			<meta http-equiv="Access-Control-Allow-Origin" content="*">
			<meta http-equiv="Cache-Control" content="no-transform ">
			<meta http-equiv="Cache-Control" content="no-siteapp">
			<link rel="apple-touch-icon" sizes="76x76" href="https://www.imooc.com/static/img/common/touch-icon-ipad.png">
			<link rel="apple-touch-icon" sizes="120x120" href="https://www.imooc.com/static/img/common/touch-icon-iphone-retina.png">
			<link rel="apple-touch-icon" sizes="152x152" href="https://www.imooc.com/static/img/common/touch-icon-ipad-retina.png">
			<link href="https://moco.imooc.com/captcha/style/captcha.min.css" rel="stylesheet">
			<link rel="stylesheet" href="https://www.imooc.com/static/moco/v1.0/dist/css/moco.min.css?t=201907021539" type="text/css">
			<link rel="stylesheet" href="https://www.imooc.com/static/lib/swiper/swiper-3.4.2.min.css?t=201907021539">
			<link rel="stylesheet" href="../zhuanlanChapter-less.css?v=201907051055" type="text/css">
			<link charset="utf-8" rel="stylesheet" href="https://www.imooc.com/static/lib/ueditor/themes/imooc/css/ueditor.css?v=201907021539"><link rel="stylesheet" href="https://www.imooc.com/static/lib/baiduShare/api/css/share_style0_16.css?v=6aba13f0.css"></head>
			<body><div id="main">


<div class="main-con hide-menu">
    <!-- 左侧菜单 & 索引 -->
    
    <div class="right-content" style="padding-left: 0px;">
        <div class="container clearfix" id="top" style="width: 1134px; display: block;">
            
            
            <div class="center_con js-center_con l" style="width: 1134px;">
                <div class="article-con">
                                            <!-- 买过的阅读 -->
                        

                    
                    <div class="art-title" style="margin-top: 0px;">
                         17 如何从源码的角度深入剖析ByteBuffer
                    </div>
                    <div class="art-info clearfix">
                        
                        <span class="l">
                            更新时间：2020-07-31 09:42:39
                        </span>
                    </div>
                    <div class="art-top">
                                                <img src="https://img4.sycdn.imooc.com/5f0595e70001d1d306400359.jpg" alt="">
                                                                        <div class="famous-word-box">
                            <img src="https://www.imooc.com/static/img/column/bg-l.png" alt="" class="bg1 bg">
                            <img src="https://www.imooc.com/static/img/column/bg-r.png" alt="" class="bg2 bg">
                            <div class="famous-word">生活的理想，就是为了理想的生活。——张闻天<p></p></div>
                        </div>
                                            </div>
                    <div class="art-content js-lookimg">
                        <div id="article_content">
                            <div class="cl-preview-section"><h1 id="前言">前言</h1>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">你好，我是彤哥。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">前面的章节，我们一起从数据流向的角度剖析了 Netty 的源码，包括服务的启动、接收新的连接或数据、写出数据、关闭服务等。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">然而，从数据流向的角度只能窥见 Netty 很小一部分的源码，比如，你只看见了调用一个方法就能创建符合要求的 ByteBuf 却不知为何如此简单，你只看见了 Netty 使用了线程池却不知线程池用的是什么队列，你只看见了 Netty 到处都在使用 Promise 却不知 Promise 为何物。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">所以，从本节开始，我们将从 Netty 核心知识的角度来剖析源码，同时，我们也会一起学习很多 Java 中的高阶技巧。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">在前面的章节，我们多多少少地介绍过一些 ByteBuffer、ByteBuf 相关的知识，但是它们还不全面，所以，本节，我想先从 Java 原生的 ByteBuffer 入手，来更好地过渡到 Netty 的源码设计。</p>
</div><div class="cl-preview-section"><h1 id="问题">问题</h1>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">我们知道，Netty 之所以如此高效，很大一部分原因得益于其对直接内存的高效使用，所以，今天，我想问：</p>
</div><div class="cl-preview-section"><ol>
<li style="font-size: 20px; line-height: 38px;">Java 中的 ByteBuffer 有直接内存的实现吗？</li>
<li style="font-size: 20px; line-height: 38px;">Java 中如何使用直接内存？又如何释放直接内存呢？</li>
<li style="font-size: 20px; line-height: 38px;">Java 中 ByteBuffer 的直接内存实现又是如何管理直接内存的？</li>
</ol>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">好了，让我们带着这些问题进入今天的探索吧。</p>
</div><div class="cl-preview-section"><h1 id="buffer的分类">Buffer 的分类</h1>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">经过前面的学习，我们知道，Buffer 按照不同的维度有不同的分类，大体上有两种主要的维度，按照数据类型分为 ByteBuffer、CharBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer 等，按照内存实现可以分为堆内存实现和直接内存实现。其实，还有另一种不太常见的维度，按照读写的维度分为只读和可读写，一般来说，只读的 Buffer 后面以 <code>R</code> 结尾，比如 HeapByteBufferR，这种比较少见，有兴趣的同学可以自己看看相关的源码。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">今天我们的主角是堆内存实现和直接内存实现，它们分别是怎么实现的呢？有什么区别吗？</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">不过，在正式介绍之前，我想讲另外一个非常有意思的类，我把它称作 Java 中的魔法类 ——Unsafe。</p>
</div><div class="cl-preview-section"><h1 id="不安全的unsafe">不安全的 Unsafe</h1>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">看过并发集合或者原子类源码的同学，应该对 Unsafe 这个类印象比较深刻，像我们经常使用的 <code>CAS</code> 操作，底层就是使用 Unsafe 来实现的，比如，AtomicInteger 中的 compareAndSet () 方法：</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> expect<span class="token punctuation">,</span> <span class="token keyword">int</span> update<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> expect<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">然而，Unsafe 的功能远远不止 <code>CAS</code> 这一种操作，有兴趣的同学可以看看这篇文章【<a href="https://mp.weixin.qq.com/s/0s-u-MysppIaIHVrshp9fA">死磕 java 魔法类之 Unsafe 解析</a>】，今天，我们再介绍一种 Unsafe 不太常见的功能 —— 操作直接内存。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">Unsafe 操作直接内存是通过下面几个方法实现的：</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java"><span class="token comment">// 分配内存</span>
<span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">long</span> <span class="token function">allocateMemory</span><span class="token punctuation">(</span><span class="token keyword">long</span> var1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 释放内存</span>
<span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">freeMemory</span><span class="token punctuation">(</span><span class="token keyword">long</span> var1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 设置内存值</span>
<span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">setMemory</span><span class="token punctuation">(</span>Object var1<span class="token punctuation">,</span> <span class="token keyword">long</span> var2<span class="token punctuation">,</span> <span class="token keyword">long</span> var4<span class="token punctuation">,</span> <span class="token keyword">byte</span> var6<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 设置某种类型的值，比如putInt()</span>
<span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">putXxx</span><span class="token punctuation">(</span><span class="token keyword">long</span> var1<span class="token punctuation">,</span> xxx var3<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 获取某种类型的值，比如getInt()</span>
<span class="token keyword">public</span> <span class="token keyword">native</span> xxx <span class="token function">getXxx</span><span class="token punctuation">(</span><span class="token keyword">long</span> var1<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">比如，我们可以使用 Unsafe 来实现一个直接内存实现的 <code>int</code> 数组。</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DirectIntArray</span> <span class="token punctuation">{</span>
    <span class="token comment">// 一个int等于4个字节</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> INT <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">long</span> size<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">long</span> address<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> Unsafe unsafe<span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// Unsafe类有权限访问控制，只能通过反射获取其实例</span>
            Field f <span class="token operator">=</span> Unsafe<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"theUnsafe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            f<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            unsafe <span class="token operator">=</span> <span class="token punctuation">(</span>Unsafe<span class="token punctuation">)</span> f<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchFieldException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IllegalAccessException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token function">DirectIntArray</span><span class="token punctuation">(</span><span class="token keyword">long</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> size<span class="token punctuation">;</span>
        <span class="token comment">// 参数字节数</span>
        address <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">allocateMemory</span><span class="token punctuation">(</span>size <span class="token operator">*</span> INT<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 获取某位置的值</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">long</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;=</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ArrayIndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span>address <span class="token operator">+</span> i <span class="token operator">*</span> INT<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 设置某位置的值</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">long</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;=</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ArrayIndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        unsafe<span class="token punctuation">.</span><span class="token function">putInt</span><span class="token punctuation">(</span>address <span class="token operator">+</span> i <span class="token operator">*</span> INT<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 数组大小</span>
    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> size<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 释放内存</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">freeMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        unsafe<span class="token punctuation">.</span><span class="token function">freeMemory</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 创建数组并赋值</span>
        DirectIntArray array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DirectIntArray</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        array<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        array<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        array<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        array<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 下面这行数组越界了</span>
<span class="token comment">//        array.set(5, 5);</span>

        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            sum <span class="token operator">+=</span> array<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 打印10</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 最后别忘记释放内存</span>
        array<span class="token punctuation">.</span><span class="token function">freeMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">最后，一定别忘了释放内存，这是操作直接内存的一个非常 “不安全的” 地方，谨记！</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">好了，有了上面的介绍，相信你对 Java 中如何操作直接内存一定有了非常清晰的认识，其实，也是非常简单的。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">下面，我们就正式地来揭开 Java 中堆内存和直接内存两种方式实现的 ByteBuffer 的神秘面纱。</p>
</div><div class="cl-preview-section"><h1 id="宏观分析bytebuffer">宏观分析 ByteBuffer</h1>
</div><div class="cl-preview-section"><blockquote>
<p style="font-size: 20px; line-height: 38px;">学习源码一般遵循着先宏观再微观的原则。宏观上，一般先看继承体系，类的基本结构等，通过这种方式一般能找到一到两个突破口。微观上，一般根据宏观找到的突破口，进入调试，调试，调试。很多同学看源码喜欢干看，其实是不对的，一定要调试，不调试就无法掌握细节。<br>
<img class="" src="https://img1.sycdn.imooc.com/5f1f821400012d9f04500487.png" data-original="//img1.sycdn.imooc.com/5f1f821400012d9f04500487.png" alt="图片描述"></p>
</blockquote>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">从继承体系上，ByteBuffer 是一个抽象类，它继承自 Buffer 抽象类，它有两个主要实现类 ——HeapByteBuffer 和 DirectByteBuffer，其中 DirectByteBuffer 和 ByteBuffer 之间还有一个 MappedByteBuffer，另外，这两个实现类分别还有自己的只读模式，即 HeapByteBufferR 和 DirectByteBufferR。</p>
</div><div class="cl-preview-section"><blockquote>
<p style="font-size: 20px; line-height: 38px;">MappedByteBuffer 是做什么的呢？本节的知识点不涉及到这个类，有兴趣的同学可以自己探索。</p>
</blockquote>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">从类的基本结构上，ByteBuffer 包含两个非常重要的方法：</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java"><span class="token comment">// 创建一个直接内存实现的ByteBuffer</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> ByteBuffer <span class="token function">allocateDirect</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DirectByteBuffer</span><span class="token punctuation">(</span>capacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 创建一个堆内存实现的ByteBuffer</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> ByteBuffer <span class="token function">allocate</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>capacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">HeapByteBuffer</span><span class="token punctuation">(</span>capacity<span class="token punctuation">,</span> capacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这两个方法就是我们微观分析时需要使用到的突破口。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">另外，还包含一些操作 ByteBuffer 的方法，主要是 put () 和 get ()，以及切片、子集等，与数组或者集合 list 的操作方法比较类似，这里就不一一列举了。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">有了上面的突破口，我们就可以正式进入微观分析阶段了，即调试。</p>
</div><div class="cl-preview-section"><h1 id="微观分析bytebuffer">微观分析 ByteBuffer</h1>
</div><div class="cl-preview-section"><h2 id="堆内存实现的bytebuffer——heapbytebuffer" style="font-size: 30px;">堆内存实现的 ByteBuffer——HeapByteBuffer</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">既然要调试，当然要写调试用例啦，我这里也准备了一个调试用例：</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ByteBufferTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 1. 创建一个堆内存实现的ByteBuffer</span>
        ByteBuffer buffer <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 2. 写入值</span>
        buffer<span class="token punctuation">.</span><span class="token function">putInt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        buffer<span class="token punctuation">.</span><span class="token function">putInt</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        buffer<span class="token punctuation">.</span><span class="token function">putInt</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 3. 切换为读模式</span>
        buffer<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 4. 读取值</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">OK，我们要开始调试了，你准备好了么？！Let’s go!</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">让我们把断点打在 <code>ByteBuffer buffer = ByteBuffer.allocate(12);</code> 这行，跟踪进去：</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java"><span class="token comment">// 1. 创建堆内存实现的ByteBuffer</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> ByteBuffer <span class="token function">allocate</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>capacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">HeapByteBuffer</span><span class="token punctuation">(</span>capacity<span class="token punctuation">,</span> capacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 2. HeapByteBuffer的构造方法</span>
<span class="token function">HeapByteBuffer</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap<span class="token punctuation">,</span> <span class="token keyword">int</span> lim<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// package-private</span>
    <span class="token comment">// lim = cap = 12</span>
    <span class="token comment">// 创建了一个12大小的byte数组</span>
    <span class="token comment">// 调用父构造方法</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> lim<span class="token punctuation">,</span> cap<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span>cap<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 3. ByteBuffer的构造方法</span>
<span class="token function">ByteBuffer</span><span class="token punctuation">(</span><span class="token keyword">int</span> mark<span class="token punctuation">,</span> <span class="token keyword">int</span> pos<span class="token punctuation">,</span> <span class="token keyword">int</span> lim<span class="token punctuation">,</span> <span class="token keyword">int</span> cap<span class="token punctuation">,</span>   <span class="token comment">// package-private</span>
           <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> hb<span class="token punctuation">,</span> <span class="token keyword">int</span> offset<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 调用父构造方法</span>
    <span class="token comment">// pos = 0，默认创建的就是写模式</span>
    <span class="token comment">// lim = cap = 12</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>mark<span class="token punctuation">,</span> pos<span class="token punctuation">,</span> lim<span class="token punctuation">,</span> cap<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// byte数组hb（heap buffer），为上面传过来的new byte[cap]</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>hb <span class="token operator">=</span> hb<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>offset <span class="token operator">=</span> offset<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 4. Buffer的构造方法</span>
<span class="token function">Buffer</span><span class="token punctuation">(</span><span class="token keyword">int</span> mark<span class="token punctuation">,</span> <span class="token keyword">int</span> pos<span class="token punctuation">,</span> <span class="token keyword">int</span> lim<span class="token punctuation">,</span> <span class="token keyword">int</span> cap<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment">// package-private</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cap <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Negative capacity: "</span> <span class="token operator">+</span> cap<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 三个非常重要的变量：capacity、limit、position</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> cap<span class="token punctuation">;</span>
    <span class="token function">limit</span><span class="token punctuation">(</span>lim<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">position</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mark <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>mark <span class="token operator">&gt;</span> pos<span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"mark &gt; position: ("</span>
                                               <span class="token operator">+</span> mark <span class="token operator">+</span> <span class="token string">" &gt; "</span> <span class="token operator">+</span> pos <span class="token operator">+</span> <span class="token string">")"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>mark <span class="token operator">=</span> mark<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">整个创建的过程非常简单，主要包含以下逻辑：</p>
</div><div class="cl-preview-section"><ol>
<li style="font-size: 20px; line-height: 38px;">创建了一个 byte 数组保存在 hb 这个变量中；</li>
<li style="font-size: 20px; line-height: 38px;">给几个重要的变量赋值，比如 capacity、limit、position，还有一个 mark，感兴趣的同学可以自己看看这个变量的作用；</li>
<li style="font-size: 20px; line-height: 38px;">默认创建的 ByteBuffer 为写模式，因为 position 从 0 开始且 capacity=limit = 数组大小；</li>
</ol>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">还记得写模式吗？还记得 capacity、limit、position 这三个重要的属性吗？让我们把前面的图再拿出来回顾一下。<br>
<img class="" src="https://img1.sycdn.imooc.com/5f1f83320001a6d110300419.png" data-original="//img1.sycdn.imooc.com/5f1f83320001a6d110300419.png" alt="图片描述"></p>
</div><div class="cl-preview-section"><blockquote>
<p style="font-size: 20px; line-height: 38px;">在上面的左图中，limit=capacity=8，表示的是数组的大小，而数组的下标是从 0 开始的，所以这里指向了数组最大位置的下一个位置。position 表示的是下一次写入的位置，从 0 开始，与数组的下标保持一致，所以，这里的 position 最大只能等于 8，也就是 limit 的值，当等于 8 时再写入，就溢出了（8 这个位置不会写入数据）。</p>
</blockquote>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">OK，到这里 ByteBuffer 我们就创建好了，所谓堆内存的实现方式，就是使用的 Java 自带的 byte 数组来实现的，让我们再来看看写入 putInt () 这个方法是如何实现的。</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java"><span class="token comment">// 写入一个int类型的数值</span>
<span class="token keyword">public</span> ByteBuffer <span class="token function">putInt</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 调用Bits工具类的putInt()方法，Bits是位的意思</span>
    <span class="token comment">// 堆内存的实现中使用大端法来存储数据</span>
    Bits<span class="token punctuation">.</span><span class="token function">putInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token function">ix</span><span class="token punctuation">(</span><span class="token function">nextPutIndex</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> bigEndian<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 移动position到下一个位置</span>
<span class="token comment">// 因为一个int占4个字节，所以这里往后移动4位</span>
<span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">nextPutIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span> nb<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment">// package-private</span>
    <span class="token comment">// 判断有没有越界</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>limit <span class="token operator">-</span> position <span class="token operator">&lt;</span> nb<span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BufferOverflowException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> p <span class="token operator">=</span> position<span class="token punctuation">;</span>
    position <span class="token operator">+=</span> nb<span class="token punctuation">;</span>
    <span class="token comment">// 注意，这里返回的是移动前的位置，初始值为0</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 计算写入的偏移量，初始值为0</span>
<span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">ix</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> i <span class="token operator">+</span> offset<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// java.nio.Bits#putInt(java.nio.ByteBuffer, int, int, boolean)</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">putInt</span><span class="token punctuation">(</span>ByteBuffer bb<span class="token punctuation">,</span> <span class="token keyword">int</span> bi<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">boolean</span> bigEndian<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 堆内存使用的是大端法，更符合人们的习惯</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>bigEndian<span class="token punctuation">)</span>
        <span class="token comment">// 大端法</span>
        <span class="token function">putIntB</span><span class="token punctuation">(</span>bb<span class="token punctuation">,</span> bi<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token function">putIntL</span><span class="token punctuation">(</span>bb<span class="token punctuation">,</span> bi<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// java.nio.Bits#putIntB(java.nio.ByteBuffer, int, int)</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">putIntB</span><span class="token punctuation">(</span>ByteBuffer bb<span class="token punctuation">,</span> <span class="token keyword">int</span> bi<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 把一个int拆分成4个byte，分别写入</span>
    <span class="token comment">// int3(int x) { return (byte)(x &gt;&gt; 24); }</span>
    bb<span class="token punctuation">.</span><span class="token function">_put</span><span class="token punctuation">(</span>bi    <span class="token punctuation">,</span> <span class="token function">int3</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// int2(int x) { return (byte)(x &gt;&gt; 16); }</span>
    bb<span class="token punctuation">.</span><span class="token function">_put</span><span class="token punctuation">(</span>bi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token function">int2</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// int1(int x) { return (byte)(x &gt;&gt;  8); }</span>
    bb<span class="token punctuation">.</span><span class="token function">_put</span><span class="token punctuation">(</span>bi <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token function">int1</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// int0(int x) { return (byte)(x      ); }</span>
    bb<span class="token punctuation">.</span><span class="token function">_put</span><span class="token punctuation">(</span>bi <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token function">int0</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// java.nio.HeapByteBuffer#_put</span>
<span class="token keyword">void</span> <span class="token function">_put</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">byte</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token comment">// package-private</span>
    <span class="token comment">// 最终变成了修改byte数组</span>
    hb<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">写入方法无非就是根据当前 position 的位置往后写入一个 int 大小的数据，写入的时候会把 int 拆分成 4 个 byte 分别写入，而最终其实就是修改前面创建的 byte 数组。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">OK，同样地，读取方法应该就是先根据当前 position 计算读取的偏移量，再从数组中读取 4 个字节的数据，最后再拼装成一个 int 类型返回。这块的代码相对来说都比较简单，我们就不一一细看了。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">综上所述，HeapByteBuffer 内部使用 byte 数组来存储数据，并根据 position 来写入或者读取数据，既然使用的是 Java 中的类型，自然使用的是堆内存。</p>
</div><div class="cl-preview-section"><h2 id="直接内存实现的bytebuffer——directbytebuffer" style="font-size: 30px;">直接内存实现的 ByteBuffer——DirectByteBuffer</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">上面我们简单介绍了 HeapByteBuffer，它主要是使用 byte 数组来实现的，那么，DirectByteBuffer 是如何实现的呢？通过上面我们讲解的 Unsafe，结合 HeapByteBuffer 的实现，你能自己实现一个 DirectByteBuffer 吗，就像直接内存实现的 DirectIntArray 一样？</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">建议先想好这几个问题，再接着看下面的源码分析。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">同样地，我们还是使用上面的调试用例，只不过改动一个方法：</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ByteBufferTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 创建一个直接内存实现的ByteBuffer</span>
        ByteBuffer buffer <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocateDirect</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 写入值</span>
        buffer<span class="token punctuation">.</span><span class="token function">putInt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        buffer<span class="token punctuation">.</span><span class="token function">putInt</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        buffer<span class="token punctuation">.</span><span class="token function">putInt</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 切换为读模式</span>
        buffer<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 读取值</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">问题无处不在，在 DirectIntArray 的使用中，我们是手动调用 freeMemory () 来释放内存的，DirectByteBuffer 的使用过程中如何释放内存，保证内存不泄漏？</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">在 <code>ByteBuffer buffer = ByteBuffer.allocateDirect(12);</code> 这行打一个断点，一步一步跟踪进去：</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ByteBuffer <span class="token function">allocateDirect</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 创建直接内存实现的ByteBuffer</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DirectByteBuffer</span><span class="token punctuation">(</span>capacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">DirectByteBuffer</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap<span class="token punctuation">)</span> <span class="token punctuation">{</span>                   <span class="token comment">// package-private</span>
    <span class="token comment">// 调用父构造方法，设置position/limit/capacity/mark这几个值</span>
    <span class="token comment">// 与HeapByteBuffer类似，只不过没有创建hb那个数组</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> cap<span class="token punctuation">,</span> cap<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 是否页对齐，默认为否</span>
    <span class="token keyword">boolean</span> pa <span class="token operator">=</span> VM<span class="token punctuation">.</span><span class="token function">isDirectMemoryPageAligned</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 每页大小</span>
    <span class="token keyword">int</span> ps <span class="token operator">=</span> Bits<span class="token punctuation">.</span><span class="token function">pageSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">long</span> size <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>1L<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>cap <span class="token operator">+</span> <span class="token punctuation">(</span>pa <span class="token operator">?</span> ps <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 先预订内存，如果内存不够，会进行清理，并尝试几次</span>
    Bits<span class="token punctuation">.</span><span class="token function">reserveMemory</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> cap<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">long</span> base <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// key1，重点来了，调用unsafe的allocateMemory()方法来分配内存</span>
        base <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">allocateMemory</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">OutOfMemoryError</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Bits<span class="token punctuation">.</span><span class="token function">unreserveMemory</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> cap<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">throw</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// key2，初始化这片内存的值为0</span>
    unsafe<span class="token punctuation">.</span><span class="token function">setMemory</span><span class="token punctuation">(</span>base<span class="token punctuation">,</span> size<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 根据是否页对齐计算实际的地址</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pa <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>base <span class="token operator">%</span> ps <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Round up to page boundary</span>
        address <span class="token operator">=</span> base <span class="token operator">+</span> ps <span class="token operator">-</span> <span class="token punctuation">(</span>base <span class="token operator">&amp;</span> <span class="token punctuation">(</span>ps <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 默认不页对齐，所以地址就等于allocateMemory()返回的地址</span>
        address <span class="token operator">=</span> base<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// key3，Cleaner是什么？干什么的？有什么作用？</span>
    cleaner <span class="token operator">=</span> Cleaner<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Deallocator</span><span class="token punctuation">(</span>base<span class="token punctuation">,</span> size<span class="token punctuation">,</span> cap<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    att <span class="token operator">=</span> null<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><blockquote>
<p style="font-size: 20px; line-height: 38px;">看源码有个准则，一定要学会抓重点，对于看不懂的东西可以先记下并跳过，比如，DirectByteBuffer 的构造方法中其实牵涉到很多高阶知识，像页对齐、弱引用 / 虚引用（在 reserveMemory () 方法中）等相关的东西，这部分东西非常复杂且难以理解，先记下来，等把整体流程理清楚了，再回头深究这一块的东西，其实也是遵循着从宏观到微观的方法论，宏观使你了解整体流程，微观才能使你的知识体系得到升华。</p>
</blockquote>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">好了，针对 DirectByteBuffer 的构造方法，整体流程与 HeapByteBuffer 是比较类似的，只不过不是创建一个 byte 数组来保存数据，而是调用 unsafe 来分配内存并保存数据，总结下来有三个非常重要的地方：</p>
</div><div class="cl-preview-section"><ol>
<li style="font-size: 20px; line-height: 38px;"><code>base = unsafe.allocateMemory(size);</code>，调用 unsafe 的 allocateMemory () 方法来分配内存</li>
<li style="font-size: 20px; line-height: 38px;"><code>unsafe.setMemory(base, size, (byte) 0);</code>，初始化这片内存的值为 0，为什么要进行初始化？如果不初始化，之前这块内存可能被别的程序使用过，会残留一些数据，对当前的数据造成影响，这是我们写 DirectIntArray 没有考虑到的。</li>
<li style="font-size: 20px; line-height: 38px;"><code>cleaner = Cleaner.create(this, new Deallocator(base, size, cap));</code>，这行代码是干什么的？看着似乎跟清理内存有关，这个我们等会再看，先来看看如何写入数据和读取数据。</li>
</ol>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">经过上面的折腾，我们终于创建好了一个 DirectByteBuffer，接下来，我们来一起看看如何写入数据和读取数据吧。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">写入数据调用的是 <code>buffer.putInt(1);</code> 这个方法，同样地，调试跟踪进去：</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java"><span class="token comment">// 写入一个int类型的数值</span>
<span class="token keyword">public</span> ByteBuffer <span class="token function">putInt</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1 &lt;&lt; 2 = 4，一个int占4个字节</span>
    <span class="token function">putInt</span><span class="token punctuation">(</span><span class="token function">ix</span><span class="token punctuation">(</span><span class="token function">nextPutIndex</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 计算下一个position的位置并返回当前position的值</span>
<span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">nextPutIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span> nb<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment">// package-private</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>limit <span class="token operator">-</span> position <span class="token operator">&lt;</span> nb<span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BufferOverflowException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> p <span class="token operator">=</span> position<span class="token punctuation">;</span>
    position <span class="token operator">+=</span> nb<span class="token punctuation">;</span>
    <span class="token comment">// 返回移动前的值</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 计算偏移量，在address的基础上加上position的值</span>
<span class="token keyword">private</span> <span class="token keyword">long</span> <span class="token function">ix</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> address <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>i <span class="token operator">&lt;&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">private</span> ByteBuffer <span class="token function">putInt</span><span class="token punctuation">(</span><span class="token keyword">long</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// unaligned不是之前讲的那个页对齐</span>
    <span class="token comment">// 这里是跟CPU架构相关的一个参数</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>unaligned<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 在windows系统中内存值使用的是小端法，所以直接内存使用的是小端法</span>
        <span class="token comment">// 因此，这里要转换一下</span>
        <span class="token comment">// 调用unsafe的putInt()方法修改直接内存中对应地址的值</span>
        unsafe<span class="token punctuation">.</span><span class="token function">putInt</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token punctuation">(</span>nativeByteOrder <span class="token operator">?</span> y <span class="token operator">:</span> Bits<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        Bits<span class="token punctuation">.</span><span class="token function">putInt</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> x<span class="token punctuation">,</span> bigEndian<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">写入方法无非就是根据当前 position 的位置往后写入一个 int 大小的数据，写入的时候会调用 unsafe 的 putInt () 方法在内存中对应地址的位置直接写入值，而不是像 HeapByteBuffer 那样修改 byte 数组对应位置的值。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">OK，同样地，读取方法应该就是先根据当前 position 计算读取的偏移地址，再调用 unsafe 的 getInt () 方法在内存中对应地址的位置读取一个 int 大小的数据，这块的代码相对来说都比较简单，我们就不一一细看了。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">综上所述，DirectByteBuffer 底层使用的是 Unsafe 来分配一块直接内存，并在写入数据和读取数据的时候使用 Unsafe 对应的方法来操作直接内存，了解了其原理，是不是也很简单呢？</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">好了，到这里 DirectByteBuffer 的基本原理我们已经看透 80% 了，为什么是 80% 呢？</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">还记得前面我们使用 DirectIntArray 的时候最后要调用 freeMemory () 来清理内存吗？</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">是的，在 DirectByteBuffer 这里，我们并没有看到清理内存的相关代码，那肯定是有问题的，哎不对，上面好像有个 Cleaner，看着像是清理什么东西，那么，它是不是清理内存的呢？让我们再仔细研究一下。</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java">cleaner <span class="token operator">=</span> Cleaner<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Deallocator</span><span class="token punctuation">(</span>base<span class="token punctuation">,</span> size<span class="token punctuation">,</span> cap<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这里新建了一个叫作 <code>Deallocator</code> 的对象，所谓 <code>Deallocator</code>，它等于 <code>De + allocator</code>，在英语中，<code>De</code> 前缀一般表示相反的意思，比如，increse 是升高的意思，而 decrease 是下降的意思，所以，allocate 是分配的意思，deallocate 应该是解除分配的意思，也就是清理的意思，变成名词就是 deallocator，可以理解为清理器的意思。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">到底是不是我们理解的意思呢？直接上代码：</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Deallocator</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> Unsafe unsafe <span class="token operator">=</span> Unsafe<span class="token punctuation">.</span><span class="token function">getUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">long</span> address<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">long</span> size<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span>

    <span class="token comment">// 构造方法传入allocate的时候返回的地址，以及容量等参数</span>
    <span class="token keyword">private</span> <span class="token function">Deallocator</span><span class="token punctuation">(</span><span class="token keyword">long</span> address<span class="token punctuation">,</span> <span class="token keyword">long</span> size<span class="token punctuation">,</span> <span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">assert</span> <span class="token punctuation">(</span>address <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>address <span class="token operator">=</span> address<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> size<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>address <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// Paranoia</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 调用unsafe的freeMemory释放内存</span>
        unsafe<span class="token punctuation">.</span><span class="token function">freeMemory</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>
        address <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token comment">// 取消预订的内存</span>
        Bits<span class="token punctuation">.</span><span class="token function">unreserveMemory</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> capacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">Deallocator 实现了 Runnable 接口，Runnable 接口是什么？大家都比较熟悉了，它是线程执行的任务。那么，这个任务是在什么时候执行的呢？又干了什么呢？我们先来看第二个问题，从上面的代码中可以看到它调用了 unsafe 的 freeMemory () 方法来释放内存，所以，这个任务的作用就是清理内存。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">但是，这个任务又是在什么时候执行的呢？或者说，在哪里执行的呢？还是回到创建的地方，也就是下面这行代码：</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java">cleaner <span class="token operator">=</span> Cleaner<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Deallocator</span><span class="token punctuation">(</span>base<span class="token punctuation">,</span> size<span class="token punctuation">,</span> cap<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这里创建了一个 Cleaner 的对象，跟踪进去看看 Cleaner 类（前方高能，请系好安全带！）：</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java"><span class="token comment">// 虚引用</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Cleaner</span> <span class="token keyword">extends</span> <span class="token class-name">PhantomReference</span><span class="token operator">&lt;</span>Object<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> ReferenceQueue<span class="token operator">&lt;</span>Object<span class="token operator">&gt;</span> dummyQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> Cleaner first <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token keyword">private</span> Cleaner next <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token keyword">private</span> Cleaner prev <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> Runnable thunk<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> Cleaner <span class="token function">add</span><span class="token punctuation">(</span>Cleaner var0<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 省略部分代码，将var0添加到Cleaner链表中</span>
        <span class="token keyword">return</span> var0<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span>Cleaner var0<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 省略部分代码，将var0从链表中移除</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token function">Cleaner</span><span class="token punctuation">(</span>Object var1<span class="token punctuation">,</span> Runnable var2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 调用父类的构造方法</span>
        <span class="token comment">// ★Cleaner这个虚引用引用的对象是var1，也就是Deallocaotr对象</span>
        <span class="token comment">// 先记住上面这句话！！！</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> dummyQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// var2即上面创建的Deallocator对象</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>thunk <span class="token operator">=</span> var2<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> Cleaner <span class="token function">create</span><span class="token punctuation">(</span>Object var0<span class="token punctuation">,</span> Runnable var1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 创建一个Cleaner对象，并返回这个对象</span>
        <span class="token comment">// 它里面封装了一个任务</span>
        <span class="token keyword">return</span> var1 <span class="token operator">==</span> null <span class="token operator">?</span> null <span class="token operator">:</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Cleaner</span><span class="token punctuation">(</span>var0<span class="token punctuation">,</span> var1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">clean</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 从链表中移除当前对象</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token comment">// 执行任务</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>thunk<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">final</span> Throwable var2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                AccessController<span class="token punctuation">.</span><span class="token function">doPrivileged</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PrivilegedAction</span><span class="token operator">&lt;</span>Void<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">public</span> Void <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>System<span class="token punctuation">.</span>err <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Cleaner terminated abnormally"</span><span class="token punctuation">,</span> var2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>

                        System<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">return</span> null<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">可见，Cleaner 继承自一个叫作 PhantomReference 的类，PhantomReference 是什么呢？</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">PhantomReference 翻译过来叫作虚引用，它还有三个兄弟，一个叫作强引用，一个叫作软引用，还有一个叫作弱引用。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><strong>强引用</strong>，使用最普遍的引用。如果一个对象具有强引用，它绝对不会被 gc 回收。如果内存空间不足了，gc 宁愿抛出 OutOfMemoryError，也不是会回收具有强引用的对象。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><strong>软引用</strong>（SoftReference），如果一个对象只具有软引用，则内存空间足够时不会回收它，但内存空间不够时就会回收这部分对象。只要这个具有软引用对象没有被回收，程序就可以正常使用。因此，可以使用软引用来做缓存使用，有效减少 OOM 的出现。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><strong>弱引用</strong>（WeakReference），如果一个对象只具有弱引用，则不管内存空间够不够，当 gc 扫描到它时就会回收它。因此，弱引用也可用来作为缓存使用。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><strong>虚引用</strong>（PhantomReference），如果一个对象只具有虚引用，那么它就和没有任何引用一样，任何时候都可能被 gc 回收。虚引用主要用来跟踪对象被垃圾回收的活动。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">让我们总结一下这四个兄弟的区别：</p>
</div><div class="cl-preview-section"><div class="table-wrapper"><table>
<thead>
<tr>
<th>类型</th>
<th>被回收时间</th>
<th>用途</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>强引用</td>
<td>不会被回收</td>
<td>对象正常状态</td>
<td> Object object = new Object();</td>
</tr>
<tr>
<td> 软引用</td>
<td>内存不足时</td>
<td>缓存</td>
<td>很少使用</td>
</tr>
<tr>
<td>弱引用</td>
<td>执行垃圾回收时</td>
<td>缓存</td>
<td> WeakHashMap、TheadLocal</td>
</tr>
<tr>
<td> 虚引用</td>
<td>任何时候</td>
<td>跟踪对象被垃圾回收的活动</td>
<td> Cleaner</td>
</tr>
</tbody>
</table>
</div></div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">软（弱、虚）引用通常和一个引用队列（ReferenceQueue）一起使用，当 gc 回收这个软（弱、虚）引用引用的对象时，会把这个软（弱、虚）引用本身放到这个引用队列中。（先记住这句话）</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">好了，关于强软弱虚引用的概念就介绍到这里，通过上面 Cleaner 的源码，我们发现，Deallocator 的 run () 方法实际上是在 Cleaner 的 clean () 方法中调用的，那么，这个 clean () 方法又是在哪里调用的呢？其实，它是在 Reference 中调用的，Reference 中有一个线程会一直扫描这些软弱虚引用，可以先看我下面删减后的代码，再看其完整代码：</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Reference</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 引用的对象</span>
    <span class="token keyword">private</span> T referent<span class="token punctuation">;</span>         <span class="token comment">/* Treated specially by GC */</span>
    <span class="token comment">// 引用队列</span>
    <span class="token keyword">volatile</span> ReferenceQueue<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token operator">&gt;</span> queue<span class="token punctuation">;</span>
    
    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"rawtypes"</span><span class="token punctuation">)</span>
    <span class="token keyword">volatile</span> Reference next<span class="token punctuation">;</span>

    <span class="token comment">// JVM内部使用，当引用的对象被gc清理时，放到这里</span>
    <span class="token keyword">transient</span> <span class="token keyword">private</span> Reference<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> discovered<span class="token punctuation">;</span>  <span class="token comment">/* used by VM */</span>

    <span class="token keyword">static</span> <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Lock</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> Lock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 通过discover来为其赋值</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> Reference<span class="token operator">&lt;</span>Object<span class="token operator">&gt;</span> pending <span class="token operator">=</span> null<span class="token punctuation">;</span>

    <span class="token comment">// 处理线程</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ReferenceHandler</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
        <span class="token comment">// 省略部分代码</span>

        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 死循环</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">tryHandlePending</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">tryHandlePending</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> waitForNotify<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Reference<span class="token operator">&lt;</span>Object<span class="token operator">&gt;</span> r<span class="token punctuation">;</span>
        Cleaner c<span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>pending <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    r <span class="token operator">=</span> pending<span class="token punctuation">;</span>
                    <span class="token comment">// 判断是否为Cleaner对象</span>
                    c <span class="token operator">=</span> r <span class="token keyword">instanceof</span> <span class="token class-name">Cleaner</span> <span class="token operator">?</span> <span class="token punctuation">(</span>Cleaner<span class="token punctuation">)</span> r <span class="token operator">:</span> null<span class="token punctuation">;</span>
                    <span class="token comment">// pending从discovered赋值而来</span>
                    pending <span class="token operator">=</span> r<span class="token punctuation">.</span>discovered<span class="token punctuation">;</span>
                    r<span class="token punctuation">.</span>discovered <span class="token operator">=</span> null<span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>waitForNotify<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        lock<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token keyword">return</span> waitForNotify<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">OutOfMemoryError</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Thread<span class="token punctuation">.</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 如果是Cleaner对象，则执行其clean()方法</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            c<span class="token punctuation">.</span><span class="token function">clean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        ReferenceQueue<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> Object<span class="token operator">&gt;</span> q <span class="token operator">=</span> r<span class="token punctuation">.</span>queue<span class="token punctuation">;</span>
        <span class="token comment">// 入队</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> ReferenceQueue<span class="token punctuation">.</span>NULL<span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 在静态块中创建上述线程</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        ThreadGroup tg <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getThreadGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>ThreadGroup tgn <span class="token operator">=</span> tg<span class="token punctuation">;</span>
             tgn <span class="token operator">!=</span> null<span class="token punctuation">;</span>
             tg <span class="token operator">=</span> tgn<span class="token punctuation">,</span> tgn <span class="token operator">=</span> tg<span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 创建这个线程</span>
        Thread handler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceHandler</span><span class="token punctuation">(</span>tg<span class="token punctuation">,</span> <span class="token string">"Reference Handler"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        handler<span class="token punctuation">.</span><span class="token function">setPriority</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span>MAX_PRIORITY<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 守护线程</span>
        handler<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 启动线程</span>
        handler<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        SharedSecrets<span class="token punctuation">.</span><span class="token function">setJavaLangRefAccess</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">JavaLangRefAccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryHandlePendingReference</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token function">tryHandlePending</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 省略其他代码</span>

<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">通过上面的分析，我们总结一下虚引用及其引用的对象被清理的过程：</p>
</div><div class="cl-preview-section"><ol>
<li style="font-size: 20px; line-height: 38px;">引用的对象被 gc 清理；</li>
<li style="font-size: 20px; line-height: 38px;">虚引用进入 discovered 队列；</li>
<li style="font-size: 20px; line-height: 38px;">discovered 队列中的虚引用被赋值给 pending 队列；</li>
<li style="font-size: 20px; line-height: 38px;">如果虚引用是 Cleaner，则执行其 clean () 方法；</li>
<li style="font-size: 20px; line-height: 38px;">如果引用队列不为空，则进入引用队列 ReferenceQueue；</li>
</ol>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">比如，我们拿 DirectByteBuffer 为例，来描述一下整个过程：</p>
</div><div class="cl-preview-section"><ol>
<li style="font-size: 20px; line-height: 38px;">首先，DirectByteBuffer 本身是一个堆内存中的对象，它里面有一个属性叫作 address，address 保存的是直接内存的地址，操作 DirectByteBuffer 的时候实际上是对 address 指向地址的操作，当然，这种操作是通过 unsafe 来执行的；</li>
<li style="font-size: 20px; line-height: 38px;">其次，Cleaner 是一个虚引用，它引用的对象是 DirectByteBuffer，并注册了 Deallocator 这个任务，是通过 <code>Cleaner.create(this, new Deallocator(base, size, cap))</code> 这行代码实现的；</li>
<li style="font-size: 20px; line-height: 38px;">再次，当 DirectByteBuffer 不具有强引用时，随时都可能被 gc 从堆内存清理掉，此时，JVM 会把上面绑定的 Cleaner 对象放到 Reference 的 discovered 队列上；</li>
<li style="font-size: 20px; line-height: 38px;">然后，Reference 中的线程 ReferenceHandler 不断轮循，把 discovered 队列中的虚引用赋值到 pending 队列中，并且，这个虚引用如果是 Cleaner 对象，会执行它的 clean () 方法，且会把这个虚引用加入到 ReferenceQueue 队列中；</li>
<li style="font-size: 20px; line-height: 38px;">最后，执行 clean () 方法的时候将会执行到 Deallocator 的 run () 方法，在这里调用 unsafe 的 freeMemory () 清理掉直接内存；</li>
</ol>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">整个过程就是这样，比较绕，且牵涉到很多虚（软弱）引用相关的知识点，望多多体会。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">其实，总结来说，在 DirectByteBuffer 的使用过程中，直接内存的回收还是 gc 控制的，只不过是一种间接控制。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">好了，到这里 DirectByteBuffer 的整个源码就剖析完成了，你有没有 Get 到呢？</p>
</div><div class="cl-preview-section"><h1 id="后记">后记</h1>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">本节，我们从宏观和微观两个角度剖析了 ByteBuffer 在 Java 中的实现方式，并从源码层面对 HeapByteBuffer 和 DirectByteBuffer 做了非常深入的挖掘，特别是 DirectByteBuffer，它牵涉到很多 Java 中的高阶知识，相信通过本节的学习，你一定能够见识到很多未曾见过的知识，并且会发现很多自己感兴趣的点，比如大端法小端法、Unsafe、强软弱虚引用等，如果你对哪个点特别感兴趣，请死磕到底。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">既然 Java 原生的 DirectByteBuffer 都已经这么牛 X 了，Netty 还能对它做出哪些更牛 X 的改造呢？下一节，我们不见不散。</p>
</div><div class="cl-preview-section"><h1 id="思维导图">思维导图</h1>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><img class="" src="https://img1.sycdn.imooc.com/5f1f835500016b8119762146.png" data-original="//img1.sycdn.imooc.com/5f1f835500016b8119762146.png" alt="图片描述"></p>
</div>}
                        </div>
                    </div>
                                            <!-- 买过的阅读 -->
                        <div class="art-next-prev clearfix">
                                                                                                <!-- 已买且开放 或者可以试读 -->
                                    <a href="/read/82/article/2175">
                                                                    <div class="prev l clearfix">
                                        <div class="icon l">
                                            <i class="imv2-arrow3_l"></i>
                                        </div>
                                        <p>
                                            16 Netty服务如何优雅关闭
                                        </p>
                                    </div>
                                </a>
                                                                                                                            <!-- 已买且开放 或者可以试读 -->
                                    <a href="/read/82/article/2177">
                                                                    <div class="next r clearfix">
                                        <p>
                                            18 Netty的ByteBuf是如何支持堆内存非池化实现的
                                        </p>
                                        <div class="icon r">
                                            <i class="imv2-arrow3_r"></i>
                                        </div>

                                    </div>
                                </a>
                                                    </div>
                                    </div>
                <div class="comments-con js-comments-con" id="coments_con">
                </div>

                
            </div>
            
            
            

        </div>
    </div>
</div>

<div class="modal modal-jiaQun-new hide" id="modal-jiaQun">
    <div class="inner" style="">
        <div class="modal-close js-close-jiaQun">
            <i class="imv2-close"></i>
        </div>
        <div class="content">
            <img src="https://img4.sycdn.imooc.com/5f1a7f610001c9a105340522.jpg">
            <div class="right-info">
                <div class="title">
                    扫码加入慕课Java核心用户群
                </div>
                <div class="desc">
                                            <p class="mb6">验证信息：<span id="joincode">2009241134354460</span><span class="copy js-copy-joincode">复制</span></p>
                                        <p class="mb6">QQ讨论群号：314316732</p>
                                            <p>QQ群URL：<a href="https://jq.qq.com/?_wv=1027&amp;k=OouwHZGZ" target="_blank">点击访问</a></p>
                                    </div>
            </div>
            <p class="tip">若遇到搜索不到QQ群或加群失败，请联系客服邮箱:kf@imooc.com</p>
        </div>
    </div>
</div>
 
<!-- 专栏介绍页专栏评价 -->

<!-- 专栏介绍页底部三条评价 -->

<!-- 专栏阅读页弹层目录和介绍页页面目录 -->

<!-- 专栏阅读页发布回复 -->

<!-- 专栏阅读页发布评论 -->

<!-- 专栏阅读页底部评论 -->

<!-- 专栏阅读 单个 评论 -->

<!-- 新增回复和展开三条以外回复 -->

<!-- 立即订阅的弹窗 -->












</div></body></html>