<html><head><meta charset="utf-8"><title>08 Netty的核心组件有哪些-慕课专栏</title>
			<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
			<meta name="renderer" content="webkit">
			<meta property="qc:admins" content="77103107776157736375">
			<meta property="wb:webmaster" content="c4f857219bfae3cb">
			<meta http-equiv="Access-Control-Allow-Origin" content="*">
			<meta http-equiv="Cache-Control" content="no-transform ">
			<meta http-equiv="Cache-Control" content="no-siteapp">
			<link rel="apple-touch-icon" sizes="76x76" href="https://www.imooc.com/static/img/common/touch-icon-ipad.png">
			<link rel="apple-touch-icon" sizes="120x120" href="https://www.imooc.com/static/img/common/touch-icon-iphone-retina.png">
			<link rel="apple-touch-icon" sizes="152x152" href="https://www.imooc.com/static/img/common/touch-icon-ipad-retina.png">
			<link href="https://moco.imooc.com/captcha/style/captcha.min.css" rel="stylesheet">
			<link rel="stylesheet" href="https://www.imooc.com/static/moco/v1.0/dist/css/moco.min.css?t=201907021539" type="text/css">
			<link rel="stylesheet" href="https://www.imooc.com/static/lib/swiper/swiper-3.4.2.min.css?t=201907021539">
			<link rel="stylesheet" href="https://static.mukewang.com/static/css/??base.css,common/common-less.css?t=2.5,column/zhuanlanChapter-less.css?t=2.5,course/inc/course_tipoff-less.css?t=2.5?v=201907051055" type="text/css">
			<link charset="utf-8" rel="stylesheet" href="https://www.imooc.com/static/lib/ueditor/themes/imooc/css/ueditor.css?v=201907021539"><link rel="stylesheet" href="https://www.imooc.com/static/lib/baiduShare/api/css/share_style0_16.css?v=6aba13f0.css"></head>
			<body><div id="main">


<div class="main-con hide-menu">
    <!-- 左侧菜单 & 索引 -->
    
    <div class="right-content" style="padding-left: 0px;">
        <div class="container clearfix" id="top" style="width: 1134px; display: block;">
            
            
            <div class="center_con js-center_con l" style="width: 1134px;">
                <div class="article-con">
                                            <!-- 买过的阅读 -->
                        

                    
                    <div class="art-title" style="margin-top: 0px;">
                        08 Netty的核心组件有哪些
                    </div>
                    <div class="art-info clearfix">
                        
                        <span class="l">
                            更新时间：2020-07-17 09:45:32
                        </span>
                    </div>
                    <div class="art-top">
                                                <img src="https://img1.sycdn.imooc.com/5f05952f000195a006400359.jpg" alt="">
                                                                        <div class="famous-word-box">
                            <img src="https://www.imooc.com/static/img/column/bg-l.png" alt="" class="bg1 bg">
                            <img src="https://www.imooc.com/static/img/column/bg-r.png" alt="" class="bg2 bg">
                            <div class="famous-word">书是人类进步的阶梯。——高尔基<p></p></div>
                        </div>
                                            </div>
                    <div class="art-content js-lookimg">
                        <div id="article_content">
                            <div class="cl-preview-section"><h1 id="前言">前言</h1>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">你好，我是彤哥。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">上一节我们一起学习了 Netty 编码的十步曲，通过上一节的学习，相信大家一定可以写出十分优雅的 Netty 代码了。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">不过，Netty 之所以这么好用，离不开它的核心组件，我归纳了一下，大概有十种，我们暂且称之为 “十大核心组件”，其中，一部分是上一节中我们见过的，还有一部分是幕后的英雄，有了这些幕后英雄的默默支持，才有了这么健壮优雅的 Netty。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">所以，本节，我们将一起学习 Netty 的十大核心组件，从宏观上理解 Netty 的架构设计。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">好了，让我们进入今天的学习吧。</p>
</div><div class="cl-preview-section"><h1 id="十大核心组件">十大核心组件</h1>
</div><div class="cl-preview-section"><h2 id="bootstrap与serverbootstrap" style="font-size: 30px;">1. Bootstrap 与 ServerBootstrap</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">Bootstrap 与 ServerBootstrap 是 Netty 程序的引导类，主要用于配置各种参数，并启动整个 Netty 服务。它们俩都继承自 AbstractBootstrap 抽象类，不同的是，Bootstrap 用于客户端引导，而 ServerBootstrap 用于服务端引导。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><img class="" src="https://img1.sycdn.imooc.com/5f0d64b30001a08c03850287.png" data-original="//img1.sycdn.imooc.com/5f0d64b30001a08c03850287.png" alt="图片描述"><br>
相对于 Bootstrap，ServerBootstrap 多了一个维度，用于处理 Accept 事件，所以它的很多方法都会多一份 <code>childXxx()</code>，比如，<code>childHandler()</code>、<code>childOption()</code> 等，但是，没有 <code>childChannel()</code> 这个方法哦 ^^，因为子 Channel 是通过 ServerSocketChannel 创建出来的，跟踪源码会发现 ServerSocketChannel 读取到消息的时候会把这个消息转换成连接，即 SocketChannel，具体的源码分析我们后面再详细介绍。</p>
</div><div class="cl-preview-section"><h2 id="eventloopgroup" style="font-size: 30px;">2. EventLoopGroup</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">EventLoopGroup 可以理解为一个线程池，对于服务端程序，我们一般会绑定两个线程池，一个用于处理 Accept 事件，一个用于处理读写事件。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">我们以 NioEventLoopGroup 这个实现类为例看看它的继承体系：</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><img class="" src="https://img1.sycdn.imooc.com/5f0d64a50001247d05420787.png" data-original="//img1.sycdn.imooc.com/5f0d64a50001247d05420787.png" alt="图片描述"></p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">细心的同学会发现，上面四个接口好熟悉：</p>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">Iterable，迭代器的接口，说穿 EventLoopGroup 是一个容器，可以通过迭代的方式查看里面的元素。</li>
<li style="font-size: 20px; line-height: 38px;">Executor，线程池的顶级接口，包含一个 execute () 方法，用于提交任务到线程池中。</li>
<li style="font-size: 20px; line-height: 38px;">ExecutorService，扩展自 Executor 接口，提供了通过 submit () 方法提交任务的方式，并增加了 shutdown () 等其它方法。</li>
<li style="font-size: 20px; line-height: 38px;">ScheduledExecutorService，扩展自 ExecutorService，增加了定时任务执行相关的方法。</li>
</ul>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">其中，后面三个都是线程池中的接口，位于著名的 <code>java.util.concurrent</code> 包下面。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">下面的几个接口或者类自然就属于 Netty 了：</p>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">
<p style="font-size: 20px; line-height: 38px;">EventExecutorGroup，扩展自 ScheduledExecutorService，并增加了两大功能，一是提供了 next () 方法用于获取一个 EventExecutor，二是管理这些 EventExecutor 的生命周期。</p>
</li>
<li style="font-size: 20px; line-height: 38px;">
<p style="font-size: 20px; line-height: 38px;">EventLoopGroup，扩展自 EventExecutorGroup，并增加或修改了两大功能，一是提供了 next () 方法用于获取一个 EventLoop，二是提供了注册 Channel 到事件轮询器中。</p>
</li>
<li style="font-size: 20px; line-height: 38px;">
<p style="font-size: 20px; line-height: 38px;">MultithreadEventLoopGroup，抽象类，EventLoopGroup 的所有实现类都继承自这个类，可以看作是一种模板，从名字也可以看出来它里面包含多个线程来处理任务。</p>
</li>
<li style="font-size: 20px; line-height: 38px;">
<p style="font-size: 20px; line-height: 38px;">NioEventLoopGroup，具体实现类，使用 NIO 形式（多路复用中的 select）工作的 EventLoopGroup。更换前缀就可以得到不同的实现类，比如 EpollEventLoopGroup 专门用于 Linux 平台，KQueueEventLoopGroup 专门用于 MacOS/BSD 平台。</p>
<blockquote>
<p style="font-size: 20px; line-height: 38px;">select/epoll/kqueue，它们是实现 IO 多路复用的不同形式，select 支持的平台比较广泛，epoll 和 kqueue 比 select 更高效，epoll 只支持 linux，kqueue 只支持 BSD 平台，其中 MacOS 衍生自 BSD，所以 kqueue 也支持 MacOS。Netty 专门为两个平台做了的不同实现，也是对性能的极致追求，而且，我们服务端通常都是运行在 Linux 系统上，所以在上线的时候完全可以使用 EpollEventLoopGroup 来代替 NioEventLoopGroup。</p>
</blockquote>
</li>
</ul>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">有的同学可能会说，为什么 Netty 要把继承体系搞这么复杂，这么深呢？其实，通过上面的分析也可以得出一些蛛丝马迹，每一个接口都是在上一层接口的基础上扩展一些新的功能，属于每一个接口自己的功能都特别纯粹，并不是很多，这也是单一职责原则的具体使用，使用多个单一的接口比使用一个总接口要好。</p>
</div><div class="cl-preview-section"><h2 id="eventloop" style="font-size: 30px;">3. EventLoop</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">EventLoop 可以理解为是 EventLoopGroup 中的工作线程，类似于 ThreadPoolExecutor 中的 Worker，但是，实际上，它并不是一个线程，它里面包含了一个线程，控制着这个线程的生命周期。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">让我们以 NioEventLoop 为例看看它的继承体系：</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><img class="" src="https://img1.sycdn.imooc.com/5f0d646c0001adfe08050987.png" data-original="//img1.sycdn.imooc.com/5f0d646c0001adfe08050987.png" alt="图片描述"><br>
可以看到这个继承体系比 EventLoopGroup 还复杂，不用过于纠结，这里，我们介绍几个关键的接口或类：</p>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">
<p style="font-size: 20px; line-height: 38px;">EventExecutor，扩展自 EventLoopGroup，主要增加了判断一个线程是不是在 EventLoop 中的方法。</p>
</li>
<li style="font-size: 20px; line-height: 38px;">
<p style="font-size: 20px; line-height: 38px;">OrderedEventExecutor，扩展自 EventExecutor，这是一个标记接口，标志着里面的任务都是按顺序执行的。</p>
</li>
<li style="font-size: 20px; line-height: 38px;">
<p style="font-size: 20px; line-height: 38px;">EventLoop，扩展自 EventLoopGroup，它将为已注册进来的 Channel 处理所有的 IO 事件，另外，它还扩展自 OrderedEventExecutor 接口，说明里面的任务是按顺序执行的。</p>
</li>
<li style="font-size: 20px; line-height: 38px;">
<p style="font-size: 20px; line-height: 38px;">SingleThreadEventLoop，抽象类，EventLoop 的所有实现类都继承自这个类，可以看作是一种模板，从名字也可以看出来它是使用单线程处理的。</p>
</li>
<li style="font-size: 20px; line-height: 38px;">
<p style="font-size: 20px; line-height: 38px;">NioEventLoop，具体实现类，绑定到一个 Selector 上，同时可以注册多个 Channel 到 Selector 上，同时，它继承自 SingleThreadEventLoop，也就说明了一个 Selector 对应一个线程。同样地，更换前缀就可以得到不同的实现，比如 EpollEventLoop、KQueueEventLoop。</p>
</li>
</ul>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><img class="" src="https://img1.sycdn.imooc.com/5f0d64590001e71110300611.png" data-original="//img1.sycdn.imooc.com/5f0d64590001e71110300611.png" alt="图片描述"></p>
</div><div class="cl-preview-section"><h2 id="bytebuf" style="font-size: 30px;">4. ByteBuf</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">ByteBuf，咋一看名字跟 ByteBuffer 还挺像，还记得 ByteBuffer 吗？没错，既然 Java NIO 中已经定义处理字节的缓冲区，为什么 Netty 还要另辟蹊径，再搞一个 ByteBuf 出来呢？</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">让我们先来回忆一下 Buffer 的基本内容：</p>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">它包含三个主要属性：position、limit、capacity。</li>
<li style="font-size: 20px; line-height: 38px;">写模式，position 从 0 开始，表示下一个可写的位置，limit 等于 capacity。</li>
<li style="font-size: 20px; line-height: 38px;">读模式，position 重置为 0，表示下一个可读的位置，limit 等于切换之前 position 的位置，capacity 不变。</li>
<li style="font-size: 20px; line-height: 38px;">通过 flip () 方法切换为读模式</li>
<li style="font-size: 20px; line-height: 38px;">通过 clean () 方法或 compact () 方法清除（部分）数据</li>
<li style="font-size: 20px; line-height: 38px;">通过 rewind () 方法重新读取或重新写入数据</li>
<li style="font-size: 20px; line-height: 38px;">通过 buf.put () 或者 channel.read (buf) 方法写入数据</li>
<li style="font-size: 20px; line-height: 38px;">通过 buf.read () 或者 channel.write (buf) 方法读取数据</li>
</ul>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">上面的内容你还记得哪些呢？是不是很复杂？Java NIO 自带的 Buffer 操作起来特别繁琐，一会儿切换成写模式，一会儿切换在读模式，position 的位置在哪，是个正常人都会被绕进去。Netty 的作者也是一样，他也被绕进去了，索性，他就创建了一个新的 ByteBuf 来处理缓冲区数据。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">那么 Netty 是怎么实现的呢？让我们一起来看看吧。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">ByteBuf 声明了两个指针：一个读指针 <code>readIndex</code> 用于读取数据，一个写指针 <code>writeIndex</code> 用于写数据。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><img class="" src="https://img1.sycdn.imooc.com/5f0d644700016c2e10270217.png" data-original="//img1.sycdn.imooc.com/5f0d644700016c2e10270217.png" alt="图片描述"><br>
使用读写指针分离带来的好处是明显的，彻底解决了读写模式切换来切换去、position 指针变来变去的问题。那么，新的 <strong>ByteBuf 都有哪些特性呢？</strong></p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">首先，让我们看看 ByteBuf 的分类，常见的分类方式有三种：</p>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">
<p style="font-size: 20px; line-height: 38px;">Pooled 和 Unpooled，池化和非池化</p>
<p style="font-size: 20px; line-height: 38px;">池化，即初始化时分配好一块内存作为内存池，每次创建 ByteBuf 时从这个内存池中分配一块连续的内存给这个 ByteBuf 使用，待这个 ByteBuf 使用完了之后再放回内存池中，供后续的 ByteBuf 使用。利用池化技术，可以减少虚拟机频繁的内存回收带来的性能开销及资源消耗。池化技术在很多场景中都有使用到，比如，数据库连接池、线程池等，它们都有一些共同的特点，就是创建对象比较耗费资源。</p>
<p style="font-size: 20px; line-height: 38px;">池化技术在生活中也随处可见，比如饭店的大厅、快递公司的网点。我们以饭店的大厅为例，它就像一块内存，来一个客人就给他分配一个桌子，如果没有大厅怎么办呢？来一个客人，饭店老板先去买个空间，也可能买块地建个空间，然后分配给这个客人，这个客人用完了再把这个空间卖掉，等下一个客人来的时候再重复以上步骤，想像一下都很美 ^^，所以，老板直接买下一个大厅，来一个客人给他分配一个桌子，用完回收，完全自己管理这片空间，省时又省力。</p>
<p style="font-size: 20px; line-height: 38px;">非池化，即完全利用 JVM 本身的内存管理能力来管理对象的生命周期，即我们平时开发使用的模式，对象的内存分配完全交给 JVM 来管理，我们不用管对象内存的管理和回收。</p>
</li>
<li style="font-size: 20px; line-height: 38px;">
<p style="font-size: 20px; line-height: 38px;">Heap 和 Direct，堆内存和直接内存</p>
<p style="font-size: 20px; line-height: 38px;">堆内存，比较好理解，即 JVM 本身的堆内存。</p>
<p style="font-size: 20px; line-height: 38px;">直接内存，独立于 JVM 内存之外的内存空间，直接向操作系统申请一块内存。</p>
</li>
<li style="font-size: 20px; line-height: 38px;">
<p style="font-size: 20px; line-height: 38px;">Safe 和 Unsafe，安全和非安全</p>
<p style="font-size: 20px; line-height: 38px;">Unsafe，底层使用 Java 本身的 Unsafe 来操作底层的数据结构，即直接利用对象在内存中的指针来操作对象，所以，比较危险。</p>
</li>
</ul>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">基于以上三个维度，而且是完全不相干的三个维度，就形成了 <code>2 * 2 * 2 = 8</code> 种完全不一样的 ByteBuf，即 PooledHeapByteBuf、PooledUnsafeHeapByteBuf、PooledDirectByteBuf、PooledUnsafeDirectByteBuf、UnpooledHeapByteBuf、UnpooledUnsafeHeapByteBuf、UnpooledDirectByteBuf、UnpooledUnsafeDirectByteBuf。<br>
<img class="" src="https://img1.sycdn.imooc.com/5f0d641a0001bf4113780487.png" data-original="//img1.sycdn.imooc.com/5f0d641a0001bf4113780487.png" alt="图片描述"><br>
好了，上面介绍了 ByteBuf 的分类，你一定会说，这么多 ByteBuf，到底用哪个呢？怎么使用呢？</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">其实，Netty 都已经为我们想好了，关于上面八种 ByteBuf，我们并不需要显式地去调用它们的构造方法，而是使用一种叫作 <code>ByteBufAllocator</code> 分配器的东西来为我们创建 ByteBuf 对象，而这种分配器又有四种不同的类型：</p>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">PooledByteBufAllocator，使用池化技术，内部会根据平台特性自行决定使用哪种 ByteBuf</li>
<li style="font-size: 20px; line-height: 38px;">UnpooledByteBufAllocator，不使用池化技术，内部会根据平台特性自行决定使用哪种 ByteBuf</li>
<li style="font-size: 20px; line-height: 38px;">PreferHeapByteBufAllocator，更偏向于使用堆内存，即除了显式地指明了使用直接内存的方法都使用堆内存</li>
<li style="font-size: 20px; line-height: 38px;"> PreferDirectByteBufAllocator，更偏向于使用直接内存，即除了显式地指明了使用堆内存的方法都使用直接内存<br>
<img class="" src="https://img1.sycdn.imooc.com/5f0d64060001930110400287.png" data-original="//img1.sycdn.imooc.com/5f0d64060001930110400287.png" alt="图片描述"><br>
看到这里，你可能已经想骂粗口了，别急，淡定，八种 ByteBuf，四种 Allocator，对于拥有选择恐惧症的我该怎么办？</li>
</ul>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">Netty 真的为你想好了，只需要简单地调用如下几行代码，Netty 就可以帮你创建最适合当前平台的 ByteBuf：</p>
</div><div class="cl-preview-section"><pre class=" language-java"><code class="prism  language-java">ByteBufAllocator allocator <span class="token operator">=</span> ByteBufAllocator<span class="token punctuation">.</span>DEFAULT<span class="token punctuation">;</span>
ByteBuf buffer <span class="token operator">=</span> allocator<span class="token punctuation">.</span><span class="token function">buffer</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
buffer<span class="token punctuation">.</span><span class="token function">writeXxx</span><span class="token punctuation">(</span>xxx<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">是不是很贴心呢？</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">默认地，Netty 将<code>最大努力</code>地使用池化、Unsafe、直接内存的方式为你创建 ByteBuf，为什么说是<code>最大努力</code>呢？因为在有些平台下某种特性支持地不是很好，所以 Netty 默认不会开启，比如 Android 平台下不会使用 Unsafe。</p>
</div><div class="cl-preview-section"><pre class=" language-java"><code class="prism  language-java"><span class="token comment">// io.netty.util.internal.PlatformDependent#unsafeUnavailabilityCause0</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isAndroid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"sun.misc.Unsafe: unavailable (Android)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token string">"sun.misc.Unsafe: unavailable (Android)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><h2 id="channel" style="font-size: 30px;">5. Channel</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">上面我们介绍了 ByteBuf，它是 Netty 在 Java NIO 的 Buffer 之上创造的一个新的缓冲区，比 Java 自带的语义清晰很多，也好用很多。那么，Channel 是不是也是凌驾于 Java NIO 的 Channel 之上的一个新事物呢？</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">答案是肯定的，Netty 的 Channel 是对 Java 原生 Channel 的进一步封装，不仅封装了原生 Channel 操作的复杂性，还提供了一些很酷且实用的功能，比如：</p>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">可以获取当前连接的状态及配置参数</li>
<li style="font-size: 20px; line-height: 38px;">通过 ChannelPipeline 来处理 IO 事件</li>
<li style="font-size: 20px; line-height: 38px;">在 Netty 中的所有 IO 操作都是异步的</li>
<li style="font-size: 20px; line-height: 38px;">可继承的 Channel 体系</li>
</ul>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">与原生 Channel 对应，Netty 的 Channel 都有相应的包装类，并且还扩展了其它协议的实现：</p>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">DatagramChannel：UDP 协议的支持</li>
<li style="font-size: 20px; line-height: 38px;"> SocketChannel：TCP 协议的支持</li>
<li style="font-size: 20px; line-height: 38px;"> ServerSocketChannel：TCP 协议的支持</li>
<li style="font-size: 20px; line-height: 38px;"> SctpChannel：SCTP 协议的支持</li>
<li style="font-size: 20px; line-height: 38px;"> SctpServerChannel：SCTP 协议的支持 </li>
<li style="font-size: 20px; line-height: 38px;"><s>RxtxChannel</s>：RXTX 协议的支持，已废弃 </li>
<li style="font-size: 20px; line-height: 38px;"><s>UdtChannel</s>：UDT 协议的支持，已废弃</li>
</ul>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">可以看到，对各种协议的支持在 Netty 中很容易实现，且它很擅长。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">Netty 不仅支持这些协议的 NIO 通用平台实现，还支持特定平台的实现，而且只需要简单地更换前缀就可以达到对不同平台的支持，比如，ServerSocketChannel 的通用实现为 NioServerSocketChannel，在 Linux 下完全可以更换成 EpollServerSocketChannel，代码只需要做很小的修改，就可以达到平台级的性能提升。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><img class="" src="https://img1.sycdn.imooc.com/5f0d619500013e6b11270187.png" data-original="//img1.sycdn.imooc.com/5f0d619500013e6b11270187.png" alt="图片描述"></p>
</div><div class="cl-preview-section"><h2 id="channelhandler" style="font-size: 30px;">6. ChannelHandler</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">ChannelHandler 是核心业务处理接口，用于处理或拦截 IO 事件，并将其转发到 ChannelPipeline 中的下一个 ChannelHandler，运用的是责任链设计模式。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">ChannelHandler 分为入站和出站两种：ChannelInboundHandler 和 ChannelOutboundHandler，不过一般不建议直接实现这两个接口，而是它们的抽象类：</p>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">SimpleChannelInboundHandler：处理入站事件，不建议直接使用 ChannelInboundHandlerAdapter</li>
<li style="font-size: 20px; line-height: 38px;">ChannelOutboundHandlerAdapter：处理出站事件</li>
<li style="font-size: 20px; line-height: 38px;"> ChannelDuplexHandler：双向的</li>
</ul>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">其中，SimpleChannelInboundHandler 相比于 ChannelInboundHandlerAdapter 优势更明显，它可以帮我们做资源的自动释放等操作。</p>
</div><div class="cl-preview-section"><h2 id="channelhandlercontext" style="font-size: 30px;">7. ChannelHandlerContext</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">ChannelHandlerContext 保存着 Channel 的上下文，同时关联着一个 ChannelHandler，通过 ChannelHandlerContext，ChannelHandler 方能与 ChannelPipeline 或者其它 ChannelHandler 进行交互，ChannelHandlerContext 是它们之间的纽带。</p>
</div><div class="cl-preview-section"><h2 id="channelfuture" style="font-size: 30px;">8. ChannelFuture</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">我们上面说了 Netty 中所有的 IO 操作都是异步的，既然是异步的就会返回在将来用来获取返回值的对象，也就是 Future，在 Netty 中，这个 Future 我们称之为 ChannelFuture，因为是跟 Channel 的 IO 事件相关联的，当然，Netty 中还有其它各种各样的 Future。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">通过 ChannelFuture，可以查看 IO 操作是否已完成、是否成功、是否已取消等等。</p>
</div><div class="cl-preview-section"><h2 id="channelpipeline" style="font-size: 30px;">9. ChannelPipeline</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">ChannelPipeline 是 ChannelHandler 的集合，它负责处理和拦截入站和出站的事件和操作，每个 Channel 都有一个 ChannelPipeline 与之对应，会自动创建。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">更确切地说，ChannelPipeline 中存储的是 ChannelHandlerContext 链，通过这个链把 ChannelHandler 连接起来，让我们仔细研究一下几者之间的关系：</p>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">一个 Channel 对应一个 ChannelPipeline</li>
<li style="font-size: 20px; line-height: 38px;"> 一个 ChannelPipeline 包含一条双向的 ChannelHandlerContext 链</li>
<li style="font-size: 20px; line-height: 38px;">一个 ChannelHandlerContext 中包含一个 ChannelHandler</li>
<li style="font-size: 20px; line-height: 38px;"> 一个 Channel 会绑定到一个 EventLoop 上</li>
<li style="font-size: 20px; line-height: 38px;">一个 NioEventLoop 维护了一个 Selector（使用的是 Java 原生的 Selector）</li>
<li style="font-size: 20px; line-height: 38px;">一个 NioEventLoop 相当于一个线程</li>
</ul>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">通过以上分析，可以得出，ChannelPipeline、ChannelHandlerContext 都是线程安全的，因为同一个 Channel 的事件都会在一个线程中处理完毕（假设用户不自己启动线程）。但是，ChannelHandler 却不一定，ChannelHandler 类似于 Spring MVC 中的 Service 层，专门处理业务逻辑的地方，一个 ChannelHandler 实例可以供多个 Channel 使用，所以，不建议把有状态的变量放在 ChannelHandler 中，而是放在消息本身或者 ChannelHandlerContext 中。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">好了，上面的关系已经描述清楚，让我们画个图直观地感受一下：</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><img class="" src="https://img1.sycdn.imooc.com/5f0d6180000114a212880566.png" data-original="//img1.sycdn.imooc.com/5f0d6180000114a212880566.png" alt="图片描述"></p>
</div><div class="cl-preview-section"><h2 id="channeloption" style="font-size: 30px;">10. ChannelOption</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">ChannelOption 严格来说不算是一种组件，它保存了很多我们拿来即用的参数，使用这些参数能够让我们以类型安全地方式来配置 Channel，比如，我们前面使用过的 ChannelOption.SO_BACKLOG，Netty 还提供了很多这种类似的参数，使得我们能够以更精细地方式控制程序正确、正常、高性能地运行。</p>
</div><div class="cl-preview-section"><h1 id="后记">后记</h1>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">本节，我们一起学习了 Netty 的十大核心组件，理解了这些组件的含义和使用方式，相信你一定能够从宏观上对 Netty 有一个更高的认识，这些组件看似散乱，其实内含逻辑，如果非要给它们归类的话，我认为可以分成以下四类：</p>
</div><div class="cl-preview-section"><ol>
<li style="font-size: 20px; line-height: 38px;">引导相关：Bootstrap 和 ServerBootstrap</li>
<li style="font-size: 20px; line-height: 38px;"> 线程相关：EventLoopGroup、EventLoop（EventExecutorGroup、EventExecutor）</li>
<li style="font-size: 20px; line-height: 38px;">Buffer 相关：ByteBuf</li>
<li style="font-size: 20px; line-height: 38px;">Channel 相关：Channel、ChannelHandler、ChannelHandlerContext、ChannelFuture、ChannelPipeline、ChannelOption</li>
</ol>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">其实，每一块甚至每一个类拿出来讲，都能讲很多内容，本节只是从宏观上认识这些组件，待后面分析源码的时候再来深入了解它们。</p>
</div><div class="cl-preview-section"><h1 id="思维导图">思维导图</h1>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><img class="" src="https://img1.sycdn.imooc.com/5f0d616c00013bc015351093.png" data-original="//img1.sycdn.imooc.com/5f0d616c00013bc015351093.png" alt="图片描述"></p>
</div>}
                        </div>
                    </div>
                                            <!-- 买过的阅读 -->
                        <div class="art-next-prev clearfix">
                                                                                                <!-- 已买且开放 或者可以试读 -->
                                    <a href="/read/82/article/2166">
                                                                    <div class="prev l clearfix">
                                        <div class="icon l">
                                            <i class="imv2-arrow3_l"></i>
                                        </div>
                                        <p>
                                            07 如何优雅地编写Netty应用程序
                                        </p>
                                    </div>
                                </a>
                                                                                                                            <!-- 已买且开放 或者可以试读 -->
                                    <a href="/read/82/article/2168">
                                                                    <div class="next r clearfix">
                                        <p>
                                            09 什么是Reactor模式
                                        </p>
                                        <div class="icon r">
                                            <i class="imv2-arrow3_r"></i>
                                        </div>

                                    </div>
                                </a>
                                                    </div>
                                    </div>
                <div class="comments-con js-comments-con" id="coments_con">
                </div>

                
            </div>
            
            
            

        </div>
    </div>
</div>

<div class="modal modal-jiaQun-new hide" id="modal-jiaQun">
    <div class="inner" style="">
        <div class="modal-close js-close-jiaQun">
            <i class="imv2-close"></i>
        </div>
        <div class="content">
            <img src="https://img3.sycdn.imooc.com/5f1a7f610001c9a105340522.jpg">
            <div class="right-info">
                <div class="title">
                    扫码加入慕课Java核心用户群
                </div>
                <div class="desc">
                                            <p class="mb6">验证信息：<span id="joincode">2009241134354460</span><span class="copy js-copy-joincode">复制</span></p>
                                        <p class="mb6">QQ讨论群号：314316732</p>
                                            <p>QQ群URL：<a href="https://jq.qq.com/?_wv=1027&amp;k=OouwHZGZ" target="_blank">点击访问</a></p>
                                    </div>
            </div>
            <p class="tip">若遇到搜索不到QQ群或加群失败，请联系客服邮箱:kf@imooc.com</p>
        </div>
    </div>
</div>
 
<!-- 专栏介绍页专栏评价 -->

<!-- 专栏介绍页底部三条评价 -->

<!-- 专栏阅读页弹层目录和介绍页页面目录 -->

<!-- 专栏阅读页发布回复 -->

<!-- 专栏阅读页发布评论 -->

<!-- 专栏阅读页底部评论 -->

<!-- 专栏阅读 单个 评论 -->

<!-- 新增回复和展开三条以外回复 -->

<!-- 立即订阅的弹窗 -->












</div></body></html>