<html><head><meta charset="utf-8"><title>24 Spring Cloud Config 服务化、动态刷新、重试-慕课专栏</title>
			<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
			<meta name="renderer" content="webkit">
			<meta property="qc:admins" content="77103107776157736375">
			<meta property="wb:webmaster" content="c4f857219bfae3cb">
			<meta http-equiv="Access-Control-Allow-Origin" content="*">
			<meta http-equiv="Cache-Control" content="no-transform ">
			<meta http-equiv="Cache-Control" content="no-siteapp">
			<link rel="apple-touch-icon" sizes="76x76" href="https://www.imooc.com/static/img/common/touch-icon-ipad.png">
			<link rel="apple-touch-icon" sizes="120x120" href="https://www.imooc.com/static/img/common/touch-icon-iphone-retina.png">
			<link rel="apple-touch-icon" sizes="152x152" href="https://www.imooc.com/static/img/common/touch-icon-ipad-retina.png">
			<link href="https://moco.imooc.com/captcha/style/captcha.min.css" rel="stylesheet">
			<link rel="stylesheet" href="https://www.imooc.com/static/moco/v1.0/dist/css/moco.min.css?t=201907021539" type="text/css">
			<link rel="stylesheet" href="https://www.imooc.com/static/lib/swiper/swiper-3.4.2.min.css?t=201907021539">
			<link rel="stylesheet" href="../zhuanlanChapter-less.css?v=201907051055" type="text/css">
			<link charset="utf-8" rel="stylesheet" href="https://www.imooc.com/static/lib/ueditor/themes/imooc/css/ueditor.css?v=201907021539"><link rel="stylesheet" href="https://www.imooc.com/static/lib/baiduShare/api/css/share_style0_16.css?v=6aba13f0.css"></head>
			<body><div id="main">

<div class="container clearfix" id="top" style="display: block; width: 1134px;">
    
    <div class="center_con js-center_con l" style="width: 1134px;">
        <div class="article-con">
                            <!-- 买过的阅读 -->
                <div class="map">
                    <a href="/read" target="_blank"><i class="imv2-feather-o"></i></a>
                    <a href="/read/37" target="_blank">Spring Cloud微服务开发实践</a>
                    <a href="" target="_blank">
                        <span>
                            / 8-3 24 Spring Cloud Config 服务化、动态刷新、重试
                        </span>
                    </a>
                </div>

            


            <div class="art-title" style="margin-top: 0px;">
                24 Spring Cloud Config 服务化、动态刷新、重试
            </div>
            <div class="art-info">
                
                <span>
                    更新时间：2019-07-12 15:35:52
                </span>
            </div>
            <div class="art-top">
                                <img src="https://img4.mukewang.com/5d28383d00019a6806400359.jpg" alt="">
                                                <div class="famous-word-box">
                    <img src="https://www.imooc.com/static/img/column/bg-l.png" alt="" class="bg1 bg">
                    <img src="https://www.imooc.com/static/img/column/bg-r.png" alt="" class="bg2 bg">
                    <div class="famous-word">你若要喜爱你自己的价值，你就得给世界创造价值。<p class="author">——歌德</p></div>
                </div>
                            </div>
            <div class="art-content js-lookimg">
                <div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">上篇文章和大家分享了 Spring Cloud Config 中的配置文件安全问题，一方面是配置文件本身要加密，另一方面是 Spring Cloud Config 这个服务要有相应的安全机制，做好这两点，我们就不必担心数据安全问题了。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">到目前为止我们的 Spring Cloud Config 中的所有案例都还是单服务的，没有服务化。另外，当配置文件刷新后， Spring Cloud Config 中的 Client 也不能及时感知到（8-1 小节向大家演示的是当配置文件变化之后，Spring Cloud Config Server 能够及时感知到），另外也没有失败重试功能，那么本文我将带领大家，来把这几个问题搞清楚。</p>
</div><div class="cl-preview-section"><h2 id="服务化" style="font-size: 30px;">服务化</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">我们在前面的配置中，当 Config Client 需要从 Config Server 上获取配置数据时，我们都是直接在 Config Client 的配置文件中写上 Config Server 的地址，类似下面这种架构：</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><img src="http://img.mukewang.com/5d1097cd000160f403820374.png" alt="图片描述" data-original="http://img.mukewang.com/5d1097cd000160f403820374.png" class="" style="cursor: pointer;"></p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这种写法相当于将 Config Client 和 Config Server 绑定死了，以后 Config Server 的地址不能变，Config Server 也不能挂，否则 Config Client 就获取不到信息了，而且这种方式也破坏了我们微服务的整体架构，即服务之间互相调用，获取对方的信息都是去服务注册中心上获取，所以我们要对这种结构进行改造，改造成下面这种结构：</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><img src="http://img.mukewang.com/5d1097d800011e7605330374.png" alt="图片描述" data-original="http://img.mukewang.com/5d1097d800011e7605330374.png" class="" style="cursor: pointer;"></p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">即当 Config Server 启动时，将自己注册到服务注册中心 Eureka 上，所有 Config Client 都从 Eureka 上去获取 Config Server 的信息，这样我们就成功将 Config Server 和 Config Client 解耦了，Eureka 在这里依然扮演了数据中心的角色。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">好了，那么接下来我们就来看看如何实现服务化。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">本文的案例在 8-2 小节的案例上继续完成，大家可以直接在 8-2 小节的案例上继续完善。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">首先我们在 CloudConfig 项目中添加一个名为 eureka 的 module ，这便是我们的注册中心了。注册中心的添加与配置，读者可以参考前面的文章，这里我就不再赘述，注册中心创建成功后，启动注册中心 eureka。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">eureka 启动之后，我们要对之前的 Config Server 和 Config Client 进行服务化改造，首先给这两个模块分别加上 eureka client 依赖，如下：</p>
</div><div class="cl-preview-section"><pre class="  language-xml"><code class="prism  language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-netflix-eureka-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">添加完成后，再修改配置，在 Config Server 和 Config Client 中分别添加如下配置，表示将这两个服务注册到 eureka 上面：</p>
</div><div class="cl-preview-section"><pre class="  language-properties"><code class="prism  language-properties"><span class="token attr-name">eureka.client.service-url.defaultZone</span><span class="token punctuation">=</span><span class="token attr-value">http://localhost:1111/eureka</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">好了，上面这两条是 Config Server 和 Config Client 共同的配置。接下来，我们还需要在 Config Client 中再额外修改一些配置，修改后的 Config Client 的 bootstrap.properties 的配置内容如下：</p>
</div><div class="cl-preview-section"><pre class="  language-properties"><code class="prism  language-properties"><span class="token attr-name">spring.application.name</span><span class="token punctuation">=</span><span class="token attr-value">client1</span>
<span class="token attr-name">server.port</span><span class="token punctuation">=</span><span class="token attr-value">8002</span>
<span class="token attr-name">spring.cloud.config.profile</span><span class="token punctuation">=</span><span class="token attr-value">dev</span>
<span class="token attr-name">spring.cloud.config.label</span><span class="token punctuation">=</span><span class="token attr-value">master</span>
<span class="token comment">#spring.cloud.config.uri=http://localhost:8001/</span>
<span class="token attr-name">spring.cloud.config.discovery.service-id</span><span class="token punctuation">=</span><span class="token attr-value">config-server</span>
<span class="token attr-name">spring.cloud.config.discovery.enabled</span><span class="token punctuation">=</span><span class="token attr-value">true</span>

<span class="token attr-name">spring.cloud.config.username</span><span class="token punctuation">=</span><span class="token attr-value">javaboy</span>
<span class="token attr-name">spring.cloud.config.password</span><span class="token punctuation">=</span><span class="token attr-value">123</span>

<span class="token attr-name">eureka.client.service-url.defaultZone</span><span class="token punctuation">=</span><span class="token attr-value">http://localhost:1111/eureka</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这里其实就是使用 <code>spring.cloud.config.discovery.service-id=config-server</code> 和 <code>spring.cloud.config.discovery.enabled=true</code> 两个配置代替了原来的 <code>spring.cloud.config.uri=http://localhost:8001/</code> 。其中 <code>spring.cloud.config.discovery.service-id=config-server</code> 表示配置 Config Server 的实例 id ，Config Client 将根据这个 id 去 eureka 上面查找 Config Server 的信息， <code>spring.cloud.config.discovery.enabled=true</code> 则表示开启通过 eureka 获取 Config Server 的功能。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">配置完成后，我们就可以启动 Config Client 了。启动成功后，我们再次访问 Config Client 中的 <code>/hello</code> 接口，获取到的数据和前面的一样，说明配置成功。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">配置成功之后，以后我们所有的 Config Client 都按照上面的配置信息来配置，即开启通过注册中心来访问 Config Server 的功能，同时指定 Config Server 的实例 id ，而不用在 Config Client 中硬编码 Config Server 的地址。</p>
</div><div class="cl-preview-section"><h2 id="动态刷新" style="font-size: 30px;">动态刷新</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">接下来我们再来看一下配置文件动态刷新的问题，在 8-1 小节中，我们向大家演示过，当 GitHub 仓库中配置文件发生改变后，如果我们刷新 Config Server 中的请求地址，会发现数据也跟着变化了，即 Config Server 是能够及时感知到配置文件的变化的，但是这种感知却不能够传递到 Config Client 中去，即 Config Client 是无法及时感知到配置文件的变化的，默认情况下，只有 Config Client 重启，才能够加载到最新的配置文件数据，如何让 Config Client 也能动态刷新配置数据呢？</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">想要让 Config Client 动态刷新配置数据，其实很容易，首先我们需要在 Config Client 中引入 actuator 依赖，如下：</p>
</div><div class="cl-preview-section"><pre class="  language-xml"><code class="prism  language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-actuator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">如果是 Spring Cloud Finchley 版（不含）之前的版本，那么直接添加依赖就完事了，不需要做额外配置，但是在 Finchley 版之后，因为采用的 Spring Boot 版本是 2.0.x ，Spring Boot 2 之后，考虑到数据安全，actuator 默认只开放了两个接口 health 和 info 。因此，在 Greenwich 版中，除了添加依赖外，我们还需要手动添加如下配置，表示暴露 refresh 接口：</p>
</div><div class="cl-preview-section"><pre class="  language-properties"><code class="prism  language-properties"><span class="token attr-name">management.endpoints.web.exposure.include</span><span class="token punctuation">=</span><span class="token attr-value">refresh</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">另外，我们还需要在 Config Client 中的 HelloController 上添加一个 <code>@RefreshScope</code> 注解，表示当调用 <code>/refresh</code> 接口时，动态更新容器中的数据，如下：</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java"><span class="token annotation punctuation">@RestController</span>
<span class="token annotation punctuation">@RefreshScope</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloController</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${javaboy}"</span><span class="token punctuation">)</span>
    String hello<span class="token punctuation">;</span>
    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> String <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> hello<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">配置完成后，我们再重新启动 Config Client ，启动成功后，我们在 IntelliJ IDEA 控制台的 Endpoints 中就可以看到 <code>/actuator/refresh</code> 接口已经暴露出来了，如下：</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><img src="http://img.mukewang.com/5d1097e70001e1c712340612.png" alt="图片描述" data-original="http://img.mukewang.com/5d1097e70001e1c712340612.png" class="" style="cursor: pointer;"></p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">一会儿，我们将通过调用这个接口实现配置文件的动态刷新。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">接下来，我们分别启动 Config Server 和 Config Client ，然后修改本地仓库中的配置文件。修改完成后，提交到远程仓库，此时我们直接访问 Config Client 的 <code>/hello</code> 接口，发现数据并未发生变化，别急，我们先调用 Config Client 的 <code>/actuator/refresh</code> 接口，注意这个接口的调用是一个 POST 请求，如下：</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><img src="http://img.mukewang.com/5d1097f30001082c14060604.png" alt="图片描述" data-original="http://img.mukewang.com/5d1097f30001082c14060604.png" class="" style="cursor: pointer;"></p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">调用成功之后，再去调用 Config Client 的 <code>/hello</code> 接口，此时发现配置文件已经发生变化了。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这样，我们在不重启 Config Client 的情况下，就能够动态刷新配置了，可能有人还是觉得这样太麻烦了，因为所有的微服务都要挨个去发送 <code>/actuator/refresh</code> 请求，这个工作量也不小，那么这个工作有没有可能做进一步的简化呢？当然是可以的，我们在后面的文章会继续为大家介绍。</p>
</div><div class="cl-preview-section"><h2 id="请求失败重试" style="font-size: 30px;">请求失败重试</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">请求失败重试这也是一个非常常见的需求，在前面的文章中为大家介绍过微服务调用过程中的请求失败重试问题，那么 Config Client 在调用 Config Server 时，一样也会发生请求失败的问题。我们平时做开发，一般来说公司的网络都是杠杠滴，但是在实际生产环境中，网络问题各种各样，我们必须考虑弱网环境下如何保证服务的高可用性，那么请求失败重试就是策略之一。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">要在 Config Client 中实现请求失败重试，其实非常容易，添加如下两个依赖即可：</p>
</div><div class="cl-preview-section"><pre class="  language-xml"><code class="prism  language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.retry<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-retry<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-aop<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">添加完成后，还需要我们在 Config Client 的配置文件中添加如下配置：</p>
</div><div class="cl-preview-section"><pre class="  language-properties"><code class="prism  language-properties"><span class="token attr-name">spring.cloud.config.fail-fast</span><span class="token punctuation">=</span><span class="token attr-value">true</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这行配置表示开启失败快速响应。什么是失败快速响应呢？默认情况下，当 Config Client 访问 Config Server 失败时，并不会立马报错，而是会等到用这个数据时，才会抛出异常，以我们前面的代码为例，如果 Config Client 访问 Config Server 失败，并不会立马抛出异常，而是等到在 Config Client 中使用注入进来的 javaboy 这个变量时，发现没有这个变量，此时才会抛出异常。这个时候项目已经启动失败了，停止运行了，所以也不会有失败重试什么事了，因此我们要开启失败快速响应。什么是失败快速响应呢？就是当 Config Client 访问 Config Server 失败时，就不再执行后面的流程了，立马做出响应，重试 or 抛异常。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">添加完这个配置之后，为了演示执行效果，接下来我们再做一点点修改，由于目前我们的 Config Server 是有安全认证的，Config Client 必须要有用户名密码才能访问到 Config Server 中的数据。我们暂时先注释掉 Config Client 中访问 Config Server 的用户名密码，即如下两行：</p>
</div><div class="cl-preview-section"><pre class="  language-properties"><code class="prism  language-properties"><span class="token comment">#spring.cloud.config.username=javaboy</span>
<span class="token comment">#spring.cloud.config.password=1234</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">注释掉之后，我们再去启动 Config Client ，此时就会启动失败，我们来观察效果重试效果：</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><img src="http://img.mukewang.com/5d1098030001fac523060486.png" alt="图片描述" data-original="http://img.mukewang.com/5d1098030001fac523060486.png" class="" style="cursor: pointer;"></p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">可以看到，请求一共发送了6次，第一次失败之后，还重试了5次。这是默认的请求重试策略，开发者也可以自定义请求重试的相关参数，如下：</p>
</div><div class="cl-preview-section"><pre class="  language-properties"><code class="prism  language-properties"><span class="token attr-name">spring.cloud.config.retry.initial-interval</span><span class="token punctuation">=</span><span class="token attr-value">1000</span>
<span class="token attr-name">spring.cloud.config.retry.multiplier</span><span class="token punctuation">=</span><span class="token attr-value">1.1</span>
<span class="token attr-name">spring.cloud.config.retry.max-interval</span><span class="token punctuation">=</span><span class="token attr-value">2000</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这四个配置含义如下：</p>
</div><div class="cl-preview-section"><ol>
<li style="font-size: 20px; line-height: 38px;">max-attempts 表示最大请求次数，默认值为 6 ，就是大家在上图看到的情况；</li>
<li style="font-size: 20px; line-height: 38px;">initial-interval 表示请求重试的初始时间间隔；</li>
<li style="font-size: 20px; line-height: 38px;">multiplier 表示时间的间隔乘数，由于网络抖动一般都是有规律的，为了防止请求重试时连续的冲突，我们需要一个时间间隔乘数，这里我设置了间隔乘数为 1.2 ，表示第一次重试间隔时间为 1 s，第二次间隔时间为 1.2 秒，第三次间隔时间为 1.44 秒…；</li>
<li style="font-size: 20px; line-height: 38px;">max-interval 表示重试的最大间隔时间。</li>
</ol>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">开启了请求重试机制之后，即使在弱网环境下，我们也能有效保证服务的可用性。</p>
</div><div class="cl-preview-section"><div class="summary"><h5 class="centertitle" style="font-size: 20px; line-height: 38px;">小结 </h5></div><!--title:&#23567;&#32467; -->
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">本文主要向大家介绍了分布式配置中心 Spring Cloud Config 中三个常见的问题，服务化、配置数据动态刷新以及请求失败重试。服务化降低了 Config Server 和 Config Client 之间的耦合度，使我们的项目架构更加规范；动态刷新则让我们在不重启 Config Client 的情况下，能够刷新配置数据；最后的请求重试则保证了弱网环境下服务的可用性，在实际生产项目中，这三个基本上也都是必配的，大家需要认真掌握。</p>
</div></div>
            </div>
                            <!-- 买过的阅读 -->
                <div class="art-next-prev clearfix">
                                                                        <!-- 已买且开放 或者可以试读 -->
                            <a href="/read/37/article/509">
                                                    <div class="prev l clearfix">
                                <div class="icon l">
                                    <i class="imv2-arrow3_l"></i>
                                </div>
                                <p>
                                    23 Spring Cloud Config 中配置文件的加密与解密
                                </p>
                            </div>
                        </a>
                                                                                            <!-- 已买且开放 或者可以试读 -->
                            <a href="/read/37/article/513">
                                                    <div class="next r clearfix">
                                <p>
                                    25 Docker 简介与消息中间件安装
                                </p>
                                <div class="icon r">
                                    <i class="imv2-arrow3_r"></i>
                                </div>

                            </div>
                        </a>
                                    </div>
                    </div>
        <div class="comments-con js-comments-con" id="coments_con">
        </div>



    </div>
    
    
    

</div>
 
<!-- 专栏介绍页专栏评价 -->

<!-- 专栏介绍页底部三条评价 -->

<!-- 专栏阅读页弹层目录和介绍页页面目录 -->

<!-- 专栏阅读页发布回复 -->

<!-- 专栏阅读页发布评论 -->

<!-- 专栏阅读页底部评论 -->

<!-- 专栏阅读 单个 评论 -->

<!-- 新增回复和展开三条以外回复 -->

<!-- 立即订阅的弹窗 -->












</div></body></html>