<html><head><meta charset="utf-8"><title>13 服务请求负载均衡-慕课专栏</title>
			<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
			<meta name="renderer" content="webkit">
			<meta property="qc:admins" content="77103107776157736375">
			<meta property="wb:webmaster" content="c4f857219bfae3cb">
			<meta http-equiv="Access-Control-Allow-Origin" content="*">
			<meta http-equiv="Cache-Control" content="no-transform ">
			<meta http-equiv="Cache-Control" content="no-siteapp">
			<link rel="apple-touch-icon" sizes="76x76" href="https://www.imooc.com/static/img/common/touch-icon-ipad.png">
			<link rel="apple-touch-icon" sizes="120x120" href="https://www.imooc.com/static/img/common/touch-icon-iphone-retina.png">
			<link rel="apple-touch-icon" sizes="152x152" href="https://www.imooc.com/static/img/common/touch-icon-ipad-retina.png">
			<link href="https://moco.imooc.com/captcha/style/captcha.min.css" rel="stylesheet">
			<link rel="stylesheet" href="https://www.imooc.com/static/moco/v1.0/dist/css/moco.min.css?t=201907021539" type="text/css">
			<link rel="stylesheet" href="https://www.imooc.com/static/lib/swiper/swiper-3.4.2.min.css?t=201907021539">
			<link rel="stylesheet" href="../zhuanlanChapter-less.css?v=201907051055" type="text/css">
			<link charset="utf-8" rel="stylesheet" href="https://www.imooc.com/static/lib/ueditor/themes/imooc/css/ueditor.css?v=201907021539"><link rel="stylesheet" href="https://www.imooc.com/static/lib/baiduShare/api/css/share_style0_16.css?v=6aba13f0.css"></head>
			<body><div id="main">

<div class="container clearfix" id="top" style="display: block; width: 1134px;">
    
    <div class="center_con js-center_con l" style="width: 1134px;">
        <div class="article-con">
                            <!-- 买过的阅读 -->
                <div class="map">
                    <a href="/read" target="_blank"><i class="imv2-feather-o"></i></a>
                    <a href="/read/37" target="_blank">Spring Cloud微服务开发实践</a>
                    <a href="" target="_blank">
                        <span>
                            / 4-3 13 服务请求负载均衡
                        </span>
                    </a>
                </div>

            


            <div class="art-title" style="margin-top: 0px;">
                13 服务请求负载均衡
            </div>
            <div class="art-info">
                
                <span>
                    更新时间：2019-06-19 17:56:16
                </span>
            </div>
            <div class="art-top">
                                <img src="https://img.mukewang.com/5d035f0c000168c606400359.jpg" alt="">
                                                <div class="famous-word-box">
                    <img src="https://www.imooc.com/static/img/column/bg-l.png" alt="" class="bg1 bg">
                    <img src="https://www.imooc.com/static/img/column/bg-r.png" alt="" class="bg2 bg">
                    <div class="famous-word">如果不想在世界上虚度一生，那就要学习一辈子。<p class="author">——高尔基</p></div>
                </div>
                            </div>
            <div class="art-content js-lookimg">
                <div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">通过前面文章的学习，大家已经了解到如何搭建服务注册中心，如何将一个 provider 注册到服务注册中心， consumer 又如何从服务注册中心获取到 provider 的地址，在 consumer 获取 provider 地址时，我们一直采用了 DiscoveryClient 来手动获取，这样出现了大量冗余代码，而且负载均衡功能也没能实现。因此，本文我将和大家分享在微服务中如何实现负载均衡，以及负载均衡的实现原理、常见的负载均衡策略等。</p>
</div><div class="cl-preview-section"><h2 id="准备工作" style="font-size: 30px;">准备工作</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">参考前面的文章，我们首先创建一个名为 Loadbalancer 的父工程，然后在父工程中创建一个名为 eureka 的服务注册中心，再创建一个名为 provider 的微服务， provider 中提供一个 <code>/hello</code> 接口， provider 中的 <code>/hello</code> 接口如下：</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java"><span class="token annotation punctuation">@RestController</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloController</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${server.port}"</span><span class="token punctuation">)</span>
    Integer port<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> String <span class="token function">hello</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">"hello "</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">" ; "</span> <span class="token operator">+</span> port<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">注意这里的 <code>/hello</code> 接口和前面我们学习的 <code>/hello</code> 接口有一点点不一样，这里我将当前应用运行的端口号注入进来，并且在接口中将端口号返回，这样主要是为了当大家从 consumer 中调用 provider 时，能够知道到底是哪个 provider 提供了服务。最后再在 provider 的 application.properties 文件中添加配置，将 provider 注册到服务注册中心上，如下：</p>
</div><div class="cl-preview-section"><pre><code>spring.application.name=provider
server.port=4001
eureka.client.service-url.defaultZone=http://localhost:1111/eureka
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">完成之后，首先启动 eureka，然后在 IntelliJ IDEA 的右侧找到 Maven Project 选项，再找到 provider 项目，对 provider 项目进行打包，如下：</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><img src="http://img.mukewang.com/5d00dc5f0001857803880388.png" alt="图片描述" data-original="http://img.mukewang.com/5d00dc5f0001857803880388.png" class="" style="cursor: pointer;"></p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">打包成功后，在 provider/target 目录下会生成一个名为 provider-0.0.1-SNAPSHOT.jar 的 jar 包，然后打开两个命令行窗口，定位到 provider/target 目录下，分别执行如下两行命令：</p>
</div><div class="cl-preview-section"><pre><code>java -jar provider-0.0.1-SNAPSHOT.jar --server.port=4001  
java -jar provider-0.0.1-SNAPSHOT.jar --server.port=4002
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这两个命令各自在一个窗口中执行，执行完成后，将启动两个 provider 实例，两个实例的端口分别是 4001 和 4002 ，此时打开 eureka 控制面板，可以看到两个 provider 实例，如下：</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><img src="http://img.mukewang.com/5d00dc6b0001414910540580.png" alt="图片描述" data-original="http://img.mukewang.com/5d00dc6b0001414910540580.png" class="" style="cursor: pointer;"></p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">如此之后，我们的准备工作就算做完了。</p>
</div><div class="cl-preview-section"><h2 id="手动实现负载均衡" style="font-size: 30px;">手动实现负载均衡</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">现在，再创建一个 consumer ，并将之注册到 eureka 上，这个具体过程我这里就不再重复，不记得的同学可以参考本章前面两篇文章。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">consumer 创建成功后，在 consumer 中创建一个 UseHelloController 的类，里边创建一个 <code>/hello</code> 接口，然后利用 DiscoveryClient 。我们先手动实现一个简单的基于轮询策略的负载均衡效果，具体代码如下：</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java"><span class="token annotation punctuation">@RestController</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UseHelloController</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Autowired</span>
    DiscoveryClient discoveryClient<span class="token punctuation">;</span>
    <span class="token annotation punctuation">@Autowired</span>
    RestTemplate restTemplate<span class="token punctuation">;</span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> String <span class="token function">hello</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        List<span class="token operator">&lt;</span>ServiceInstance<span class="token operator">&gt;</span> list <span class="token operator">=</span> discoveryClient<span class="token punctuation">.</span><span class="token function">getInstances</span><span class="token punctuation">(</span><span class="token string">"provider"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ServiceInstance instance <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>count <span class="token operator">%</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        count<span class="token operator">++</span><span class="token punctuation">;</span>
        String host <span class="token operator">=</span> instance<span class="token punctuation">.</span><span class="token function">getHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> port <span class="token operator">=</span> instance<span class="token punctuation">.</span><span class="token function">getPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        String s <span class="token operator">=</span> restTemplate<span class="token punctuation">.</span><span class="token function">getForObject</span><span class="token punctuation">(</span><span class="token string">"http://"</span> <span class="token operator">+</span> host <span class="token operator">+</span> <span class="token string">":"</span> <span class="token operator">+</span> port <span class="token operator">+</span> <span class="token string">"/hello?name={1}"</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> s<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这里一个简单的轮询策略的负载均衡实现思路如下：</p>
</div><div class="cl-preview-section"><ol>
<li style="font-size: 20px; line-height: 38px;">由于 DiscoveryClient 可以从 eureka 上获取到 provider 的所有实例，这些获取到的所有实例保存在一个 List 集合中，因此所谓的轮询，实际上就是从 List 集合中循环取出 ServiceInstance 实例，组装成相关的地址去运行；</li>
<li style="font-size: 20px; line-height: 38px;">基于第一步的分析，我们创建一个全局变量 count ，每次将集合大小与 count 取模，以取模的结果为下标，从 List 集合中取出相关的实例，然后拼接出请求地址。</li>
</ol>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这个过程其实很简单，轮询的逻辑也很简单，该方法执行结果如下图：</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><img src="http://img.mukewang.com/5d00dc79000129fa00730050.gif" alt="图片描述" data-original="http://img.mukewang.com/5d00dc79000129fa00730050.gif" class="" style="cursor: pointer;"></p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">可以看到，服务是由端口为 4001 的 provider 和端口为 4002 的 provider 来轮流提供的。有没有发现负载均衡其实很简单！</p>
</div><div class="cl-preview-section"><h2 id="使用-loadbalancer-实现负载均衡" style="font-size: 30px;">使用 @Loadbalancer 实现负载均衡</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">上面是一个自己手动实现的负载均衡，代码量虽然不大，但是如果每次请求都这么写，实际上还是很头大，因为充斥着大量的代码冗余，此时，有人可能会想到上篇文章我们在讲解 RestTemplate 时提到的拦截器，如果能够在拦截器中将请求地址拦截下来，然后自动进行负载均衡计算，进而使用一个合适的地址去发送请求的话，就会方便很多。没错，实际上在 Spring Cloud 中也是这么做的！</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">在 Spring Cloud 中，要实现负载均衡其实非常容易，只需要在 RestTemplate 的Bean上添加一个 @LoadBalanced 注解即可，如下：</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java"><span class="token annotation punctuation">@Bean</span>
<span class="token annotation punctuation">@LoadBalanced</span>
RestTemplate <span class="token function">loadBalancer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RestTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">此时的 RestTemplate 就是一个具备负载均衡功能的 RestTemplate 了，接下来，在 UseHelloController 中继续添加如下代码：</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java"><span class="token annotation punctuation">@Autowired</span>
<span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"loadBalancer"</span><span class="token punctuation">)</span>
RestTemplate loadBalancer<span class="token punctuation">;</span>
<span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/hello2"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> String <span class="token function">hello2</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    String s <span class="token operator">=</span> loadBalancer<span class="token punctuation">.</span><span class="token function">getForObject</span><span class="token punctuation">(</span><span class="token string">"http://provider/hello?name={1}"</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">是不是一下清爽了很多？关于这段代码，解释如下：</p>
</div><div class="cl-preview-section"><ol>
<li style="font-size: 20px; line-height: 38px;">由于现在项目中存在两个 RestTemplate 的实例，因此这里我加了 @Qualifier(“loadBalancer”) 注解，表示通过名称来查找 RestTemplate 的实例（如果继续根据类型来查找，系统会不知道到底注入哪个实例）；</li>
<li style="font-size: 20px; line-height: 38px;">此时注入进来的 RestTemplate 实例自动就具备了负载均衡功能，但需要注意的是这里的请求地址，原本的 <code>Host+":"+Port</code> 被微服务名称所替代，实际上这个很好理解，因为这里如果还继续明确直接指定了服务地址的话，那还怎么负载均衡呀？</li>
<li style="font-size: 20px; line-height: 38px;">这里使用了 provider 来代替 <code>Host+":"+Port</code> ，在真正的请求发起时，会通过拦截器将请求拦截下来，然后将 provider 换成一个具体的服务地址。</li>
</ol>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">使用了具备负载均衡功能的 RestTemplate 之后，当我们再次启动 consumer ，发起一个网络访问时，可以在 IntelliJ IDEA 的控制台看到如下日志：<br>
<img src="http://img.mukewang.com/5d00dc830001769112380272.png" alt="图片描述" data-original="http://img.mukewang.com/5d00dc830001769112380272.png" class="" style="cursor: pointer;"></p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">可以看到， consumer 会自动从 eureka 上根据 provider 获取 provider 所有实例的信息，不仅仅包括实例的地址信息，也包括实例的历史请求数据等信息，根据这些辅助数据，可以实现不同的负载均衡策略。</p>
</div><div class="cl-preview-section"><h3 id="请求失败重试">请求失败重试</h3>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">具备了负载均衡功能的 RestTemplate 也可以开启请求重试功能。有的时候，在微服务调用的过程中，由于网络抖动等原因造成了访问失败，这个时候如果直接就认定访问失败显然是不划算的，可以多尝试几次，多次尝试之后，如果还是请求失败，再判定访问失败。默认情况下，重试功能是没有开启的，开启重试功能很简单，开发者只需要在 consumer 中添加 Spring Retry 依赖即可，如下：</p>
</div><div class="cl-preview-section"><pre class="  language-xml"><code class="prism  language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.retry<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-retry<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">只要添加了该依赖，我们的 RestTemplate 此时就自动具备了请求失败重试的功能（注意，加入依赖后请求失败重试功能就会自动开启了），如果开发者加入了该依赖，但是又不想开启请求失败重试功能，可以在application.properties中添加如下配置：</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java">spring<span class="token punctuation">.</span>cloud<span class="token punctuation">.</span>loadbalancer<span class="token punctuation">.</span>retry<span class="token punctuation">.</span>enabled<span class="token operator">=</span><span class="token boolean">false</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">表示关闭请求失败重试功能。至于请求失败重试的次数以及切换实例的次数，可以通过如下配置实现：</p>
</div><div class="cl-preview-section"><pre><code># 最大的重试次数，不包括第一次请求
ribbon.MaxAutoRetries=3
# 最大重试server的个数，不包括第一个 server
ribbon.MaxAutoRetriesNextServer=1
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">另外也可以指定是否开启任何异常都重试：</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java">ribbon<span class="token punctuation">.</span>OkToRetryOnAllOperations<span class="token operator">=</span><span class="token boolean">true</span>
</code></pre>
</div><div class="cl-preview-section"><h3 id="客户端负载均衡">客户端负载均衡</h3>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">细心的同学可能发现，这里我们所说的负载均衡和大家平时所了解到的负载均衡不太一样，平时我们所说的负载均衡一般是指 Nginx 或者 F5 之类的工具，其中 Nginx也叫反向代理代理服务器，它的工作流程如下图：</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><img src="http://img.mukewang.com/5d00dc8e0001905105240467.png" alt="图片描述" data-original="http://img.mukewang.com/5d00dc8e0001905105240467.png" class="" style="cursor: pointer;"></p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">所有的请求首先到达负载均衡服务器，再由负载均衡服务器根据提前配置好的负载均衡策略，将请求转发到不同的 Real Server 上，对于客户端来说，它并不知道究竟是哪一个 Real Server 提供的服务，这种负载均衡方式我们一般称之为服务端负载均衡。而上文我们提到的负载均衡则与这种方式不同，上文的负载均衡是先将 provider 的所有地址拿到，然后 consumer 根据本地配置的负载均衡策略，从 provider 地址列表中挑选一个地址去调用，调用过程如下图：</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><img src="http://img.mukewang.com/5d00dc960001cba903480472.png" alt="图片描述" data-original="http://img.mukewang.com/5d00dc960001cba903480472.png" class="" style="cursor: pointer;"></p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">在这个调用过程中，客户端首先去 Eureka 中获取 provider 地址，获取到 provider 地址列表之后，再根据本地提前配置好的负载均衡策略从地址列表中挑选一个地址去调用，这个过程没有中间代理服务器，到底调用哪一个服务是由 consumer 自己决定的，因此这种负载均衡我们也称之为客户端负载均衡。</p>
</div><div class="cl-preview-section"><h2 id="常见负载均衡策略" style="font-size: 30px;">常见负载均衡策略</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">通过上面的学习，大家了解到，默认的负载均衡策略实际上是轮询，那么除了这种负载均衡策略之外，还有哪些负载均衡策略呢？又是如何配置的呢？我们继续来看。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">要说负载均衡策略，就需要先向大家介绍一个接口叫做 ILoadBalancer ，它的源码如下：</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ILoadBalancer</span> <span class="token punctuation">{</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addServers</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Server<span class="token operator">&gt;</span> newServers<span class="token punctuation">)</span><span class="token punctuation">;</span>  
	<span class="token keyword">public</span> Server <span class="token function">chooseServer</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span><span class="token punctuation">;</span>  
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">markServerDown</span><span class="token punctuation">(</span>Server server<span class="token punctuation">)</span><span class="token punctuation">;</span>  
	<span class="token annotation punctuation">@Deprecated</span>  
	<span class="token keyword">public</span> List<span class="token operator">&lt;</span>Server<span class="token operator">&gt;</span> <span class="token function">getServerList</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> availableOnly<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Server<span class="token operator">&gt;</span> <span class="token function">getReachableServers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
	<span class="token keyword">public</span> List<span class="token operator">&lt;</span>Server<span class="token operator">&gt;</span> <span class="token function">getAllServers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">从方法名大致就可以看出，这里有服务的添加、选择、标记服务下线、获取服务列表等功能，这个接口的实现类如下：</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><img src="http://img.mukewang.com/5d00dc9d000168ca04170395.png" alt="图片描述" data-original="http://img.mukewang.com/5d00dc9d000168ca04170395.png" class="" style="cursor: pointer;"></p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">在它的实现类 BaseLoadBalancer 中，去向 Eureka 获取服务列表，并不断地通过心跳消息去检查服务是否可用，有了服务列表之后，再根据具体的 IRule 进行负载均衡，所以，我们再来关注下 IRule ，这也是一个接口，它的实现类如下：</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><img src="http://img.mukewang.com/5d00dca500015b4d10740395.png" alt="图片描述" data-original="http://img.mukewang.com/5d00dca500015b4d10740395.png" class="" style="cursor: pointer;"></p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这里一个实现类就代表了一个负载均衡实现策略，例如：</p>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">RandomRule 表示随机策略</li>
<li style="font-size: 20px; line-height: 38px;">RoundRobinRule 表示轮询策略</li>
<li style="font-size: 20px; line-height: 38px;">WeightedResponseTimeRule 表示加权策略（即将过期，功能和 ResponseTimeWeightedRule 一致）</li>
<li style="font-size: 20px; line-height: 38px;">ResponseTimeWeightedRule 也是加权，它是根据每一个 Server 的平均响应时间动态加权，响应时间越长，权重越小，处理请求的机会也越小</li>
<li style="font-size: 20px; line-height: 38px;">RetryRule 表示一个具备重试功能的负载均衡策略，内部默认使用了 RoundRobinRule 这个内部也可以自己传其他的负载均衡策略进去</li>
<li style="font-size: 20px; line-height: 38px;">BestAvailableRule 策略表示使用并发数最小的服务</li>
</ul>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">那么这些不同的负载均衡策略要如何去配置呢？很简单，需要哪种负载均衡，就提供哪种负载均衡的 IRule 实例就行了。例如，需要使用随机策略，那么只需要在 consumer 的配置类中提供一个 RandomRule 的实例即可，如下：</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java"><span class="token annotation punctuation">@Bean</span>
IRule <span class="token function">iRule</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RandomRule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">此时，多次访问 provider 接口，就会发现负载均衡策略已经变为随机策略了。</p>
</div><div class="cl-preview-section"><h2 id="负载均衡原理" style="font-size: 30px;">负载均衡原理</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">网上关于负载均衡策略源码分析的文章很多，但是大多数都看得初学者丈二和尚摸不着头脑，因为这里确实涉及到的类比较多，因此本文换一个思路来和大家讲这个原理。关于负载均衡，大家可能会比较感兴趣服务列表到底是什么时候通过什么方式加载的？为什么在 RestTemplate 访问中不需要写服务的具体地址，而只需要给一个服务名就行了？所有的配置又是如何切入到 RestTemplate 中的？接下来，带着这些问题，我来和大家分析负载均衡具体的实现逻辑。</p>
</div><div class="cl-preview-section"><h3 id="服务列表加载问题">服务列表加载问题</h3>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">首先第一个问题就是服务列表的加载问题。在前面的文章中，我们都是自己通过 DiscoveryClient 手动获取服务地址列表的，自从用了 @LoadBalanced 注解之后，我们不再需要自己手动加载地址了，直接写服务名就可以了，不用看源码我们也知道，服务名最终肯定要被转为一个具体的地址才能使用，那么这个过程到底是在哪里呢？</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">通过查看 @LoadBalanced 的源码我们发现凡是加了该注解的 RestTemplate 都会被自动配置一个 LoadBalancerClient ，LoadBalancerClient 只是一个接口，这个接口继承自 ServiceInstanceChooser 并且只有一个实现类 RibbonLoadBalancerClient ，如下图：</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><img src="http://img.mukewang.com/5d00dcaf0001202802410233.png" alt="图片描述" data-original="http://img.mukewang.com/5d00dcaf0001202802410233.png" class="" style="cursor: pointer;"></p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">其中， ServiceInstanceChooser 里边只定义了一个方法，如下：</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ServiceInstanceChooser</span> <span class="token punctuation">{</span>
	ServiceInstance <span class="token function">choose</span><span class="token punctuation">(</span>String serviceId<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">看名字就知道，这个方法是用来根据 serviceId 获取 ServiceInstance 的， ServiceInstance 中则保存了一个服务的详细信息， LoadBalancerClient 接口在此基础上又增加了三个方法，如下：</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">LoadBalancerClient</span> <span class="token keyword">extends</span> <span class="token class-name">ServiceInstanceChooser</span> <span class="token punctuation">{</span>

	<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> T <span class="token function">execute</span><span class="token punctuation">(</span>String serviceId<span class="token punctuation">,</span> LoadBalancerRequest<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> request<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span>

	<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> T <span class="token function">execute</span><span class="token punctuation">(</span>String serviceId<span class="token punctuation">,</span> ServiceInstance serviceInstance<span class="token punctuation">,</span>
			LoadBalancerRequest<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> request<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span>

	URI <span class="token function">reconstructURI</span><span class="token punctuation">(</span>ServiceInstance instance<span class="token punctuation">,</span> URI original<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这里方法有三个， execute 方法用来做执行操作， reconstructURI 方法则用来重构 Url，也就是把 <code>http://provider/hello</code> 这样的地址变为 <code>http://localhost:4001/hello</code> 这样的形式。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这里只是一个接口，具体的实现在 RibbonLoadBalancerClient 类中。在该类中，首先来看服务的选择问题， choose 方法经过一系列的跳转最终来到了这里：</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java"><span class="token keyword">public</span> ServiceInstance <span class="token function">choose</span><span class="token punctuation">(</span>String serviceId<span class="token punctuation">,</span> Object hint<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	Server server <span class="token operator">=</span> <span class="token function">getServer</span><span class="token punctuation">(</span><span class="token function">getLoadBalancer</span><span class="token punctuation">(</span>serviceId<span class="token punctuation">)</span><span class="token punctuation">,</span> hint<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>server <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> null<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RibbonServer</span><span class="token punctuation">(</span>serviceId<span class="token punctuation">,</span> server<span class="token punctuation">,</span> <span class="token function">isSecure</span><span class="token punctuation">(</span>server<span class="token punctuation">,</span> serviceId<span class="token punctuation">)</span><span class="token punctuation">,</span>
			<span class="token function">serverIntrospector</span><span class="token punctuation">(</span>serviceId<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span>server<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">在这个方法中，首先使用 getServer 方法去获取服务，这个方法最终会来到 ILoadBalancer 接口的 chooseServer 方法中， ILoadBalancer 接口的继承关系如下图：</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><img src="http://img.mukewang.com/5d00dcb8000175d606040395.png" alt="图片描述" data-original="http://img.mukewang.com/5d00dcb8000175d606040395.png" class="" style="cursor: pointer;"></p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">默认情况下，在 RibbonLoadBalancerClient 类中注入的 ILoadBalancer 的实例是 ZoneAwareLoadBalancer ，但是 ZoneAwareLoadBalancer 继承自 DynamicServerListLoadBalancer ，而在 DynamicServerListLoadBalancer 的构造方法中，调用了 <code>restOfInit(clientConfig);</code> 方法，该方法源码如下：</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java"><span class="token keyword">void</span> <span class="token function">restOfInit</span><span class="token punctuation">(</span>IClientConfig clientConfig<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">boolean</span> primeConnection <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isEnablePrimingConnections</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// turn this off to avoid duplicated asynchronous priming done in BaseLoadBalancer.setServerList()</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setEnablePrimingConnections</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">enableAndInitLearnNewServersFeature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">updateListOfServers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>primeConnection <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getPrimeConnections</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getPrimeConnections</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">primeConnections</span><span class="token punctuation">(</span><span class="token function">getReachableServers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setEnablePrimingConnections</span><span class="token punctuation">(</span>primeConnection<span class="token punctuation">)</span><span class="token punctuation">;</span>
    LOGGER<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"DynamicServerListLoadBalancer for client {} initialized: {}"</span><span class="token punctuation">,</span> clientConfig<span class="token punctuation">.</span><span class="token function">getClientName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>toString
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">在这个方法中，通过 updateListOfServers(); 去加载服务列表，而该方法会调用到 ServerList 接口中的 getUpdatedListOfServers 方法， ServerList 是一个接口，这个接口中定义了获取所有注册微服务信息的方法，它的最终实现类是 DomainExtractingServerList 。在 DomainExtractingServerList 中，我们终于看到了通过 EurekaClient 去获取服务列表的代码了，如下：</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java">    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>DiscoveryEnabledServer<span class="token operator">&gt;</span> <span class="token function">obtainServersViaDiscovery</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        EurekaClient eurekaClient <span class="token operator">=</span> eurekaClientProvider<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>vipAddresses<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span>String vipAddress <span class="token operator">:</span> vipAddresses<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                List<span class="token operator">&lt;</span>InstanceInfo<span class="token operator">&gt;</span> listOfInstanceInfo <span class="token operator">=</span> eurekaClient<span class="token punctuation">.</span><span class="token function">getInstancesByVipAddress</span><span class="token punctuation">(</span>vipAddress<span class="token punctuation">,</span> isSecure<span class="token punctuation">,</span> targetRegion<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span>InstanceInfo ii <span class="token operator">:</span> listOfInstanceInfo<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">//省略</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> serverList<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">毫无疑问，这里最终会来到 DiscoveryClient 中获取服务地址列表。至此，大家应该知道了服务列表是在哪里加载了吧！</p>
</div><div class="cl-preview-section"><h3 id="请求地址替换问题">请求地址替换问题</h3>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">那么请求地址又是怎么样从 <code>http://provider/hello</code> 变为 <code>http://localhost:4001/hello</code> 呢？上文我们提到了在 LoadBalancerClient 类中有一个方法叫做 reconstructURI ，这个方法就是用来重构 Url ，它的具体实现在 LoadBalancerContext 类的 reconstructURIWithServer 方法中，具体代码如下：</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java"><span class="token keyword">public</span> URI <span class="token function">reconstructURIWithServer</span><span class="token punctuation">(</span>Server server<span class="token punctuation">,</span> URI original<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    String host <span class="token operator">=</span> server<span class="token punctuation">.</span><span class="token function">getHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> port <span class="token operator">=</span> server<span class="token punctuation">.</span><span class="token function">getPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    String scheme <span class="token operator">=</span> server<span class="token punctuation">.</span><span class="token function">getScheme</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">if</span> <span class="token punctuation">(</span>host<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>original<span class="token punctuation">.</span><span class="token function">getHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> 
            <span class="token operator">&amp;&amp;</span> port <span class="token operator">==</span> original<span class="token punctuation">.</span><span class="token function">getPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token operator">&amp;&amp;</span> scheme <span class="token operator">==</span> original<span class="token punctuation">.</span><span class="token function">getScheme</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> original<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>scheme <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        scheme <span class="token operator">=</span> original<span class="token punctuation">.</span><span class="token function">getScheme</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>scheme <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        scheme <span class="token operator">=</span> <span class="token function">deriveSchemeAndPortFromPartialUri</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>scheme<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"://"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Strings<span class="token punctuation">.</span><span class="token function">isNullOrEmpty</span><span class="token punctuation">(</span>original<span class="token punctuation">.</span><span class="token function">getRawUserInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>original<span class="token punctuation">.</span><span class="token function">getRawUserInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"@"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>host<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>port <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">":"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>original<span class="token punctuation">.</span><span class="token function">getRawPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Strings<span class="token punctuation">.</span><span class="token function">isNullOrEmpty</span><span class="token punctuation">(</span>original<span class="token punctuation">.</span><span class="token function">getRawQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"?"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>original<span class="token punctuation">.</span><span class="token function">getRawQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Strings<span class="token punctuation">.</span><span class="token function">isNullOrEmpty</span><span class="token punctuation">(</span>original<span class="token punctuation">.</span><span class="token function">getRawFragment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"#"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>original<span class="token punctuation">.</span><span class="token function">getRawFragment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        URI newURI <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URI</span><span class="token punctuation">(</span>sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> newURI<span class="token punctuation">;</span>            
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">URISyntaxException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">方法参数 Server 中包含了服务的基本信息，original 则是待转换的 Url ，这里的逻辑整体比较好理解，就是将 Server 中的数据拿出来重新拼接地址。</p>
</div><div class="cl-preview-section"><h3 id="如何切入到-resttemplate-中">如何切入到 RestTemplate 中</h3>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">那么上面这些东西又是如何切入到 RestTemplate 中的呢？这里需要大家回忆一下上篇文章我们在介绍 RestTemplate 时讲过的拦截器，实际上，这里的功能也都是通过拦截器嵌入到 RestTemplate 的执行中的。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">当我们的 classpath 下存在 RestTemplate ，并且项目中存在 LoadBalancerClient 的实例时，在 LoadBalancerAutoConfiguration 类中就会启动一个自动配置，部分源码如下：</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java"><span class="token annotation punctuation">@Configuration</span>
<span class="token annotation punctuation">@ConditionalOnClass</span><span class="token punctuation">(</span>RestTemplate<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@ConditionalOnBean</span><span class="token punctuation">(</span>LoadBalancerClient<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@EnableConfigurationProperties</span><span class="token punctuation">(</span>LoadBalancerRetryProperties<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoadBalancerAutoConfiguration</span> <span class="token punctuation">{</span>
	<span class="token annotation punctuation">@Configuration</span>
	<span class="token annotation punctuation">@ConditionalOnClass</span><span class="token punctuation">(</span>RetryTemplate<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">RetryInterceptorAutoConfiguration</span> <span class="token punctuation">{</span>

		<span class="token annotation punctuation">@Bean</span>
		<span class="token annotation punctuation">@ConditionalOnMissingBean</span>
		<span class="token keyword">public</span> RetryLoadBalancerInterceptor <span class="token function">ribbonInterceptor</span><span class="token punctuation">(</span>
				LoadBalancerClient loadBalancerClient<span class="token punctuation">,</span>
				LoadBalancerRetryProperties properties<span class="token punctuation">,</span>
				LoadBalancerRequestFactory requestFactory<span class="token punctuation">,</span>
				LoadBalancedRetryFactory loadBalancedRetryFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RetryLoadBalancerInterceptor</span><span class="token punctuation">(</span>loadBalancerClient<span class="token punctuation">,</span> properties<span class="token punctuation">,</span>
					requestFactory<span class="token punctuation">,</span> loadBalancedRetryFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token annotation punctuation">@Bean</span>
		<span class="token annotation punctuation">@ConditionalOnMissingBean</span>
		<span class="token keyword">public</span> RestTemplateCustomizer <span class="token function">restTemplateCustomizer</span><span class="token punctuation">(</span>
				<span class="token keyword">final</span> RetryLoadBalancerInterceptor loadBalancerInterceptor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">return</span> restTemplate <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
				List<span class="token operator">&lt;</span>ClientHttpRequestInterceptor<span class="token operator">&gt;</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>
						restTemplate<span class="token punctuation">.</span><span class="token function">getInterceptors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>loadBalancerInterceptor<span class="token punctuation">)</span><span class="token punctuation">;</span>
				restTemplate<span class="token punctuation">.</span><span class="token function">setInterceptors</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">可以看到，在这里，自动向 RestTemplate 中加了一个拦截器 RetryLoadBalancerInterceptor ，正是这个拦截器将上面提到的所有功能给集成进来了，有兴趣的读者可以了解下具体的拦截过程，在 RetryLoadBalancerInterceptor 类的 intercept 方法中，通过 LoadBalancerClient 的实例进行了服务获取、负载均衡以及请求 Url 重构，该方法的逻辑就比较简单了，这里就不再赘述。</p>
</div><div class="cl-preview-section"><div class="summary"><h5 class="centertitle" style="font-size: 20px; line-height: 38px;">小结 </h5></div><!--title:&#23567;&#32467; -->
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">本文首先带领读者手动实现了一个简易的负载均衡功能，然后向读者介绍了 RestTemplate 如何在框架中实现负载均衡以及请求失败重试等配置，并带着读者大致过了一下源码，实际上这里的源码并不复杂，抓住主线，然后通过 Debug 的方式很容易将思路理清。由于集群化部署是微服务一个重要的特点，因此，负载均衡策略以及配置方式大家一定要掌握。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">本文作者：纯洁的微笑、江南一点雨</p>
</div></div>
            </div>
                            <!-- 买过的阅读 -->
                <div class="art-next-prev clearfix">
                                                                        <!-- 已买且开放 或者可以试读 -->
                            <a href="/read/37/article/442">
                                                    <div class="prev l clearfix">
                                <div class="icon l">
                                    <i class="imv2-arrow3_l"></i>
                                </div>
                                <p>
                                    12 RestTemplate 用法详解
                                </p>
                            </div>
                        </a>
                                                                                            <!-- 已买且开放 或者可以试读 -->
                            <a href="/read/37/article/444">
                                                    <div class="next r clearfix">
                                <p>
                                    14 声明式服务调用 Feign
                                </p>
                                <div class="icon r">
                                    <i class="imv2-arrow3_r"></i>
                                </div>

                            </div>
                        </a>
                                    </div>
                    </div>
        <div class="comments-con js-comments-con" id="coments_con">
        </div>



    </div>
    
    
    

</div>
 
<!-- 专栏介绍页专栏评价 -->

<!-- 专栏介绍页底部三条评价 -->

<!-- 专栏阅读页弹层目录和介绍页页面目录 -->

<!-- 专栏阅读页发布回复 -->

<!-- 专栏阅读页发布评论 -->

<!-- 专栏阅读页底部评论 -->

<!-- 专栏阅读 单个 评论 -->

<!-- 新增回复和展开三条以外回复 -->

<!-- 立即订阅的弹窗 -->












</div></body></html>