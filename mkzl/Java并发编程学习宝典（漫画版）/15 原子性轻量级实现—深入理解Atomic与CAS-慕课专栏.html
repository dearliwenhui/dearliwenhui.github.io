<html><head><meta charset="utf-8"><title>15 原子性轻量级实现—深入理解Atomic与CAS-慕课专栏</title>
			<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
			<meta name="renderer" content="webkit">
			<meta property="qc:admins" content="77103107776157736375">
			<meta property="wb:webmaster" content="c4f857219bfae3cb">
			<meta http-equiv="Access-Control-Allow-Origin" content="*">
			<meta http-equiv="Cache-Control" content="no-transform ">
			<meta http-equiv="Cache-Control" content="no-siteapp">
			<link rel="apple-touch-icon" sizes="76x76" href="https://www.imooc.com/static/img/common/touch-icon-ipad.png">
			<link rel="apple-touch-icon" sizes="120x120" href="https://www.imooc.com/static/img/common/touch-icon-iphone-retina.png">
			<link rel="apple-touch-icon" sizes="152x152" href="https://www.imooc.com/static/img/common/touch-icon-ipad-retina.png">
			<link href="https://moco.imooc.com/captcha/style/captcha.min.css" rel="stylesheet">
			<link rel="stylesheet" href="https://www.imooc.com/static/moco/v1.0/dist/css/moco.min.css?t=201907021539" type="text/css">
			<link rel="stylesheet" href="https://www.imooc.com/static/lib/swiper/swiper-3.4.2.min.css?t=201907021539">
			<link rel="stylesheet" href="https://static.mukewang.com/static/css/??base.css,common/common-less.css?t=2.5,column/zhuanlanChapter-less.css?t=2.5,course/inc/course_tipoff-less.css?t=2.5?v=201907051055" type="text/css">
			<link charset="utf-8" rel="stylesheet" href="https://www.imooc.com/static/lib/ueditor/themes/imooc/css/ueditor.css?v=201907021539"><link rel="stylesheet" href="https://www.imooc.com/static/lib/baiduShare/api/css/share_style0_16.css?v=6aba13f0.css"></head>
			<body><div id="main">


<div class="main-con hide-menu">
    <!-- 左侧菜单 & 索引 -->
    
    <div class="right-content" style="padding-left: 0px;">
        <div class="container clearfix" id="top" style="width: 1134px; display: block;">
            
            
            <div class="center_con js-center_con l" style="width: 1134px;">
                <div class="article-con">
                                            <!-- 买过的阅读 -->
                        

                    
                    <div class="art-title" style="margin-top: 0px;">
                        15 原子性轻量级实现—深入理解Atomic与CAS
                    </div>
                    <div class="art-info clearfix">
                        
                        <span class="l">
                            更新时间：2019-10-17 10:45:37
                        </span>
                    </div>
                    <div class="art-top">
                                                <img src="https://img3.mukewang.com/5da482f000019b8806400359.jpg" alt="">
                                                                        <div class="famous-word-box">
                            <img src="https://www.imooc.com/static/img/column/bg-l.png" alt="" class="bg1 bg">
                            <img src="https://www.imooc.com/static/img/column/bg-r.png" alt="" class="bg2 bg">
                            <div class="famous-word">构成我们学习最大障碍的是已知的东西，而不是未知的东西。 <p class="author">—— 贝尔纳</p></div>
                        </div>
                                            </div>
                    <div class="art-content js-lookimg">
                        <div id="article_content">
                            <div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">在上一章介绍了并发的三大特性，即原子性、可见性和有序性。从本节起，我们将学习如何在多线程开发中确保这三大特性。首先，最简单的方式就是使用 synchronized 关键字或者其它加锁。这种方式最大的好处是–简单！是的，无需动脑子，在需要的地方加锁就好了。同步方式在并发时包治百病，但治病的手段却是让多线程程序转为串行执行，这相当于自毁武功。如果滥用同步，那么程序就是去了多线程的意义。因此，只有在必要的时候才使用同步。比如对共享资源的访问。而且尽量控制同步代码块的范围，不需要使用同步的代码，尽量不要放入同步代码块。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">那么除了使用 synchronized 实现同步，还有其它手段保证三大特性吗？答案是肯定的，Java 还提供了轻量级的实现，来解决特定的问题。这些实现方式不像 synchronized 能够包治百病，但是对症下药，疗效更好。对于程序来说，在解决问题的同时，还能保证代码的效率。所以我们需要掌握好 synchronized 同步之外的这些方法，遇到并发问题时，采用更为合适的手段解决问题，而不是一股脑的都用 synchronized 或者其它显式锁的方式实现同步。这样才是一位合格的攻城狮！</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">本节我们来看看原子性的轻量级实现–Atomic。</p>
</div><div class="cl-preview-section"><h2 id="atomic简介" style="font-size: 30px;">1. Atomic 简介</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">Atomic 相关类在 java.util.concurrent.atomic 包中。针对不同的原生类型及引用类型，有 AtomicInteger、AtomicLong、AtomicBoolean、AtomicReference 等。另外还有数组对应类型 AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray。由于 Atomic 提供的功能类似，就不一个个过了。我们以 AtomicInteger 为例，看看 Atomic 类型变量所能提供的功能。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">我们先看一个简单的例子，运算逻辑是对变量 count 的累加。假如 count 为 int 类型，多个线程并发时，可能各自读取到了同样的值，也可能 A 线程读到 2，但由于某种原因更新晚了，count 已经被其它线程更新为了 4，但是线程 A 还是继续执行了 count+1 的操作，count 反而被更新为更小的值 3。现在的多线程程序是不安全的。要处理此问题，按照我们已经学习过的知识，需要把 count=count+1 放入 synchronized 代码块中。这样做肯定能够解决问题。但是这种同步操作是悲观锁的方式，每次都认为有其它线程在和它并发操作，所以每次都要对资源进行锁定，而加锁这个操作自身就有很大消耗。而且不是每一次 count+1 时都有并发发生，无并发发生时的加锁并无必要。直接用 synchronized 进行同步，效率并不高。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">下面我们看看怎么用 AtomicInteger 解决这个问题。使用 AtomicInteger 很简单，我们在声明 count 的时候，将其声明为 AtomicInteger 即可，然后把 count=count+1 的语句改为 count.incrementAndGet ()。问题就完美解决了。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">接下来我们看看 Atomic 实现原子操作的原理。我们首先看看 AtomicInteger 的 incrementAndGet 方法注释：</p>
</div><div class="cl-preview-section"><pre class=" language-java"><code class="prism  language-java"><span class="token comment">/**
 * Atomically increments by one the current value.
 *
 * @return the updated value
 */</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">可以看到此方法以原子操作在当前 value 上加 1。count=count+1 这行语句其实隐含了两步操作，第一步取得 count 的值，第二步为 count 加 1 。而在这两步操作中间，count 的值可能已经改变了。而 AtomicInteger 提供的 incrementAndGet () 方法，则把这两步操作作为一个原子性操作来完成，则不会出现线程安全问题。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">Atomic 变量的操作是如何保证原子性的呢？其实是使用了 CAS 算法。</p>
</div><div class="cl-preview-section"><h2 id="cas算法分析" style="font-size: 30px;">2. CAS 算法分析</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">CAS 是 Compare and swap 的缩写，翻译过来就是比较替换。其实 CAS 是乐观锁的一种实现。而 Synchronized 则是悲观锁。这里的乐观和悲观指的是当前线程对是否有并发的判断。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">悲观锁–认为每一次自己的操作大概率会有其它线程在并发，所以自己在操作前都要对资源进行锁定，这种锁定是排他的。悲观锁的缺点是不但把多线程并行转化为了串行，而且加锁和释放锁都会有额外的开支。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">乐观锁–认为每一次操作时大概率不会有其它线程并发，所以操作时并不加锁，而是在对数据操作时比较数据的版本，和自己更新前取得的版本一致才进行更新。乐观锁省掉了加锁、释放锁的资源消耗，而且在并发量并不是很大的时候，很少会发生版本不一致的情况，此时乐观锁效率会更高。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">Atomic 变量在做原子性操作时，会从内存中取得要被更新的变量值，并且和你期望的值进行比较，期望的值则是你要更新操作的值。如果两个值相等，那么说明没有其它线程对其更新，本线程可以继续执行。如果不等，说明有线程已经先于此线程进行了更新操作。那么则继续取得该变量的最新值，重复之前的逻辑，直至操作成功。这保证了每个线程对 Atomic 变量操作是线程安全的。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这里举个例子，我们每天都会向代码库提交代码，不知道你是否遇到过如下场景。你发现代码中有个 bug，只需要修改一行代码就可以修复，于是你先 pull，改好这行代码后立刻 push，但是 git 告诉你由于落后远程代码库的版本，push 失败了。很不巧，就在你 pull 和 push 之间这短短的几秒钟，有其它开发 push 了代码。那你只能再次 pull，和你这次修改做合并，然后再次 push。仔细想想，这不就是 CAS 吗？只不过除了数据提交前的版本比较 git 帮你做外，pull、merge、push 需要你手动执行。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><img class="" src="https://img.mukewang.com/5da542f300018f5810210623.jpg" data-original="//img.mukewang.com/5da542f300018f5810210623.jpg" alt="图片描述"></p>
</div><div class="cl-preview-section"><h2 id="atomic源代码分析" style="font-size: 30px;">3. Atomic 源代码分析</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">下面我们看看 AtomicInteger 的源代码。首先，AtomicInteger 中有 3 个重要的成员变量：</p>
</div><div class="cl-preview-section"><pre><code>private static final Unsafe unsafe = Unsafe.getUnsafe();
private static final long valueOffset;
private volatile int value;
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">第一个 Unsafe 对象，Atomic 中的原子操作都是借助 unsafe 对象所实现的；</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">第二个是 AtomicInteger 包装的变量在内存中的地址；</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">第三个是 AtomicInteger 包装的变量值，并且用 volatile 修饰，以确保变量的变化能被其它线程看到。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">其实 valueOffset 就是 value 的内存地址。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">AtomicInteger 中有一段静态代码块如下：</p>
</div><div class="cl-preview-section"><pre class=" language-java"><code class="prism  language-java"><span class="token keyword">static</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        valueOffset <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">objectFieldOffset</span>
            <span class="token punctuation">(</span>AtomicInteger<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这段代码中 unsafe 对象获取了 AtomicInteger 类中 value 这个字段的 offset。unsafe.objectFieldOffset ()  是一个 native 的方法。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">AtomicInteger 有一个构造函数如下：</p>
</div><div class="cl-preview-section"><pre class=" language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token function">AtomicInteger</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    value <span class="token operator">=</span> initialValue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">可以看到对它所包装的 int 变量 value 进行了赋值。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">通过以上分析，我们来总结一下目前对 AtomicInteger 的了解：</p>
</div><div class="cl-preview-section"><ol>
<li style="font-size: 20px; line-height: 38px;">AtomicInteger 对象包装了通过构造函数传入的一个初始 int 值；</li>
<li style="font-size: 20px; line-height: 38px;">AtomicInteger 持有这个 int 变量的内存地址；</li>
<li style="font-size: 20px; line-height: 38px;">AtomicInteger 还有一个用来做原子性操作的 unsafe 对象。</li>
</ol>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">接下来我们以文章前面提到的 incrementAndGet 方法为例，来看看 Atomic 原子性的实现。代码如下：</p>
</div><div class="cl-preview-section"><pre class=" language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">代码很简单，调用了 <em>unsafe</em>.getAndAddInt(this, <em>valueOffset</em>, 1) 后，对其返回 +1，然后 return。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">那么原子性实现的秘密就全在 <em>unsafe</em>.getAndAddInt () 这个方法中了。随便翻看一下 AtomicInteger 的源代码，这个方法被各种调用，其实我们搞清楚 <em>unsafe</em>.getAndAddInt () 的实现，谜底也就揭晓了。我们继续看 <em>unsafe</em>.getAndAddInt () 的实现：</p>
</div><div class="cl-preview-section"><pre class=" language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndAddInt</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span> <span class="token keyword">long</span> valueOffset<span class="token punctuation">,</span> <span class="token keyword">int</span> var<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> expect<span class="token punctuation">;</span>
        <span class="token comment">// 利用循环，直到更新成功才跳出循环。</span>
        <span class="token keyword">do</span> <span class="token punctuation">{</span>
            <span class="token comment">// 获取value的最新值</span>
            expect <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getIntVolatile</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> valueOffset<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// expect + var表示需要更新的值，如果compareAndSwapInt返回false，说明value值被其他线程更改了。</span>
            <span class="token comment">// 那么就循环重试，再次获取value最新值expect，然后再计算需要更新的值expect + var。直到更新成功</span>
        <span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> expect<span class="token punctuation">,</span> expect <span class="token operator">+</span> var<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 返回当前线程在更改value成功后的，value变量原先值。并不是更改后的值</span>
        <span class="token keyword">return</span> expect<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">为了帮助理解，我加了一些注释。三个入参，第一个 obj 传入的是 AtomicInteger 对象自己，第二个是 value 变量的内存地址，第三个则是要增加的值。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">程序体中是一个循环，循环中通过 AtomicInteger 对象和 value 属性的 offset，取得到当前的 value 值，接下来调用 this.compareAndSwapInt (obj, valueOffset, expect, expect + var)。这个方法名仔细看下，是不是很熟悉？是的，就是 CAS。调用前我们已经获取到了期望值，所以在这个方法中会把期望值和你要替换掉的值做比较，如果一直则替换，否则重复 while 循环，也就是再此获取最新的期望值，然后再比较替换，直至替换成功。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">你现在一定很好奇 compareAndSwapInt 的方法是如何实现的。我们点开此方法后，可以看到是一个 native 方法，native 方法使用 C 语言编写。由于 JDK 并未开源，我们只能下载开源版本的 OpenJDK。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">可以看到在 compareAndSwapInt 源代码的最后，调用了 Atomic::cmpxchg (x,addr,e)。这个方法在不同的平台会有不同的实现。不过总的思想如下：</p>
</div><div class="cl-preview-section"><ol>
<li style="font-size: 20px; line-height: 38px;">判断当前系统是否为多核处理器；</li>
<li style="font-size: 20px; line-height: 38px;">执行 CPU 指令 cmpxchg，如果为多核则在 cmpxchg 加 lock 前缀。</li>
</ol>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">可以看到最终是通过 CPU 指令 cmpxchg 来实现比较交换。那么 Lock 前缀起到什么作用呢？加了 Lock 前缀的操作，在执行期间，所使用的缓存会被锁定，其他处理器无法读写该指令要访问的内存区域，由此保证了比较替换的原子性。而这个操作过程称之为缓存锁定。</p>
</div><div class="cl-preview-section"><h2 id="cas的缺点" style="font-size: 30px;">4. CAS 的缺点</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">CAS 最终通过 CPU 指令实现，把无谓的同步消耗降到最低，但是没有银弹，CAS 也有着几个致命的缺点：</p>
</div><div class="cl-preview-section"><ol>
<li style="font-size: 20px; line-height: 38px;">比较替换如果失败，则会一直循环，直至成功。这在并发量很大的情况下对 CPU 的消耗将会非常大；</li>
<li style="font-size: 20px; line-height: 38px;">只能保证一个变量自身操作的原子性，但多个变量操作要实现原子性，是无法实现的；</li>
<li style="font-size: 20px; line-height: 38px;">ABA 问题。</li>
</ol>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">前两个问题比较简单，我们重点看一下第三个 ABA 问题。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">假如本线程更新前取得期望值为 A，和更新操作之间的这段时间内，其它线程可能把 value 改为了 B 又改回了 A。 而本线程更新时发现 value 和期望值一样还是 A，认为其没有变化，则执行了更新操作。但其实此时的 A 已经不是彼时的 A 了。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">大多数情况下 ABA 不会造成业务上的问题。但是如果你认为 ABA 问题对你的程序业务有问题，那么就需要解决。 JDK 提供了 AtomicStampedReference 类，通过对 Atomic 包装的变量增加版本号，来解决 ABA 问题，即使 value 还是 A，但如果版本变化了，也认为比较失败。</p>
</div><div class="cl-preview-section"><h2 id="总结" style="font-size: 30px;">5. 总结</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">本节我们学习了轻量级的原子性实现–Atomic。并且以 AtomicInteger 为例进行了源代码的讲解，Atomic 的类很多，但是大同小异，感兴趣的话，可以自己读一下其它 Atomic 类的源代码。本节最后介绍了 CAS，一定要深入理解，这也是面试中经常会问到的问题之一。我们经过本节的学习，了解了 Atomic 的优点，也知道了它的局限性。在以后的多线程开发中，可以有选择的使用 Atomic 变量，以使程序达到更好的效率。</p>
</div>}
                        </div>
                    </div>
                                            <!-- 买过的阅读 -->
                        <div class="art-next-prev clearfix">
                                                                                                <!-- 已买且开放 或者可以试读 -->
                                    <a href="/read/49/article/949">
                                                                    <div class="prev l clearfix">
                                        <div class="icon l">
                                            <i class="imv2-arrow3_l"></i>
                                        </div>
                                        <p>
                                            14 僵持不下—死锁详解
                                        </p>
                                    </div>
                                </a>
                                                                                                                            <!-- 已买且开放 或者可以试读 -->
                                    <a href="/read/49/article/951">
                                                                    <div class="next r clearfix">
                                        <p>
                                            16 让你眼见为实—volatile详解
                                        </p>
                                        <div class="icon r">
                                            <i class="imv2-arrow3_r"></i>
                                        </div>

                                    </div>
                                </a>
                                                    </div>
                                    </div>
                <div class="comments-con js-comments-con" id="coments_con">
                </div>

                
            </div>
            
            
            

        </div>
    </div>
</div>

<div class="modal modal-jiaQun-new hide" id="modal-jiaQun">
    <div class="inner" style="">
        <div class="modal-close js-close-jiaQun">
            <i class="imv2-close"></i>
        </div>
        <div class="content">
            <img src="https://img1.mukewang.com/5d762b3c000119e505400602.jpg">
            <div class="right-info">
                <div class="title">
                    扫码加入慕课Java核心用户群
                </div>
                <div class="desc">
                                            <p class="mb6">验证信息：<span id="joincode">1910221525494047</span><span class="copy js-copy-joincode">复制</span></p>
                                        <p class="mb6">QQ讨论群号：906691736</p>
                                            <p>QQ群URL：<a href="https://jq.qq.com/?_wv=1027&amp;k=55RtSbJ" target="_blank">点击访问</a></p>
                                    </div>
            </div>
            <p class="tip">若遇到搜索不到QQ群或加群失败，请联系客服邮箱:kf@imooc.com</p>
        </div>
    </div>
</div>
 
<!-- 专栏介绍页专栏评价 -->

<!-- 专栏介绍页底部三条评价 -->

<!-- 专栏阅读页弹层目录和介绍页页面目录 -->

<!-- 专栏阅读页发布回复 -->

<!-- 专栏阅读页发布评论 -->

<!-- 专栏阅读页底部评论 -->

<!-- 专栏阅读 单个 评论 -->

<!-- 新增回复和展开三条以外回复 -->

<!-- 立即订阅的弹窗 -->












</div></body></html>