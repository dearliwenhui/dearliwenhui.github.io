<html><head><meta charset="utf-8"><title>31 凭票取餐—Future模式详解-慕课专栏</title>
			<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
			<meta name="renderer" content="webkit">
			<meta property="qc:admins" content="77103107776157736375">
			<meta property="wb:webmaster" content="c4f857219bfae3cb">
			<meta http-equiv="Access-Control-Allow-Origin" content="*">
			<meta http-equiv="Cache-Control" content="no-transform ">
			<meta http-equiv="Cache-Control" content="no-siteapp">
			<link rel="apple-touch-icon" sizes="76x76" href="https://www.imooc.com/static/img/common/touch-icon-ipad.png">
			<link rel="apple-touch-icon" sizes="120x120" href="https://www.imooc.com/static/img/common/touch-icon-iphone-retina.png">
			<link rel="apple-touch-icon" sizes="152x152" href="https://www.imooc.com/static/img/common/touch-icon-ipad-retina.png">
			<link href="https://moco.imooc.com/captcha/style/captcha.min.css" rel="stylesheet">
			<link rel="stylesheet" href="https://www.imooc.com/static/moco/v1.0/dist/css/moco.min.css?t=201907021539" type="text/css">
			<link rel="stylesheet" href="https://www.imooc.com/static/lib/swiper/swiper-3.4.2.min.css?t=201907021539">
			<link rel="stylesheet" href="../zhuanlanChapter-less.css?v=201907051055" type="text/css">
			<link charset="utf-8" rel="stylesheet" href="https://www.imooc.com/static/lib/ueditor/themes/imooc/css/ueditor.css?v=201907021539"><link rel="stylesheet" href="https://www.imooc.com/static/lib/baiduShare/api/css/share_style0_16.css?v=6aba13f0.css"></head>
			<body><div id="main">


<div class="main-con hide-menu">
    <!-- 左侧菜单 & 索引 -->
    
    <div class="right-content" style="padding-left: 0px;">
        <div class="container clearfix" id="top" style="width: 1134px; display: block;">
            
            
            <div class="center_con js-center_con l" style="width: 1134px;">
                <div class="article-con">
                                            <!-- 买过的阅读 -->
                        

                    
                    <div class="art-title" style="margin-top: 0px;">
                        31 凭票取餐—Future模式详解
                    </div>
                    <div class="art-info clearfix">
                        
                        <span class="l">
                            更新时间：2019-12-12 09:40:27
                        </span>
                    </div>
                    <div class="art-top">
                                                <img src="https://img4.mukewang.com/5de861070001eafb06400359.jpg" alt="">
                                                                        <div class="famous-word-box">
                            <img src="https://www.imooc.com/static/img/column/bg-l.png" alt="" class="bg1 bg">
                            <img src="https://www.imooc.com/static/img/column/bg-r.png" alt="" class="bg2 bg">
                            <div class="famous-word">与有肝胆人共事，从无字句处读书。<p class="author">——周恩来</p></div>
                        </div>
                                            </div>
                    <div class="art-content js-lookimg">
                        <div id="article_content">
                            <div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">从本节开始，我们进入新的一章学习，同时也是最后一章的学习。我们从如何实现一个线程开始学起，学习了并发的问题和解决办法，学习了线程池等工具的使用，学习了各种并发容器。本章将会讲解实际开发中经常会用到的多线程设计模式及其在 JDK 中的实现和应用。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">本节我们要学习的是 Future 模式。我们先来看一个例子，假如你中午要出去买一份午餐打包带回家，并且要去超市买一管牙膏，应该怎么做才会时间最短？当然是点好外卖，然后去超市买牙膏，等你回来看外卖是否已经做好了，如果做好了，拿小票取餐。如果还没好，那就继续等待，等做好后取餐回家。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">如果程序不使用多线程实现的话，那么主线程就会阻塞在外卖加工过程上，直到午餐做好，才能去超市买东西。但如果我们采用多线程，可以点餐后马上去超市买牙膏，同时有新的线程加工你的午餐。今天我们来学习一种新的多线程应用模式 Future，解决起类似问题就容易多了。</p>
</div><div class="cl-preview-section"><h2 id="、future模式介绍" style="font-size: 30px;">1、Future 模式介绍</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">我们先不着急讲解 Future，先来回顾下之前我们讲解的 Thread 和 runnable，实现多线程的方式是新起线程运行 run 方法，但是 run 方法有个缺陷是没有返回值，并且主线程也并不知道新的线程何时运行完毕。上文的例子，我们不但需要做饭的线程返回午餐，并且主线程需要知道午餐已经好了。使用我们之前学习知识，通过 wait、notify 和共享资源也可以实现，但会比较复杂。其实 JDK 提供了非常方便的工具就是 Future。Future 持有要运行的任务，以及任务的结果。主线程只要声明了 Future 对象，并且启动新的线程运行他。那么随时能通过 Future 对象获取另外线程运行的结果。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">接下来我们看看 Future 如何实现例子中的场景。</p>
</div><div class="cl-preview-section"><h2 id="、future-使用" style="font-size: 30px;">2、Future 使用</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">上述例子的代码如下：</p>
</div><div class="cl-preview-section"><pre class=" language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ExecutionException<span class="token punctuation">,</span> InterruptedException <span class="token punctuation">{</span>
        
      FutureTask<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span> cookTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>String<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> String <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token string">"5斤的龙虾"</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        Long startTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我点了5斤的龙虾。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>cookTask<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我去买牙膏。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我买到牙膏了！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      
        String lunch <span class="token operator">=</span> cookTask<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我点的"</span><span class="token operator">+</span>lunch<span class="token operator">+</span><span class="token string">"已经OK了！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        Long userTime <span class="token operator">=</span> <span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startTime<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">1000</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我一共用了"</span><span class="token operator">+</span>userTime<span class="token operator">+</span><span class="token string">"秒买午餐并且买牙膏。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">代码中先了一个 FutureTask 对象，称之为 cookTask。顾名思义，这个 task 是用来做饭的。可以看到构造方法中传入 Callable 的实现。实现的 call 方法中模拟做饭用了 3 秒钟。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">主线程运行后，先点了 5 斤的龙虾，然后一个新的线程就开始去执行 cookTask 了。等会儿，到这里你一定会问，Thread 构造方法需要传入 Runnable 的实现啊？没错，FutureTask 实现了 Runnable 接口。FutureTask 的 run 方法实际执行的是 Callable 的 call 方法。那么新的线程 start 后，实际做饭的逻辑会被执行：自线程 sleep3 秒后返回 “5 斤的龙虾”。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">主线程在启动做饭的自线程后继续向下执行，去买牙膏。这里 sleep 两秒，模拟买牙膏的时间消耗。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">买到牙膏接下来的一行代码 String lobster = cookTask.get (); 重点说一下，此时分两种情况：</p>
</div><div class="cl-preview-section"><ol>
<li style="font-size: 20px; line-height: 38px;">cookTask 运行的线程已经结束了，那么可以直接取到运行的结果赋值给 lunch；</li>
<li style="font-size: 20px; line-height: 38px;">cookTask 运行的线程还没有执行结束，此时主线程会阻塞，直到能取得运行结果。</li>
</ol>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">cookTask 就是你的购物小票，只要你没弄丢，随时能去取你的午饭。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">程序最后计算了整个过程的执行时间。由于采用了多线程并发，所以执行时间应该等于耗时最长的那个任务。这个例子中做龙虾 3 秒 &gt; 买牙膏 2 秒，所以总共耗时 3 秒，输出如下：</p>
</div><div class="cl-preview-section"><pre><code>我点了5斤的龙虾
我去买牙膏
我买到牙膏了！
我点的5斤的龙虾已经OK了
我一共用了3秒买午餐并且买牙膏
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">加入我调整买牙膏需要 10 秒，那么输出则如下：</p>
</div><div class="cl-preview-section"><pre><code>我点了5斤的龙虾
我去买牙膏
我买到牙膏了！
我点的5斤的龙虾已经OK了
我一共用了10秒买午餐并且买牙膏
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">总共耗时 10 秒。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">现在我们想一下，假如单线程串行执行，点完午餐必须等待午餐做好了，才能去买牙膏。那么永远耗时都是 2 者之和。采用并发执行后，仅为时间较长的那个任务的时间。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">由于我们调用 Future 的 get 方法后主线程就开始阻塞了，所以我们应该在真正需要使用 Future 对象的返回结果时才去调用，充分利用并发的特性来提升程序性能。</p>
</div><div class="cl-preview-section"><h2 id="、future源码解析" style="font-size: 30px;">3、Future 源码解析</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">Future 是一个接口，而 FutrueTask 则是他的实现，我们看一下它们的继承关系：</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><img class="" src="https://img.mukewang.com/5def17ec000191fa04410287.jpg" data-original="//img.mukewang.com/5def17ec000191fa04410287.jpg" alt="图片描述"><br>
FutureTask 不但实现了 Future 而且实现了 Runnable 接口。这也是为什么它能作为参数传入 Thread 构造方法。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">Runnable 接口我们讲过，里面只有一个 run 方法，用于被 Thread 调用。我们看一下 Future 接口有哪些方法：<br>
<img class="" src="https://img.mukewang.com/5def17e20001e9cf02900141.jpg" data-original="//img.mukewang.com/5def17e20001e9cf02900141.jpg" alt="图片描述"></p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">cancel 用于尝试取消任务。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">get 用于等待并获取任务执行结果。带时间参数的 get 方法只会等待指定时间长度。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">isCancelled 返回任务在完成前是否已经被取消。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">isDone 返回任务是否完成。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">我们用到最多的就是 get 方法，获取任务的执行结果。</p>
</div><div class="cl-preview-section"><h3 id="futuretask构造方法">3.1 FutureTask 构造方法</h3>
</div><div class="cl-preview-section"><pre class=" language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token function">FutureTask</span><span class="token punctuation">(</span>Callable<span class="token operator">&lt;</span>V<span class="token operator">&gt;</span> callable<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>callable <span class="token operator">==</span> null<span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>callable <span class="token operator">=</span> callable<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> NEW<span class="token punctuation">;</span>       <span class="token comment">// ensure visibility of callable</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">需要传入 Callable 的实现，Callable 是一个接口，定义了 call 方法，返回 V 类型。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">然后定义了 FutureTask 的状态为 NEW。FutrueTask 定义了如下状态：</p>
</div><div class="cl-preview-section"><pre class=" language-java"><code class="prism  language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> NEW          <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> COMPLETING   <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> NORMAL       <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> EXCEPTIONAL  <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CANCELLED    <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> INTERRUPTING <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> INTERRUPTED  <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">通过字面我们很容易理解其含义。</p>
</div><div class="cl-preview-section"><h3 id="run方法解析">3.2 run 方法解析</h3>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">FutrueTask 实现了 Runnbale 接口，所以 Thread 运行后实际上执行的是 FutrueTask 的 run 方法。我们要想了解 Future 的实现原理，那么就应该从它的 run 方法开始入手。</p>
</div><div class="cl-preview-section"><pre class=" language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//如果此时状态不为NEW直接结束</span>
  <span class="token comment">//如果为NEW，但是CAS操作把本线程写入为runner时，发现runner已经不为null，那么也直接结束</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">!=</span> NEW <span class="token operator">||</span>
        <span class="token operator">!</span>UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> runnerOffset<span class="token punctuation">,</span>
                                     null<span class="token punctuation">,</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
      <span class="token comment">//取得Callable对象</span>
        Callable<span class="token operator">&lt;</span>V<span class="token operator">&gt;</span> c <span class="token operator">=</span> callable<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> state <span class="token operator">==</span> NEW<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            V result<span class="token punctuation">;</span>
            <span class="token keyword">boolean</span> ran<span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
              <span class="token comment">//运行Callable对象的call方法，并且取得返回值。</span>
                result <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                ran <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                result <span class="token operator">=</span> null<span class="token punctuation">;</span>
                ran <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token function">setException</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
          <span class="token comment">//如果call方法成功执行结束，那么把执行结果设置给成员变量outcome;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>ran<span class="token punctuation">)</span>
                <span class="token function">set</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token comment">// runner must be non-null until state is settled to</span>
        <span class="token comment">// prevent concurrent calls to run()</span>
        runner <span class="token operator">=</span> null<span class="token punctuation">;</span>
        <span class="token comment">// state must be re-read after nulling runner to prevent</span>
        <span class="token comment">// leaked interrupts</span>
        <span class="token keyword">int</span> s <span class="token operator">=</span> state<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">&gt;=</span> INTERRUPTING<span class="token punctuation">)</span>
            <span class="token function">handlePossibleCancellationInterrupt</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">核心逻辑就是执行运行 Callable 对象的 call 方法，把返回结果写入 outcome。outcome 用来保存计算结果。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">保存计算结果则是通过 set 方法。</p>
</div><div class="cl-preview-section"><h3 id="set-方法解析">3.3 set 方法解析</h3>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">set 方法代码如下：</p>
</div><div class="cl-preview-section"><pre class=" language-java"><code class="prism  language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>V v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  	<span class="token comment">//状态还是NEW，保存计算结果给outcome</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> stateOffset<span class="token punctuation">,</span> NEW<span class="token punctuation">,</span> COMPLETING<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        outcome <span class="token operator">=</span> v<span class="token punctuation">;</span>
      <span class="token comment">//更新状态为NORMAL</span>
        UNSAFE<span class="token punctuation">.</span><span class="token function">putOrderedInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> stateOffset<span class="token punctuation">,</span> NORMAL<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// final state</span>
      <span class="token comment">//唤醒等待的线程</span>
        <span class="token function">finishCompletion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">如果没有被取消则会保存计算结果 v 到 outcome。然后更新最终状态为 NORMAL。最后调用 finishCompletion 方法唤醒阻塞的线程。代码如下：</p>
</div><div class="cl-preview-section"><pre class=" language-java"><code class="prism  language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">finishCompletion</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// assert state &gt; COMPLETING;</span>
  <span class="token comment">//遍历等待线程，结束等待</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>WaitNode q<span class="token punctuation">;</span> <span class="token punctuation">(</span>q <span class="token operator">=</span> waiters<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> waitersOffset<span class="token punctuation">,</span> q<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token comment">//结束等待线程的挂起</span>
                Thread t <span class="token operator">=</span> q<span class="token punctuation">.</span>thread<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    q<span class="token punctuation">.</span>thread <span class="token operator">=</span> null<span class="token punctuation">;</span>
                    LockSupport<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
              <span class="token comment">//如果没有下一个等待线程，那么结束循环</span>
                WaitNode next <span class="token operator">=</span> q<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                q<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment">// unlink to help gc</span>
                q <span class="token operator">=</span> next<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
		<span class="token comment">//全部完成后回调FutrueTask的done方法。done方法为空，可以由子类实现。</span>
    <span class="token function">done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//清除callable</span>
    callable <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment">// to reduce footprint</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><h3 id="get-方法解析">3.4 get 方法解析</h3>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">get 方法用于获取任务的返回值，如果还没有执行完成，则会阻塞，代码如下：</p>
</div><div class="cl-preview-section"><pre class=" language-java"><code class="prism  language-java"><span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span> ExecutionException <span class="token punctuation">{</span>
    <span class="token comment">//获取当前Task的状态</span>
  	<span class="token keyword">int</span> s <span class="token operator">=</span> state<span class="token punctuation">;</span>
    <span class="token comment">//如果还没有完成，则阻塞等待完成</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">&lt;=</span> COMPLETING<span class="token punctuation">)</span>
        s <span class="token operator">=</span> <span class="token function">awaitDone</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> 0L<span class="token punctuation">)</span><span class="token punctuation">;</span>
  	<span class="token comment">//获取任务执行的返回结果</span>
    <span class="token keyword">return</span> <span class="token function">report</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">我们先来看 awaitDone 的代码：</p>
</div><div class="cl-preview-section"><pre class=" language-java"><code class="prism  language-java"><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">awaitDone</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> timed<span class="token punctuation">,</span> <span class="token keyword">long</span> nanos<span class="token punctuation">)</span>
    <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
  <span class="token comment">//计算等待截止时长</span>
    <span class="token keyword">final</span> <span class="token keyword">long</span> deadline <span class="token operator">=</span> timed <span class="token operator">?</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> nanos <span class="token operator">:</span> 0L<span class="token punctuation">;</span>
    WaitNode q <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> queued <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">//当前线程如果被打断，则不再等待。从等待链表中移除</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">removeWaiter</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
			<span class="token comment">//取得目前的状态</span>
        <span class="token keyword">int</span> s <span class="token operator">=</span> state<span class="token punctuation">;</span>
      <span class="token comment">//如果已经执行完成，清空q节点保存的线程</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">&gt;</span> COMPLETING<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> null<span class="token punctuation">)</span>
                q<span class="token punctuation">.</span>thread <span class="token operator">=</span> null<span class="token punctuation">;</span>
            <span class="token keyword">return</span> s<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token comment">//如果正在执行，让出CPU执行权</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> COMPLETING<span class="token punctuation">)</span> <span class="token comment">// cannot time out yet</span>
            Thread<span class="token punctuation">.</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">//没有进入以上分支，运行到此分支，这说明此线程确实需要开始等待了，</span>
      <span class="token comment">//那么如果还未为此线程建立关联的等待节点，则进行创建。</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">==</span> null<span class="token punctuation">)</span>
            q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WaitNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">//通过CAS把此线程的等待node加入到连表中。失败的话，下次循环若能运行到此分支，会继续添加。</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>queued<span class="token punctuation">)</span>
            queued <span class="token operator">=</span> UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> waitersOffset<span class="token punctuation">,</span>
                                                 q<span class="token punctuation">.</span>next <span class="token operator">=</span> waiters<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">//如果设置了超时，检查是否超时。超时的话结束等待。 否则挂起超时时长</span>
      <span class="token comment">//如果没有设置超时时长，则永久挂起</span>
      <span class="token comment">//回到上面的finishCompletion方法，等到task执行完成后会执行LockSupport.unpark(t)，结束阻塞。</span>
      <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>timed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            nanos <span class="token operator">=</span> deadline <span class="token operator">-</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&lt;=</span> 0L<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">removeWaiter</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> state<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            LockSupport<span class="token punctuation">.</span><span class="token function">parkNanos</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span>
            LockSupport<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">最后我们看一下 report 方法：</p>
</div><div class="cl-preview-section"><pre class=" language-java"><code class="prism  language-java"><span class="token keyword">private</span> V <span class="token function">report</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token keyword">throws</span> ExecutionException <span class="token punctuation">{</span>
  <span class="token comment">//获取执行结果</span>
    Object x <span class="token operator">=</span> outcome<span class="token punctuation">;</span>
  <span class="token comment">//NORMAL为正常结束，那么直接把X转型后返回</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> NORMAL<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>V<span class="token punctuation">)</span>x<span class="token punctuation">;</span>
  <span class="token comment">//如果任务被取消了，则抛出异常</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">&gt;=</span> CANCELLED<span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">CancellationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Throwable<span class="token punctuation">)</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">outcome 保存的就是任务的执行结果。根据此时的状态，选择返回执行结果还是抛出取消的异常。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">最后我们总结下 FutureTask 的代码：</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">1、FutureTask 实现 Runnable 和 Future 接口；</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">2、在线程上运行 FutureTask 后，run 方法被调用，run 方法会调用传入的 Callable 接口的 call 方法；</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">3、拿到返回值后，通过 set 方法保存结果到 outcome，并且唤醒所有等待的线程；</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">4、调用 get 方法获取执行结果时，如果没有执行完毕，则进入等待，直到 set 方法调用后被唤醒。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">下图示意了两个线程运行 task 和 get 时的程序逻辑：<br>
<img class="" src="https://img.mukewang.com/5def17cf0001e90b11350434.jpg" data-original="//img.mukewang.com/5def17cf0001e90b11350434.jpg" alt="图片描述"></p>
</div><div class="cl-preview-section"><h2 id="、总结" style="font-size: 30px;">4、总结</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">Future 模式在实际开发中有着大量的应用场景。比如说微服务架构中，需要调用不同服务接口获取数据，但是接口调用间并无依赖关系，那么可以通过 FutureTask 并发调用，然后再执行后续逻辑。如果我们采用串行的方式，则需要一个接口返回后，再调用下一个接口。FutreTask 需要结合 Callable 接口使用，示例代码中为了让大家显示的看到 Callable 接口，所以采用匿名对象的方式。实际使用中我们可以使用 lambda 表达式来简化代码，如下：</p>
</div><div class="cl-preview-section"><pre class=" language-java"><code class="prism  language-java">FutureTask<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span> cookTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token string">"5斤的龙虾"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
</div>}
                        </div>
                    </div>
                                            <!-- 买过的阅读 -->
                        <div class="art-next-prev clearfix">
                                                                                                <!-- 已买且开放 或者可以试读 -->
                                    <a href="/read/49/article/964">
                                                                    <div class="prev l clearfix">
                                        <div class="icon l">
                                            <i class="imv2-arrow3_l"></i>
                                        </div>
                                        <p>
                                            30 限量供应，不好意思您来晚了—Semaphore详解
                                        </p>
                                    </div>
                                </a>
                                                                                                                            <!-- 已买且开放 或者可以试读 -->
                                    <a href="/read/49/article/966">
                                                                    <div class="next r clearfix">
                                        <p>
                                            32 请按到场顺序发言—Completion Service详解
                                        </p>
                                        <div class="icon r">
                                            <i class="imv2-arrow3_r"></i>
                                        </div>

                                    </div>
                                </a>
                                                    </div>
                                    </div>
                <div class="comments-con js-comments-con" id="coments_con">
                </div>

                
            </div>
            
            
            

        </div>
    </div>
</div>

<div class="modal modal-jiaQun-new hide" id="modal-jiaQun">
    <div class="inner" style="">
        <div class="modal-close js-close-jiaQun">
            <i class="imv2-close"></i>
        </div>
        <div class="content">
            <img src="https://img3.mukewang.com/5d762b3c000119e505400602.jpg">
            <div class="right-info">
                <div class="title">
                    扫码加入慕课Java核心用户群
                </div>
                <div class="desc">
                                            <p class="mb6">验证信息：<span id="joincode">1910221525494047</span><span class="copy js-copy-joincode">复制</span></p>
                                        <p class="mb6">QQ讨论群号：906691736</p>
                                            <p>QQ群URL：<a href="https://jq.qq.com/?_wv=1027&amp;k=55RtSbJ" target="_blank">点击访问</a></p>
                                    </div>
            </div>
            <p class="tip">若遇到搜索不到QQ群或加群失败，请联系客服邮箱:kf@imooc.com</p>
        </div>
    </div>
</div>
 
<!-- 专栏介绍页专栏评价 -->

<!-- 专栏介绍页底部三条评价 -->

<!-- 专栏阅读页弹层目录和介绍页页面目录 -->

<!-- 专栏阅读页发布回复 -->

<!-- 专栏阅读页发布评论 -->

<!-- 专栏阅读页底部评论 -->

<!-- 专栏阅读 单个 评论 -->

<!-- 新增回复和展开三条以外回复 -->

<!-- 立即订阅的弹窗 -->












</div></body></html>