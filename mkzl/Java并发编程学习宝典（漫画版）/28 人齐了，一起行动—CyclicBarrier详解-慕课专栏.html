<html><head><meta charset="utf-8"><title>28 人齐了，一起行动—CyclicBarrier详解-慕课专栏</title>
			<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
			<meta name="renderer" content="webkit">
			<meta property="qc:admins" content="77103107776157736375">
			<meta property="wb:webmaster" content="c4f857219bfae3cb">
			<meta http-equiv="Access-Control-Allow-Origin" content="*">
			<meta http-equiv="Cache-Control" content="no-transform ">
			<meta http-equiv="Cache-Control" content="no-siteapp">
			<link rel="apple-touch-icon" sizes="76x76" href="https://www.imooc.com/static/img/common/touch-icon-ipad.png">
			<link rel="apple-touch-icon" sizes="120x120" href="https://www.imooc.com/static/img/common/touch-icon-iphone-retina.png">
			<link rel="apple-touch-icon" sizes="152x152" href="https://www.imooc.com/static/img/common/touch-icon-ipad-retina.png">
			<link href="https://moco.imooc.com/captcha/style/captcha.min.css" rel="stylesheet">
			<link rel="stylesheet" href="https://www.imooc.com/static/moco/v1.0/dist/css/moco.min.css?t=201907021539" type="text/css">
			<link rel="stylesheet" href="https://www.imooc.com/static/lib/swiper/swiper-3.4.2.min.css?t=201907021539">
			<link rel="stylesheet" href="../zhuanlanChapter-less.css?v=201907051055" type="text/css">
			<link charset="utf-8" rel="stylesheet" href="https://www.imooc.com/static/lib/ueditor/themes/imooc/css/ueditor.css?v=201907021539"><link rel="stylesheet" href="https://www.imooc.com/static/lib/baiduShare/api/css/share_style0_16.css?v=6aba13f0.css"></head>
			<body><div id="main">


<div class="main-con hide-menu">
    <!-- 左侧菜单 & 索引 -->
    
    <div class="right-content" style="padding-left: 0px;">
        <div class="container clearfix" id="top" style="width: 1134px; display: block;">
            
            
            <div class="center_con js-center_con l" style="width: 1134px;">
                <div class="article-con">
                                            <!-- 买过的阅读 -->
                        

                    
                    <div class="art-title" style="margin-top: 0px;">
                        28 人齐了，一起行动—CyclicBarrier详解
                    </div>
                    <div class="art-info clearfix">
                        
                        <span class="l">
                            更新时间：2019-12-03 09:55:08
                        </span>
                    </div>
                    <div class="art-top">
                                                <img src="https://img4.mukewang.com/5de5bf7b0001f74f06400359.jpg" alt="">
                                                                        <div class="famous-word-box">
                            <img src="https://www.imooc.com/static/img/column/bg-l.png" alt="" class="bg1 bg">
                            <img src="https://www.imooc.com/static/img/column/bg-r.png" alt="" class="bg2 bg">
                            <div class="famous-word">青年是学习智慧的时期，中年是付诸实践的时期。 <p class="author">—— 卢梭</p></div>
                        </div>
                                            </div>
                    <div class="art-content js-lookimg">
                        <div id="article_content">
                            <div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">上一节我们讲解了 CountDownLatch，它的作用是让多个线程完成后，再促使主线程继续向下执行。不过它有一定的局限性，无法被重复使用。本节我们学习的 CyclicBarrier 不会有这个问题。CyclicBarrier 从字面上理解为循环栅栏。栅栏自然起到的就是屏障的作用，阻止线程通过，而循环则是指其可以反复使用。下面我们就先看看如何使用 CyclicBarrier。</p>
</div><div class="cl-preview-section"><h2 id="、cyclicbarrier-的使用" style="font-size: 30px;">1、CyclicBarrier 的使用</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">几年前北京的黑车盛行，西二旗地铁口，大量黑车司机在出口招揽生意：“软件园、软件园！5 块一位！还差最后一位！” 。等你上车，发现其实不是还差一位，而是只有你一位。而司机此时绝对不会发车，而是会等车上坐够 4 个人后才出发，然后下一辆黑车再次坐满 4 人后发车。下面我们就使用 CyclicBarrier 来模拟这个场景。</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        CyclicBarrier cyclicBarrier <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"人满了发车"</span><span class="token punctuation">)</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>

        IntStream<span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>number <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"第 "</span> <span class="token operator">+</span> number <span class="token operator">+</span> <span class="token string">" 乘客上车了！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    cyclicBarrier<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"第 "</span> <span class="token operator">+</span> number <span class="token operator">+</span> <span class="token string">" 乘客出发了！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BrokenBarrierException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">代码中首先声明 cyclicBarrier 对象，构造方法有两个参数，第一个参数是计数器初始值，每有一个线程达成则会减  1 。减到 0 时，触发执行第二个参数传入的 Runnable 实现的 run 方法。我这里使用 lambda 的方式简化代码。如果你不需要这个 Runnable 的任务，那么只需要传入第一个参数即可。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">接下来的代码中，模拟 10 位乘客上车，每次上车后调用  cyclicBarrier.await() 。这里就是屏障点，此时当前线程会阻塞在此处，并且计数器被减  1 。为了输出的效果便于观看，每次新线程启动前先 sleep 一会。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">每当四个乘客完成上车操作，cyclicBarrier 就会触发 “人满了发车” 的操作。而最后两位乘客上车后，由于没有新的乘客上车，计数器不会被减到 0，导致无法越过屏障，所以永远不会发车。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">cyclicBarrier运行的示意图如下：<br>
<img class="" src="https://img.mukewang.com/5dd5fb100001250a16000799.jpg" data-original="//img.mukewang.com/5dd5fb100001250a16000799.jpg" alt="图片描述"></p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">代码运行输出如下：</p>
</div><div class="cl-preview-section"><pre><code>第 1 乘客上车了！
第 2 乘客上车了！
第 3 乘客上车了！
第 4 乘客上车了！
人满了发车
第 4 乘客出发了！
第 1 乘客出发了！
第 2 乘客出发了！
第 3 乘客出发了！
第 5 乘客上车了！
第 6 乘客上车了！
第 7 乘客上车了！
第 8 乘客上车了！
人满了发车
第 8 乘客出发了！
第 5 乘客出发了！
第 7 乘客出发了！
第 6 乘客出发了！
第 9 乘客上车了！
第 10 乘客上车了！
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">可以看到每上车 4 人，才会触发发车，同时每个人的线程才会继续 cyclicBarrier.await() 后面的代码，输出 “第 n 乘客出发了！”</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这个例子也验证了 CyclicBarrier 可以重复使用，每次满 4 人上车，都会触发发车。然后重新开始计数。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">通过这个例子我们了解了 CyclicBarrier 的使用。在这里我们总结下 CyclicBarrier 涉及的几个概念：</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">1、计数器。初始值为构造 CyclicBarrier 传入的第一个参数，每当一个线程到达屏障点，计数器减1；</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">2、屏障点，线程中调用 cyclicBarrier.await() 后，该线程到达屏障点，等待 CyclicBarrier 打开，也就是计数器到 0 ；</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">3、冲出屏障后的任务。首先这个任务可选。不需要的话，在构造 CyclicBarrier 时只需要传入计数器初始值即可。这个任务在计数器到 0时被触发。</p>
</div><div class="cl-preview-section"><h2 id="、cyclicbarrier-原理解析" style="font-size: 30px;">2、CyclicBarrier 原理解析</h2>
</div><div class="cl-preview-section"><h3 id="、--cyclicbarrier-中的属性">2.1、  CyclicBarrier 中的属性</h3>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java"><span class="token comment">/** CyclicBarrier使用的拍他锁*/</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/** barrier被冲破前，线程等待的condition*/</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> Condition trip <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/** barrier被冲破时，需要满足的参与线程数。*/</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> parties<span class="token punctuation">;</span>
<span class="token comment">/* barrier被冲破后执行的方法。*/</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> Runnable barrierCommand<span class="token punctuation">;</span>
<span class="token comment">/** 当其轮次 */</span>
<span class="token keyword">private</span> Generation generation <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Generation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/**
 *目前等待剩余的参与者数量。从 parties倒数到0。每个轮次该值会被重置回parties
 */</span>
<span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">可以看到 CyclicBarrier 内部通过 ReentrantLock 来实现的，而 ReentrantLock 的底层实现还是 AQS。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">parties 在构造函数中被赋值，它的值永远不会变，因为 CyclicBarrier 会被重置复用。而每个轮次真正用来计数的变量是 count。每个轮次结束，count 会被重置为 parties 的值。</p>
</div><div class="cl-preview-section"><h3 id="、-await-方法解析">2.2、 await() 方法解析</h3>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">await 方法的调用，代表调用线程到达了屏障点，这个方法其实调用了 dowait 方法，我们直接分析 dowait 方法，它实现了 CyclicBarrier 的核心功能。</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java"><span class="token comment">/**
 * Main barrier code, covering the various policies.
 */</span>
<span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">dowait</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> timed<span class="token punctuation">,</span> <span class="token keyword">long</span> nanos<span class="token punctuation">)</span>
    <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span> BrokenBarrierException<span class="token punctuation">,</span>
           TimeoutException <span class="token punctuation">{</span>
    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
    <span class="token comment">//对共享资源count，generation操作前，需要先上锁保证线程安全</span>
    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
      	<span class="token comment">//拿到当前轮次对象的引用</span>
        <span class="token keyword">final</span> Generation g <span class="token operator">=</span> generation<span class="token punctuation">;</span>
				<span class="token comment">//如果已经broken，那么抛出异常</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>g<span class="token punctuation">.</span>broken<span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BrokenBarrierException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token comment">//如果被打断，通过breakBarrier方法设置当前轮次为broken状态，通知当前轮次所有等待的线程线程</span>
        <span class="token comment">//并且抛出InterruptedException</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">breakBarrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
				<span class="token comment">//count减1</span>
        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token operator">--</span>count<span class="token punctuation">;</span>
      	<span class="token comment">//如果index为0，那么冲破屏障点</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// tripped</span>
            <span class="token keyword">boolean</span> ranAction <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token comment">//冲破屏障点后，如果CyclicBarrier构造时传入Runnable，则被调用。</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token keyword">final</span> Runnable command <span class="token operator">=</span> barrierCommand<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">!=</span> null<span class="token punctuation">)</span>
                    command<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                ranAction <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token comment">//这个方法中会进行重置，并且通知所有在屏障点阻塞的线程继续执行。</span>
                <span class="token function">nextGeneration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
              	<span class="token comment">//正常情况由于运行了command后ranAction被置为true，并不会执行如下逻辑</span>
              	<span class="token comment">//在command执行期间出了异常才会进入下面的逻辑，认为当前轮次被破坏了</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ranAction<span class="token punctuation">)</span>
                    <span class="token function">breakBarrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

      	<span class="token comment">//开始自旋，直到屏障被冲破，或者interrupted或者超时</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timed<span class="token punctuation">)</span>
                  	<span class="token comment">//阻塞，此时会释放锁，以让其他线程进入await方法中。等待屏障被冲破后，向后执行</span>
                    trip<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&gt;</span> 0L<span class="token punctuation">)</span>
                    nanos <span class="token operator">=</span> trip<span class="token punctuation">.</span><span class="token function">awaitNanos</span><span class="token punctuation">(</span>nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ie<span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token comment">//如果当前线程阻塞被interrupt了，并且本轮次还没有被break，那么修改本轮次状态为broken</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>g <span class="token operator">==</span> generation <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span> g<span class="token punctuation">.</span>broken<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token function">breakBarrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">throw</span> ie<span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
						<span class="token comment">//如果本轮次被破坏，那么抛出异常</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>g<span class="token punctuation">.</span>broken<span class="token punctuation">)</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BrokenBarrierException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">//如果已经成功进入下一轮次，那么返回index</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>g <span class="token operator">!=</span> generation<span class="token punctuation">)</span>
                <span class="token keyword">return</span> index<span class="token punctuation">;</span>
						<span class="token comment">//如果已经超时，那么本轮次被打破</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>timed <span class="token operator">&amp;&amp;</span> nanos <span class="token operator">&lt;=</span> 0L<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">breakBarrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TimeoutException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
      <span class="token comment">//释放锁</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">以上代码分为两大段逻辑，分别是自旋前，和自旋。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><strong>A、自旋前的逻辑，核心逻辑如下：</strong></p>
</div><div class="cl-preview-section"><ol>
<li style="font-size: 20px; line-height: 38px;">计数器 -1；</li>
<li style="font-size: 20px; line-height: 38px;">判断是否计数器到 0；</li>
<li style="font-size: 20px; line-height: 38px;">如果到了，则冲破屏障点，执行传入的 Runnable；</li>
<li style="font-size: 20px; line-height: 38px;">调用 nextGeneration() 来更新 Generation，重置计数器，并且通知本轮次等待的线程。</li>
</ol>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><strong>B、如果计数器没有到 0，则进入自旋的逻辑：</strong></p>
</div><div class="cl-preview-section"><ol>
<li style="font-size: 20px; line-height: 38px;">开始等待，此时会释放锁，以让其它线程进入 lock 的代码块执行以上逻辑；</li>
<li style="font-size: 20px; line-height: 38px;">当被唤醒时，可能因为当前 generation 被 break 了，或者计数器到 0，屏障被冲破；</li>
<li style="font-size: 20px; line-height: 38px;">对比边刚进入 dowait 方法时获取的 generation 对象和最新 generation 是否一致。不一致说明已经换代了，也就是屏障被冲破，可以 return 了；</li>
<li style="font-size: 20px; line-height: 38px;">如果等待超时或者 generation 被 break，分别抛出异常。</li>
</ol>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">不同线程在 A 部分的逻辑会影响已经进入 B 部分逻辑的线程中止自旋。这些自旋的线程或者冲破屏障点，继续向下执行，也可能抛出异常。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">我们再看下用于更新轮次的方法 nextGeneration()：</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">nextGeneration</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// signal completion of last generation</span>
    trip<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// set up next generation</span>
    count <span class="token operator">=</span> parties<span class="token punctuation">;</span>
    generation <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Generation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">三行代码做了三件事：</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">1、通知所有被阻塞在本轮次屏障点的线程。屏障点被冲破，可以继续向下执行了；</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">2、重置计数器为初始值；</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">3、更新轮次对象。这样自旋中的线程才会跳出自旋。</p>
</div><div class="cl-preview-section"><h2 id="、总结" style="font-size: 30px;">3、总结</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">CyclicBarrier 和 CountDownLatch 相比，更为灵活，可以被重复使用。前者可以用来分段任务，假如有个任务需要分三个阶段来完成，每个阶段可以多线程并发执行，但是进入下一个阶段的时候，必须所有线程都完成了第一阶段的执行。那么通过 CyclicBarrier，在每个线程的每个阶段开始前都设置屏障点，可以很轻松地实现。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">CyclicBarrier 的实现是通过 ReentrantLock 控制计数器的原子更新，通过条件变量来实现线程同步。</p>
</div>}
                        </div>
                    </div>
                                            <!-- 买过的阅读 -->
                        <div class="art-next-prev clearfix">
                                                                                                <!-- 已买且开放 或者可以试读 -->
                                    <a href="/read/49/article/961">
                                                                    <div class="prev l clearfix">
                                        <div class="icon l">
                                            <i class="imv2-arrow3_l"></i>
                                        </div>
                                        <p>
                                            27 倒数计时开始，三、二、一—CountDownLatch详解
                                        </p>
                                    </div>
                                </a>
                                                                                                                            <!-- 已买且开放 或者可以试读 -->
                                    <a href="/read/49/article/963">
                                                                    <div class="next r clearfix">
                                        <p>
                                            29 一手交钱，一手交货—Exchanger详解
                                        </p>
                                        <div class="icon r">
                                            <i class="imv2-arrow3_r"></i>
                                        </div>

                                    </div>
                                </a>
                                                    </div>
                                    </div>
                <div class="comments-con js-comments-con" id="coments_con">
                </div>

                
            </div>
            
            
            

        </div>
    </div>
</div>

<div class="modal modal-jiaQun-new hide" id="modal-jiaQun">
    <div class="inner" style="">
        <div class="modal-close js-close-jiaQun">
            <i class="imv2-close"></i>
        </div>
        <div class="content">
            <img src="https://img2.mukewang.com/5d762b3c000119e505400602.jpg">
            <div class="right-info">
                <div class="title">
                    扫码加入慕课Java核心用户群
                </div>
                <div class="desc">
                                            <p class="mb6">验证信息：<span id="joincode">1910221525494047</span><span class="copy js-copy-joincode">复制</span></p>
                                        <p class="mb6">QQ讨论群号：906691736</p>
                                            <p>QQ群URL：<a href="https://jq.qq.com/?_wv=1027&amp;k=55RtSbJ" target="_blank">点击访问</a></p>
                                    </div>
            </div>
            <p class="tip">若遇到搜索不到QQ群或加群失败，请联系客服邮箱:kf@imooc.com</p>
        </div>
    </div>
</div>
 
<!-- 专栏介绍页专栏评价 -->

<!-- 专栏介绍页底部三条评价 -->

<!-- 专栏阅读页弹层目录和介绍页页面目录 -->

<!-- 专栏阅读页发布回复 -->

<!-- 专栏阅读页发布评论 -->

<!-- 专栏阅读页底部评论 -->

<!-- 专栏阅读 单个 评论 -->

<!-- 新增回复和展开三条以外回复 -->

<!-- 立即订阅的弹窗 -->












</div></body></html>