<html><head><meta charset="utf-8"><title>07 深入Thread类—线程API精讲-慕课专栏</title>
			<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
			<meta name="renderer" content="webkit">
			<meta property="qc:admins" content="77103107776157736375">
			<meta property="wb:webmaster" content="c4f857219bfae3cb">
			<meta http-equiv="Access-Control-Allow-Origin" content="*">
			<meta http-equiv="Cache-Control" content="no-transform ">
			<meta http-equiv="Cache-Control" content="no-siteapp">
			<link rel="apple-touch-icon" sizes="76x76" href="https://www.imooc.com/static/img/common/touch-icon-ipad.png">
			<link rel="apple-touch-icon" sizes="120x120" href="https://www.imooc.com/static/img/common/touch-icon-iphone-retina.png">
			<link rel="apple-touch-icon" sizes="152x152" href="https://www.imooc.com/static/img/common/touch-icon-ipad-retina.png">
			<link href="https://moco.imooc.com/captcha/style/captcha.min.css" rel="stylesheet">
			<link rel="stylesheet" href="https://www.imooc.com/static/moco/v1.0/dist/css/moco.min.css?t=201907021539" type="text/css">
			<link rel="stylesheet" href="https://www.imooc.com/static/lib/swiper/swiper-3.4.2.min.css?t=201907021539">
			<link rel="stylesheet" href="https://static.mukewang.com/static/css/??base.css,common/common-less.css?t=2.5,column/zhuanlanChapter-less.css?t=2.5,course/inc/course_tipoff-less.css?t=2.5?v=201907051055" type="text/css">
			<link charset="utf-8" rel="stylesheet" href="https://www.imooc.com/static/lib/ueditor/themes/imooc/css/ueditor.css?v=201907021539"><link rel="stylesheet" href="https://www.imooc.com/static/lib/baiduShare/api/css/share_style0_16.css?v=6aba13f0.css"></head>
			<body><div id="main">


<div class="main-con hide-menu">
    <!-- 左侧菜单 & 索引 -->
    
    <div class="right-content" style="padding-left: 0px;">
        <div class="container clearfix" id="top" style="width: 1134px; display: block;">
            
            
            <div class="center_con js-center_con l" style="width: 1134px;">
                <div class="article-con">
                                            <!-- 买过的阅读 -->
                        

                    
                    <div class="art-title" style="margin-top: 0px;">
                        07 深入Thread类—线程API精讲
                    </div>
                    <div class="art-info clearfix">
                        
                        <span class="l">
                            更新时间：2019-09-25 15:53:08
                        </span>
                    </div>
                    <div class="art-top">
                                                <img src="https://img.mukewang.com/5d762f6f000117b206400359.jpg" alt="">
                                                                        <div class="famous-word-box">
                            <img src="https://www.imooc.com/static/img/column/bg-l.png" alt="" class="bg1 bg">
                            <img src="https://www.imooc.com/static/img/column/bg-r.png" alt="" class="bg2 bg">
                            <div class="famous-word">每个人的生命都是一只小船，理想是小船的风帆。<p class="author">——张海迪</p></div>
                        </div>
                                            </div>
                    <div class="art-content js-lookimg">
                        <div id="article_content">
                            <div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">前面几节我们都在围绕着如何创建 Thread 和 启动 Thread 做分析。上节我们讲解了 Thread 的几种状态，以及状态间的变化。有些状态的变化是被动发生的，比如 run 方法执行完后进入 TERMINATED 状态。不过更多时候，状态的变化是由于主动调用了某些方法。而这些方法大多数是 Thread 类的 API。本小结，我们就来重点学习下 Thread 类暴露出来的 API。</p>
</div><div class="cl-preview-section"><h2 id="sleep-方法" style="font-size: 30px;">sleep 方法</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">顾名思义，线程的 sleep 方法会使线程休眠指定的时间长度。休眠的意思是，当前逻辑执行到此不再继续执行，而是等待指定的时间。但在这段时间内，该线程持有的 monitor 锁（锁在后面会讲解，这里可以认为对共享资源的独占标志）并不会被放弃。我们可以认为线程只是工作到一半休息了一会，但它所占有的资源并不会交还。这样设计很好理解，因为线程在 sleep 的时候可能是处于同步代码块的中间位置，如果此时把锁放弃，就违背了同步的语义。所以 sleep 时并不会放弃锁，等过了 sleep 时长后，可以确保后面的逻辑还在同步执行。<br>
<img class="" src="https://img.mukewang.com/5d7ef1b40001079108400407.jpg" data-original="//img.mukewang.com/5d7ef1b40001079108400407.jpg" alt="图片描述"><br>
sleep 方法有两个重载，分别是：</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token keyword">long</span> millis<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token keyword">long</span> millis<span class="token punctuation">,</span> <span class="token keyword">int</span> nanos<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">两者的区别只是一个支持休眠时间到毫秒级，另外一个到纳秒级。但其实第二个并不能真的精确到纳秒级别，我们来看第二个重载方法代码：</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token keyword">long</span> millis<span class="token punctuation">,</span> <span class="token keyword">int</span> nanos<span class="token punctuation">)</span>
<span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>millis <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"timeout value is negative"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> nanos <span class="token operator">&gt;</span> <span class="token number">999999</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span>
                            <span class="token string">"nanosecond timeout value out of range"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&gt;=</span> <span class="token number">500000</span> <span class="token operator">||</span> <span class="token punctuation">(</span>nanos <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> millis <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        millis<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">sleep</span><span class="token punctuation">(</span>millis<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">可以清楚的看到，最终调用的还是第一个毫秒级别的 sleep 方法。而传入的纳秒会被四舍五入。如果大于 50 万，毫秒 ++，否则纳秒被省略。</p>
</div><div class="cl-preview-section"><h2 id="yield-方法" style="font-size: 30px;">yield 方法</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">yield 方法我们平时并不常用。yield 单词的意思是让路，在多线程中意味着本线程愿意放弃 CPU 资源，也就是可以让出 CPU 资源。不过这只是给 CPU 一个提示，当 CPU 资源并不紧张时，则会无视 yield 提醒。如果 CPU 没有无视 yield 提醒，那么当前 CPU 会从 RUNNING 变为 RUNNABLE 状态，此时其它等待 CPU 的 RUNNABLE 线程，会去竞争 CPU 资源。讲到这里有个问题，刚刚 yield 的线程同为 RUNNABLE 状态，是否也会参与竞争再次获得 CPU 资源呢？经过我大量测试，刚刚 yield 的线程是不会马上参与竞争获得 CPU 资源的。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">我们看下面测试代码：</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">YieldExampleClient</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Thread xiaoming <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"小明--"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//                if (i == 2) {</span>
<span class="token comment">//                    Thread.yield();</span>
<span class="token comment">//                }</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        Thread jianguo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"建国--"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        xiaoming<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        jianguo<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">可以看到启动两个线程打印，控制台输出如下：</p>
</div><div class="cl-preview-section"><pre><code>小明--0
小明--1
小明--2
小明--3
小明--4
小明--5
小明--6
小明--7
小明--8
小明--9
建国--0
建国--1
建国--2
建国--3
建国--4
建国--5
建国--6
建国--7
建国--8
建国--9
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">每次结果有所区别，但是一般都是小明输出到 5 以后，建国才开始输出。这一是因为线程启动需要时间，另外也是因为 CPU 紧张， jianguo 线程在排队。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">我们放开小明线程注解部分，让输出到 xiaoming 线程输出到 2 的时候 yield ，看看会怎么样。输出如下：</p>
</div><div class="cl-preview-section"><pre><code>小明--0
小明--1
小明--2
建国--0
建国--1
......
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">我们看前四行，xiaoming 先获得了 CPU 的使用权，不过在打印到 2 的时候调用了 yield 方法，提示可以让出 CPU 的使用权，而此时 CPU 接受了提示，从而让建国获得了 CPU 的使用权。我尝试建立更多的线程，多次尝试，发现小明打印到 2 的时候，肯定会切换为其它线程打印。不过如果 CPU 资源丰富，那么会无视 yield 方法，xiaoming 也无需让出 CPU 资源。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">yield 方法为了提升线程间的交互，避免某个线程长时间过渡霸占 CPU 资源。但 yield 在实际开发中用的比较少，源码的注解也提到这一点：“<em>It is rarely appropriate to use this method.</em>”。</p>
</div><div class="cl-preview-section"><h2 id="currentthread-方法" style="font-size: 30px;">currentThread 方法</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">我们前几节中已经使用过该方法，这是一个静态方法，用于获取当前线程的实例。用法很简单，如下：</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java">Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">拿到线程的实例后，我们还可以获取 Thread 的 名称：</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java">Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这两个方法在之前例子中我们都使用过，也比较简单，就不再赘述。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">此外我们还可以获取线程 ID ：</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java">Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</div><div class="cl-preview-section"><h2 id="setpriority-方法" style="font-size: 30px;">setPriority 方法</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">此方法用于设置线程的优先级。每个线程都有自己的优先级数值，当 CPU 资源紧张的时候，优先级高的线程获得 CPU 资源的概率会更大。请注意仅仅是概率会更大，并不意味着就一定能够先于优先级低的获取。这和摇车牌号一个道理，我现在中签概率是标准的 9 倍，但摇中依然摇摇无期。而身边却时不时的出现第一次摇号就中的朋友。如果在 CPU 比较空闲的时候，那么优先级就没有用了，人人都有肉吃，不需要摇号了。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">优先级别高可以在大量的执行中有所体现。在大量数据的样本中，优先级高的线程会被选中执行的次数更多。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">最后我们看下 setPriority 的源码：</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setPriority</span><span class="token punctuation">(</span><span class="token keyword">int</span> newPriority<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ThreadGroup g<span class="token punctuation">;</span>
    <span class="token function">checkAccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newPriority <span class="token operator">&gt;</span> MAX_PRIORITY <span class="token operator">||</span> newPriority <span class="token operator">&lt;</span> MIN_PRIORITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>g <span class="token operator">=</span> <span class="token function">getThreadGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>newPriority <span class="token operator">&gt;</span> g<span class="token punctuation">.</span><span class="token function">getMaxPriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            newPriority <span class="token operator">=</span> g<span class="token punctuation">.</span><span class="token function">getMaxPriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">setPriority0</span><span class="token punctuation">(</span>priority <span class="token operator">=</span> newPriority<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">Thread 有自己的最小和最大优先级数值，范围在 1-10。如果不在此范围内，则会报错。另外如果设置的 priority 超过了线程所在组的 priority ，那么只能被设置为组的最高 priority 。最后通过调用 native 方法 setPriority0 进行设置。</p>
</div><div class="cl-preview-section"><h2 id="interrupt-相关方法" style="font-size: 30px;">interrupt 相关方法</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">interrupt 的意思是打断。调用了 interrupt 方法后，线程会怎么样？不知道你的答案是什么。我在第一次学习 interrupt 的时候，第一感觉是让线程中断。其实，并不是这样。inerrupt 方法的作用是让可中断方法，比如让 sleep 中断。也就是说其中断的并不是线程的逻辑，中断的是线程的阻塞。这一点在本小结一开始就要彻底搞清池，否则带着错误的想法会影响学习的效果。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">那么 interrupt 方法调用后，对未使用可中断方法的线程有影响吗？我们做个简单的实验，代码如下：</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InterruptClient</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
        Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">100</span> <span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I'm doing my work"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I'm interrupted?"</span><span class="token operator">+</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">线程 run 方法中没有调用可中断方法，只是输出 <strong>I’m doing my work</strong>，另外还会输出自己的中断状态。而主线程会 sleep 一毫秒，留时间给 thread 线程启动，然后调用 thread 线程的 interrupt 方法。我截取其中关键一段输出如下：</p>
</div><div class="cl-preview-section"><pre><code>I'm doing my work
I'm interrupted?false
I'm doing my work
I'm interrupted?true
I'm doing my work
I'm interrupted?true
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这段后面的输出一直到结束，都在重复 “I’m doing my work I’m interrupted?true“，这说明两个问题：</p>
</div><div class="cl-preview-section"><ol>
<li style="font-size: 20px; line-height: 38px;">调用 interrupt 方法，并不会影响可中断方法之外的逻辑。线程不会中断，会继续执行。这里的中断概念并不是指中断线程；</li>
<li style="font-size: 20px; line-height: 38px;">一旦调用了 interrupt 方法，那么线程的 interrupted 状态会一直为 ture（没有通过调用可中断方法或者其他方式主动清除标识的情况下）；</li>
</ol>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">通过上面实现我们了解了 interrupt 方法中断的不是线程。它中断的其实是可中断方法，如 sleep 。可中断方法被中断后，会把 interrupted 状态归位，改回 false 。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">我们还是做个实验，代码如下：</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InterruptSleepClient</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
        Thread xiaopang <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">100</span> <span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I'm doing my work"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I will sleep"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"My sleeping was interrupted"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I'm interrupted?"</span><span class="token operator">+</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        xiaopang<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        xiaopang<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这次干活的小胖比较懒，每次干完活都要休息一秒钟。有一次被让他干活的老师发现，把他叫醒了。但是后来看他照睡不误，也就随他去了。这段代码执行结果如下：</p>
</div><div class="cl-preview-section"><pre><code>I'm doing my work
I will sleep
My sleeping was interrupted
I'm interrupted? false
I'm doing my work
I will sleep
I'm interrupted? false
I'm doing my work
I will sleep
I'm interrupted? false
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">可以看到当 xiaopang.interrupt () 执行后，睡眠中的 xiaopang 被唤醒了。这里额外需要注意的是，此时 xiaopang 线程的 interrupted 状态还是 false 。因为可中断线程会捕获中断的信号，并且会清除掉 interrupted 标识。因此输出的 “I’m interrupted ?” 全部是 false 。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">最后我们再看一下静态方法 interrupted 。这个方法其实和成员方法 isInterrupted 方法类似，都是返回了 interrupted 状态。不同就是 interrupted 方法返回状态后，如果为 true 则会清除掉状态。而 isInterrupted 则不会。上面第一段测试代码已经验证了这一点，被打断后，调用 isInterrupted 一直返回 true。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">下面我们来验证下 interrupted 是否会清除标识位。把第一段代码稍微改一下：</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InterruptedClient</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
        Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">100</span> <span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I'm doing my work"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//原代码  System.out.println("I'm interrupted?"+Thread.currentThread().isInterrupted());</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I'm interrupted?"</span><span class="token operator">+</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">改动已经在注解中说明，仅仅是改了获取 interrupted 状态的方法。但输出结果却是不一样的：</p>
</div><div class="cl-preview-section"><pre><code>I'm doing my work
I'm interrupted?false
I'm doing my work
I'm interrupted?false
I'm doing my work
I'm interrupted?true
I'm doing my work
I'm interrupted?false
I'm doing my work
I'm interrupted?false
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">可以看到在输出 “I’m interrupted?true” 后，中断状态又变回了 false。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">通过以上讲解，可以看出 interrupt 方法只是设置了中断标识位，这个标识位只对可中断方法会产生作用。不过我们还可以利用它做更多的事情，比如说如果线程的 run 方法中这么写：</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token comment">//do somenting</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这样主线程中可以通过调用此线程的 interrupt 方法，让其推出运行。此时 interrupted 的含义就真的是线程退出了。不过假如你的 while 循环中调用了可中断方法，那么就会有干扰。</p>
</div><div class="cl-preview-section"><h2 id="join-方法" style="font-size: 30px;">join 方法</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">最后我们再讲解一个重要的方法 join。这个方法功能强大，也很实用。我们用它能够实现并行化处理。比如主线程需要做两件没有相互依赖的事情，那么可以起 A、B 两个线程分别去做。通过调用 A、B 的 join 方法，让主线程 block 住，直到 A、B 线程的工作全部完成，才继续走下去。我们来看下面这段代码：</p>
</div><div class="cl-preview-section"><pre class="  language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JoinClient</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
        Thread backendDev <span class="token operator">=</span> <span class="token function">createWorker</span><span class="token punctuation">(</span><span class="token string">"backed dev"</span><span class="token punctuation">,</span> <span class="token string">"backend coding"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Thread frontendDev <span class="token operator">=</span> <span class="token function">createWorker</span><span class="token punctuation">(</span><span class="token string">"frontend dev"</span><span class="token punctuation">,</span> <span class="token string">"frontend coding"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Thread tester <span class="token operator">=</span> <span class="token function">createWorker</span><span class="token punctuation">(</span><span class="token string">"tester"</span><span class="token punctuation">,</span> <span class="token string">"testing"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        backendDev<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        frontendDev<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      
<span class="token comment">//        backendDev.join();</span>
<span class="token comment">//        frontendDev.join();</span>
      
        tester<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> Thread <span class="token function">createWorker</span><span class="token punctuation">(</span>String role<span class="token punctuation">,</span> String work<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I finished "</span> <span class="token operator">+</span> work <span class="token operator">+</span> <span class="token string">" as a "</span> <span class="token operator">+</span> role<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这段代码中，我们把 join 方法去掉。执行结果如下：</p>
</div><div class="cl-preview-section"><pre><code>I finished backend coding as a backed dev
I finished testing as a tester
I finished backend coding as a frontend dev
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">我们期望的是前端和后端开发完成工作后，测试才开始测试。但从输出结果看并非如此。要想实现这个需求，我们只需把注释打开，让  <strong>backendDev</strong> 和 <strong>frontendDev</strong> 先做 join 操作，此时主线程会被 block 住。直到 <strong>backendDev</strong> 和 <strong>frontendDev</strong> 线程都执行结束，才会继续往下执行。输出如下：</p>
</div><div class="cl-preview-section"><pre><code>I finished backend coding as a backed dev
I finished frontend coding as a frontend dev
I finished testing as a tester
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">可以看到现在的输出完全符合我们的期望。可见调用 join 方法后 block 的并不是被调用的 <strong>backendDev</strong> 或 <strong>frontendDev 线程</strong>，而是调用方线程，这个需要牢记。</p>
</div><div class="cl-preview-section"><h2 id="总结" style="font-size: 30px;">总结</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">本小结讲解了 Thread 的几个常用的方法，这些方法在我们实际开发中会经常用到的，需要我们认真学习和理解。有些已经被弃用的方法没有再讲解，比如 stop 方法。关于更多的方法，其实读者可以直接阅读 Thread 源代码，Thread 类的注解写得相当详细。其实很多时候我们自己动手直接阅读源代码和注解，是更为快捷的学习方式，而且也更为权威。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">下一节我们继续讲解线程的相关操作 wait ()、notify ()、notifyAll ()。这些方法也会改变线程的状态，但并不是 Thread 的 API 。</p>
</div>}
                        </div>
                    </div>
                                            <!-- 买过的阅读 -->
                        <div class="art-next-prev clearfix">
                                                                                                <!-- 已买且开放 或者可以试读 -->
                                    <a href="/read/49/article/941">
                                                                    <div class="prev l clearfix">
                                        <div class="icon l">
                                            <i class="imv2-arrow3_l"></i>
                                        </div>
                                        <p>
                                            06 线程什么时候开始真正执行？—线程的状态详解
                                        </p>
                                    </div>
                                </a>
                                                                                                                            <!-- 已买且开放 或者可以试读 -->
                                    <a href="/read/49/article/943">
                                                                    <div class="next r clearfix">
                                        <p>
                                            08 集体协作，什么最重要？沟通！—线程的等待和通知
                                        </p>
                                        <div class="icon r">
                                            <i class="imv2-arrow3_r"></i>
                                        </div>

                                    </div>
                                </a>
                                                    </div>
                                    </div>
                <div class="comments-con js-comments-con" id="coments_con">
                </div>

                
            </div>
            
            
            

        </div>
    </div>
</div>

<div class="modal modal-jiaQun-new hide" id="modal-jiaQun">
    <div class="inner" style="">
        <div class="modal-close js-close-jiaQun">
            <i class="imv2-close"></i>
        </div>
        <div class="content">
            <img src="https://img4.mukewang.com/5d762b3c000119e505400602.jpg">
            <div class="right-info">
                <div class="title">
                    扫码加入慕课Java核心用户群
                </div>
                <div class="desc">
                                            <p class="mb6">验证信息：<span id="joincode">1910221525494047</span><span class="copy js-copy-joincode">复制</span></p>
                                        <p class="mb6">QQ讨论群号：906691736</p>
                                            <p>QQ群URL：<a href="https://jq.qq.com/?_wv=1027&amp;k=55RtSbJ" target="_blank">点击访问</a></p>
                                    </div>
            </div>
            <p class="tip">若遇到搜索不到QQ群或加群失败，请联系客服邮箱:kf@imooc.com</p>
        </div>
    </div>
</div>
 
<!-- 专栏介绍页专栏评价 -->

<!-- 专栏介绍页底部三条评价 -->

<!-- 专栏阅读页弹层目录和介绍页页面目录 -->

<!-- 专栏阅读页发布回复 -->

<!-- 专栏阅读页发布评论 -->

<!-- 专栏阅读页底部评论 -->

<!-- 专栏阅读 单个 评论 -->

<!-- 新增回复和展开三条以外回复 -->

<!-- 立即订阅的弹窗 -->












</div></body></html>