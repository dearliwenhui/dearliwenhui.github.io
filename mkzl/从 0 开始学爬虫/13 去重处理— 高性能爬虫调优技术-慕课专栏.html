<html><head><meta charset="utf-8"><title>13 去重处理— 高性能爬虫调优技术-慕课专栏</title>
			<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
			<meta name="renderer" content="webkit">
			<meta property="qc:admins" content="77103107776157736375">
			<meta property="wb:webmaster" content="c4f857219bfae3cb">
			<meta http-equiv="Access-Control-Allow-Origin" content="*">
			<meta http-equiv="Cache-Control" content="no-transform ">
			<meta http-equiv="Cache-Control" content="no-siteapp">
			<link rel="apple-touch-icon" sizes="76x76" href="https://www.imooc.com/static/img/common/touch-icon-ipad.png">
			<link rel="apple-touch-icon" sizes="120x120" href="https://www.imooc.com/static/img/common/touch-icon-iphone-retina.png">
			<link rel="apple-touch-icon" sizes="152x152" href="https://www.imooc.com/static/img/common/touch-icon-ipad-retina.png">
			<link href="https://moco.imooc.com/captcha/style/captcha.min.css" rel="stylesheet">
			<link rel="stylesheet" href="https://www.imooc.com/static/moco/v1.0/dist/css/moco.min.css?t=201907021539" type="text/css">
			<link rel="stylesheet" href="https://www.imooc.com/static/lib/swiper/swiper-3.4.2.min.css?t=201907021539">
			<link rel="stylesheet" href="https://static.mukewang.com/static/css/??base.css,common/common-less.css?t=2.5,column/zhuanlanChapter-less.css?t=2.5,course/inc/course_tipoff-less.css?t=2.5?v=201907051055" type="text/css">
			<link charset="utf-8" rel="stylesheet" href="https://www.imooc.com/static/lib/ueditor/themes/imooc/css/ueditor.css?v=201907021539"><link rel="stylesheet" href="https://www.imooc.com/static/lib/baiduShare/api/css/share_style0_16.css?v=6aba13f0.css"></head>
			<body><div id="main">

<div class="container clearfix" id="top" style="display: block; width: 1134px;">
    
    <div class="center_con js-center_con l" style="width: 1134px;">
        <div class="article-con">
                            <!-- 买过的阅读 -->
                <div class="map">
                    <a href="/read" target="_blank"><i class="imv2-feather-o"></i></a>
                    <a href="/read/34" target="_blank">从 0 开始学爬虫</a>
                    <a href="" target="_blank">
                        <span>
                            / 4-2 13 去重处理— 高性能爬虫调优技术
                        </span>
                    </a>
                </div>

            


            <div class="art-title" style="margin-top: 0px;">
                13 去重处理— 高性能爬虫调优技术
            </div>
            <div class="art-info">
                
                <span>
                    更新时间：2019-06-14 14:35:18
                </span>
            </div>
            <div class="art-top">
                                <img src="https://img.mukewang.com/5ce766200001ed3106400360.jpg" alt="">
                                                <div class="famous-word-box">
                    <img src="https://www.imooc.com/static/img/column/bg-l.png" alt="" class="bg1 bg">
                    <img src="https://www.imooc.com/static/img/column/bg-r.png" alt="" class="bg2 bg">
                    <div class="famous-word">没有引发任何行动的思想都不是思想，而是梦想。 <p class="author">—— 马丁</p></div>
                </div>
                            </div>
            <div class="art-content js-lookimg">
                <div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">目标网站中的网页之间的链接可能是有序的也可能是无序的，甚至可能是具有很大重复性的，甚至某些网站采用页面互链的方式形成“链接死循环”诱杀爬虫，对于增量式爬网而言那些被爬取过的数据则没有必要重新获取，由其像对于网易此类老牌的信息门户内链接错综复杂，循环链接极多，面对这些情况我们就需要采用“去重处理”过滤那些没有必要爬取的页面跳出链接的死循环。</p>
</div><div class="cl-preview-section"><h3 id="什么时候应该进行去重处理？">什么时候应该进行去重处理？</h3>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">去重处理可以避免将重复性的数据保存到数据库中以造成大量的冗余性数据。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">不要在获得蜘蛛爬网结果后进行内容过滤，这样做只不过是避免后端数据库出现重复数据。去重处理对于一次性爬取是有效的，但对于增量式爬网则恰恰相反。对于持续性长的增量式爬网，应该进行“前置过滤”，这样可以有效地减少蜘蛛出动的次数。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">在发出请求之前检查蜘蛛是否曾爬取过该 URL，如果已爬取过，则让蜘蛛直接跳过该请求以避免重复出动。除了重复的 URL 指纹，还应该加上404与500错误的URL过滤，因为即使目标网站上没有反爬网机制，但绝大多数的Web 服务器程序都会有对404与500错误的记录。过多的404与500很容易暴露蜘蛛的痕迹，因此加入对异常URL的筛选是非常有必要的。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">Scrapy 是默认加载内置的去重过滤器的，那么我们可以先从这个去重过滤器的源代码中学习一下它的基本实现原理。Scrapy提供了一个很好的请求指纹过滤器（Request Fingerprint duplicates filter - <code>scrapy.dupefilters.RFPDupeFilter</code>），当它被启用后，会自动记录所有成功返回响应的请求的URL并将其以文件（requests.seen）方式保存在项目目录中。请求指纹过滤器的原理是为每个URL生成一个指纹并记录下来，一旦当前请求的URL在指纹库中有记录，就自动跳过该请求。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">接下来我从 <code>scrapy.dupefilters.RFPDupeFilter</code> 源码中抽取其核心代码（其中的部分辅助性的代码被我略去）来了解这个去重的原理：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">class</span> <span class="token class-name">RFPDupeFilter</span><span class="token punctuation">(</span>BaseDupeFilter<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""Request Fingerprint duplicates filter"""</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> path<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> debug<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span><span class="token builtin">file</span> <span class="token operator">=</span> <span class="token boolean">None</span>					<span class="token comment"># 指纹文件</span>
        self<span class="token punctuation">.</span>fingerprints <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 指纹变量</span>
				<span class="token comment"># 这里部分内容略去</span>
        <span class="token keyword">if</span> path<span class="token punctuation">:</span>
            self<span class="token punctuation">.</span><span class="token builtin">file</span> <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token string">'requests.seen'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'a+'</span><span class="token punctuation">)</span>
            self<span class="token punctuation">.</span><span class="token builtin">file</span><span class="token punctuation">.</span>seek<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>fingerprints<span class="token punctuation">.</span>update<span class="token punctuation">(</span>x<span class="token punctuation">.</span>rstrip<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> self<span class="token punctuation">.</span><span class="token builtin">file</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">request_seen</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> request<span class="token punctuation">)</span><span class="token punctuation">:</span>
    		<span class="token triple-quoted-string string">"""
    		读取或更新重复的URL指纹
    		"""</span>
        fp <span class="token operator">=</span> self<span class="token punctuation">.</span>request_fingerprint<span class="token punctuation">(</span>request<span class="token punctuation">)</span>
        <span class="token keyword">if</span> fp <span class="token keyword">in</span> self<span class="token punctuation">.</span>fingerprints<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">True</span>
        self<span class="token punctuation">.</span>fingerprints<span class="token punctuation">.</span>add<span class="token punctuation">(</span>fp<span class="token punctuation">)</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span><span class="token builtin">file</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span><span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span>fp <span class="token operator">+</span> os<span class="token punctuation">.</span>linesep<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">request_fingerprint</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> request<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> request_fingerprint<span class="token punctuation">(</span>request<span class="token punctuation">)</span>
        
		<span class="token comment"># close(), log() 与 from_settings() 三个函数的代码略去</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><code>RFPDupeFilter</code> 的代码非常容易理解，分成两部实现：</p>
</div><div class="cl-preview-section"><ol>
<li style="font-size: 20px; line-height: 38px;">在构造时(<code>__init__</code>)读取现有的URL指纹库文件(没有就创建一个)到一个 <code>fingerprints</code> 变量内，该变量是<code>set</code> 类型所以它是一个具有唯一性的集合，指纹不会重复。</li>
<li style="font-size: 20px; line-height: 38px;">每次发出请求之前Scrapy会调用 <code>request_seen</code> 方法，如果该方法返回 <code>False</code> 请求就会被正常发出，相反则会被剔除。</li>
</ol>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">默认情况下这个过滤器是被自动启用的。当然也可以根据自身的需求编写自定义的过滤器，继承<code>scrapy.dupefilters.BaseDupeFilter</code> 来开发自定义的过滤器。</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">class</span> <span class="token class-name">BaseDupeFilter</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>

    @<span class="token builtin">classmethod</span>
    <span class="token keyword">def</span> <span class="token function">from_settings</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> settings<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""
    我们可以通过这个方法从settings.py文件中读取过滤器的配置
    """</span>
        <span class="token keyword">return</span> cls<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">request_seen</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> request<span class="token punctuation">)</span><span class="token punctuation">:</span>
    	<span class="token triple-quoted-string string">"""
    	返回当前的请求是否已重复
    	"""</span>
        <span class="token keyword">return</span> <span class="token boolean">False</span>

    <span class="token keyword">def</span> <span class="token function">open</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span> 
    	<span class="token triple-quoted-string string">"""
    	当过滤器被打开时执行的代码
    	"""</span>
        <span class="token keyword">pass</span>

    <span class="token keyword">def</span> <span class="token function">close</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> reason<span class="token punctuation">)</span><span class="token punctuation">:</span>  
    	<span class="token triple-quoted-string string">"""
    	当过滤器被关闭时执行的代码
    	"""</span> 
        <span class="token keyword">pass</span>

    <span class="token keyword">def</span> <span class="token function">log</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> request<span class="token punctuation">,</span> spider<span class="token punctuation">)</span><span class="token punctuation">:</span> 
    	<span class="token triple-quoted-string string">"""
    	记录请求已被过滤
    	"""</span>
        <span class="token keyword">pass</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">由于 <code>scrapy.dupefilters.RFPDupeFilter</code> 采用文件方式保存指纹库，对于增量爬取且只用于短期运行的项目还能应对。一旦遇到爬取量巨大的场景时，这个过滤器就显得不太适用了，因为指纹库文件会变得越来越大，过滤器在启动时会一次性将指纹库中所有的URL读入，导致<strong>消耗大量内存</strong>。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><code>scrapy.dupefilters.RFPDupeFilter</code> 是被默认加载的，当然我们也可以在 <code>settings.py</code> 内显式地将它改成我们自己的定义的去重过滤器：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python">DUPEFILTER_CLASS <span class="token operator">=</span> <span class="token string">'netease_crawler.dupefilters.RFPDupeFilter'</span>
</code></pre>
</div><div class="cl-preview-section"><h3 id="编写基于-redis-的去重过滤器">编写基于 Redis 的去重过滤器</h3>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">对于本示例中的增量式的网易爬虫而言 <code>RFPDupeFilter</code> 当爬取数据量变得越来越大时就很容易因为读取指纹库时使用内存过大而导致整个爬虫性能下降，最终会因为内存耗尽而死机。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">所以我们可以采用相同的原理将 URL 指纹存储到 Redis 数据库中，借助 Redis 超高的读写性能来优化由于<code>RFPDupeFilter</code> 所带来的性能瓶颈。</p>
</div><div class="cl-preview-section"><h4 id="redis-的基本介绍" style="font-size: 26px;"><strong>Redis 的基本介绍</strong></h4>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">Redis 是一款开源的，基于 BSD 许可的，高级键值 (key-value) 缓存 (cache) 和存储 (store) 系统。由于 Redis 的键包括 string，hash，list，set，sorted set，bitmap 和 hyperloglog，所以常常被称为数据结构服务器。你可以在这些类型上面运行原子操作，例如，追加字符串，增加哈希中的值，加入一个元素到列表，计算集合的交集、并集和差集，或者是从有序集合中获取最高排名的元素。</p>
</div><div class="cl-preview-section"><h4 id="redis-的作用与好处" style="font-size: 26px;">Redis 的作用与好处</h4>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">为了满足高性能，Redis 采用内存 (in-memory) 数据集 (dataset)。根据你的使用场景，你可以通过每隔一段时间转储数据集到磁盘，或者追加每条命令到日志来持久化。持久化也可以被禁用，如果你只是需要一个功能丰富，网络化的内存缓存。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">Redis 是由 ANSI C 语言编写的，在无需额外依赖下，运行于大多数 POSIX 系统，如 Linux、*BSD、OS X。Redis 是在 Linux 和 OS X 两款操作系统下开发和充分测试的，所以我推荐 Linux 为部署环境。Redis 也可以运行在 Solaris 派生系统上，如 SmartOS，但是支持有待加强。没有官方支持的 Windows 构建版本，但是微软开发和维护了一个 64 位 Windows 的版本。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">更详细的内容可以参考<a href="http://www.redis.cn/">Redis的中文网</a>或者<a href="http://www.redis.io/">Redis英文官网</a></p>
</div><div class="cl-preview-section"><h4 id="安装-redis--docker" style="font-size: 26px;">安装 Redis | Docker</h4>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">比起手工安装Redis我更愿意使用Docker的镜像来起动一个Redis实例，这既不会"污染"我的开发环境也不会给我的开发机器带来过多的性能损耗。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">Docker是一种现代最流行的虚化容器技术，它不像虚拟机那样需要独立分走你系统的资源，而是采用"共享"的方式来使用你的机器。对于完全没有接触过Docker的童鞋也可以保持淡定，就当是执行几个命令行运行起来的一个服务，免去你安装经常下载、安装工具的痛苦。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">关于Docker的详细资料可以到以下的网站中详细学习:</p>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;"><a href="%5Bhttp://www.runoob.com/docker/docker-tutorial.html%5D(http://www.runoob.com/docker/docker-tutorial.html)">菜鸟学院的Docker专栏</a></li>
<li style="font-size: 20px; line-height: 38px;"><a href="%5Bhttp://www.docker.org.cn/%5D(http://www.docker.org.cn/)">Docker中文社区站</a></li>
</ul>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">Docker实在是太火了，它的资料到处都是，为了节省篇幅在此就不过多讲述怎么来安装它了，其它平台的读者可以参考以下的链接：</p>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;"><a href="%5Bhttp://www.runoob.com/docker/centos-docker-install.html%5D(http://www.runoob.com/docker/centos-docker-install.html)">CentOS docker 安装</a></li>
<li style="font-size: 20px; line-height: 38px;"><a href="%5Bhttp://www.runoob.com/docker/windows-docker-install.html%5D(http://www.runoob.com/docker/windows-docker-install.html)">Windows</a></li>
<li style="font-size: 20px; line-height: 38px;"><a href="%5Bhttp://www.runoob.com/docker/macos-docker-install.html%5D(http://www.runoob.com/docker/macos-docker-install.html)">macOS</a></li>
</ul>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">进入docker的命令行，查找redis的镜像：</p>
</div><div class="cl-preview-section"><pre><code>$ docker search redis
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><img src="http://img.mukewang.com/5ce609630001c47c26021344.png" alt="图片描述" data-original="http://img.mukewang.com/5ce609630001c47c26021344.png" class="" style="cursor: pointer;"><br>
找到官方的 docker 镜像 <code>redis</code> (在 OFFICIAL 栏下有 [OK] 字样的都是官方提供的)，然后使用<code>pull</code>指令从docker的镜像库里拉取 <code>redis</code> 到本地机器</p>
</div><div class="cl-preview-section"><pre><code>docker pull redis
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">完成后可以用<code>images</code>指令查看本地已拉取的镜像：<br>
<img src="http://img.mukewang.com/5ce609890001f4ec23081358.png" alt="图片描述" data-original="http://img.mukewang.com/5ce609890001f4ec23081358.png" class="" style="cursor: pointer;">使用 <code>run</code> 指令起动 redis 容器实例：</p>
</div><div class="cl-preview-section"><pre><code>$ mkdir data
$ docker run -p 6379:6379 -v $PWD/data:/data -d redis
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这里要稍微做一个简单的解析，首先我在当前目录创建一个<code>data</code>目录，目的是将redis的数据文件存到这个目录下，然后指令的参数是以下的意义：</p>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;"><code>-p 6379:6379</code> : 将容器的6379端口映射到主机的6379端口</li>
<li style="font-size: 20px; line-height: 38px;"><code>-v $PWD/data:/data</code> : 将主机中当前目录下的<code>data</code>挂载到容器的<code>/data</code>目录</li>
<li style="font-size: 20px; line-height: 38px;"><code>-d</code> 就表示在后台运行</li>
<li style="font-size: 20px; line-height: 38px;"><code>redis</code> 是指定采用哪个镜像来实例化容器</li>
</ul>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">执行以上指令以后就容器就起动了，可以用<code>ps</code>指令查看当前运行了哪些容器实例:</p>
</div><div class="cl-preview-section"><pre><code>$ docker ps
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><img src="http://img.mukewang.com/5ce609c900011eaf17741078.png" alt="图片描述" data-original="http://img.mukewang.com/5ce609c900011eaf17741078.png" class="" style="cursor: pointer;">现在redis就摆在那里可以用了，只要连接到本机的6379端口就可以直接使用redis的存储服务了。</p>
</div><div class="cl-preview-section"><h4 id="python-中连接-redis" style="font-size: 26px;">Python 中连接 Redis</h4>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">接下的一步是我们应该如何在 Python 里面连接redis呢？在 Python 世界中redis的工具包也非常的多，我个人比较喜欢使用<a href="https://pypi.org/project/redis/">redis</a>这个源自于redis官方的Python客户端，它的代码很清晰简单也非常容易使用而且同时支持Python2.x和Python3。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">记得使用前在虚环境先安装redis:</p>
</div><div class="cl-preview-section"><pre><code>$ pip install redis
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">然后按以下的代码，两行就可以实例化redis对象直接在代码里面使用</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">from</span> redis <span class="token keyword">import</span> Redis
redis <span class="token operator">=</span> Redis<span class="token punctuation">(</span>port<span class="token operator">=</span><span class="token number">6379</span><span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><h4 id="set-类型的介绍" style="font-size: 26px;">Set 类型的介绍</h4>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">准备好Redis的工具环境，接下来就是要在Redis中建立指纹库了。Redis是一个键-值(Key-Value)型的NoSQL数据库，它的值有很多种类型，其中我们只需要用到<code>Set</code>这个类型就可以实现指纹库的存储与读取。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p>
</div><div class="cl-preview-section"><h4 id="编写redisdupefilter" style="font-size: 26px;">编写<code>RedisDupeFilter</code></h4>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><code>RedisDupeFilter</code>完合可以按照 <code>RFPDupeFilter</code>的逻辑来改写：</p>
</div><div class="cl-preview-section"><ol>
<li style="font-size: 20px; line-height: 38px;">从<code>BaseDupeFilter</code>直接继承，重写相应方法</li>
<li style="font-size: 20px; line-height: 38px;">从<code>settings.py</code>读取 Redis的连接信息用以实例化<code>redis</code>对象</li>
<li style="font-size: 20px; line-height: 38px;">为每个URL生成指纹存到Redis的Set集合中</li>
<li style="font-size: 20px; line-height: 38px;">对每次进行过滤的重复性URL在日志中记录输出</li>
</ol>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">具体代码实现如下：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token comment"># coding: utf-8</span>
<span class="token keyword">from</span> redis <span class="token keyword">import</span> Redis
<span class="token keyword">from</span> scrapy<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>request <span class="token keyword">import</span> request_fingerprint
<span class="token keyword">from</span> scrapy<span class="token punctuation">.</span>dupefilters <span class="token keyword">import</span> BaseDupeFilter
<span class="token keyword">import</span> logging

<span class="token keyword">class</span> <span class="token class-name">RedisDupeFilter</span><span class="token punctuation">(</span>BaseDupeFilter<span class="token punctuation">)</span><span class="token punctuation">:</span>
		<span class="token triple-quoted-string string">"""
		基于Redis的去重过滤器
		"""</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> host<span class="token operator">=</span><span class="token string">'localhost'</span><span class="token punctuation">,</span> port<span class="token operator">=</span><span class="token number">6379</span><span class="token punctuation">,</span> db<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>redis <span class="token operator">=</span> Redis<span class="token punctuation">(</span>host<span class="token operator">=</span>host<span class="token punctuation">,</span> port<span class="token operator">=</span>port<span class="token punctuation">,</span> db<span class="token operator">=</span>db<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>logger <span class="token operator">=</span> logging<span class="token punctuation">.</span>getLogger<span class="token punctuation">(</span>__name__<span class="token punctuation">)</span>

    @<span class="token builtin">classmethod</span>
    <span class="token keyword">def</span> <span class="token function">from_settings</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> settings<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        读取配置信息
        """</span>
    	host <span class="token operator">=</span> settings<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'REDIS_HOST'</span><span class="token punctuation">,</span><span class="token string">'localhost'</span><span class="token punctuation">)</span>
        redis_port <span class="token operator">=</span> settings<span class="token punctuation">.</span>getint<span class="token punctuation">(</span><span class="token string">'REDIS_PORT'</span><span class="token punctuation">)</span>
        redis_db <span class="token operator">=</span> settings<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'REDIS_DUP_DB'</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> cls<span class="token punctuation">(</span>host<span class="token punctuation">,</span> redis_port<span class="token punctuation">,</span> redis_db<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">request_seen</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> request<span class="token punctuation">)</span><span class="token punctuation">:</span>
        fp <span class="token operator">=</span> self<span class="token punctuation">.</span>request_fingerprint<span class="token punctuation">(</span>request<span class="token punctuation">)</span>
        key <span class="token operator">=</span> <span class="token string">'UrlFingerprints'</span>
        <span class="token keyword">if</span> <span class="token operator">not</span> self<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>sismember<span class="token punctuation">(</span>key<span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>sadd<span class="token punctuation">(</span>key<span class="token punctuation">,</span> fp<span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>
        <span class="token keyword">return</span> <span class="token boolean">True</span>

    <span class="token keyword">def</span> <span class="token function">request_fingerprint</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> request<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        用Hash生成URL指纹
        :param request:
        :return:
        """</span>
        <span class="token keyword">return</span> request_fingerprint<span class="token punctuation">(</span>request<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">log</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> request<span class="token punctuation">,</span> spider<span class="token punctuation">)</span><span class="token punctuation">:</span>
        msg <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"已过滤的重复请求: %(request)s"</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>logger<span class="token punctuation">.</span>debug<span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">'request'</span><span class="token punctuation">:</span> request<span class="token punctuation">}</span><span class="token punctuation">,</span> extra<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">'spider'</span><span class="token punctuation">:</span> spider<span class="token punctuation">}</span><span class="token punctuation">)</span>
        spider<span class="token punctuation">.</span>crawler<span class="token punctuation">.</span>stats<span class="token punctuation">.</span>inc_value<span class="token punctuation">(</span><span class="token string">'dupefilter/filtered'</span><span class="token punctuation">,</span> spider<span class="token operator">=</span>spider<span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">与<code>RFPDupeFilter</code>相比两个过滤的代码基本相同，只是将的文件型的指纹库换成了Redis，这里调用了两个redis的常用指令：<code>sismember</code>和<code>sadd</code>:</p>
</div><div class="cl-preview-section"><pre><code>self.redis.sismember(key,fp)
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这个代码的意思是判断是否具有该的键-值，该方法的调用就相当于在redis-cli的命令行工具中运行<a href="https://redis.io/commands/sismember">SMEMBERS</a>指令:</p>
</div><div class="cl-preview-section"><pre><code>127.0.0.1:6379&gt;SMEMBERS UrlFingerprints
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">如果没有这个URL在指纹库中就是不存在的，通过<code>sadd</code>方法将该URL指纹添加到redis的Set指纹库中。</p>
</div><div class="cl-preview-section"><pre><code>self.redis.sadd(key, fp)
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">上述代码就相当于在 redis-cli 命令工具中的<a href="https://redis.io/commands/sadd">SADD</a></p>
</div><div class="cl-preview-section"><h4 id="request_footprint-函数" style="font-size: 26px;"><code>request_footprint</code> 函数</h4>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">如果你仔细阅读了上述的代码你会发现有一个老是重复出现的函数<code>request_footprint</code>，这个函数的实际作用是将URL转换为哈希值的。由于<code>RFPDupeFilter</code>是将指纹存到文件的，当然存固定长度的哈希值会使得指纹库更小而且校对速度会比字符串更高，但是如果用在Redis中的话就会有点多余了，以下是回顾上文中的一段话：</p>
</div><div class="cl-preview-section"><blockquote>
<p style="font-size: 20px; line-height: 38px;">Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p>
</blockquote>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">也就是说使用Redis的Set集合来存储指纹库的话根本我们就不需要耗费多余的CPU资源来调用<code>request_footprint</code>计算哈希值，直接将URL存到Redis就可以了。下面是简化后的代码：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token comment"># coding: utf-8</span>
<span class="token keyword">from</span> redis <span class="token keyword">import</span> Redis
<span class="token keyword">from</span> scrapy<span class="token punctuation">.</span>dupefilters <span class="token keyword">import</span> BaseDupeFilter
<span class="token keyword">import</span> logging


<span class="token keyword">class</span> <span class="token class-name">RedisDupeFilter</span><span class="token punctuation">(</span>BaseDupeFilter<span class="token punctuation">)</span><span class="token punctuation">:</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> host<span class="token operator">=</span><span class="token string">'localhost'</span><span class="token punctuation">,</span> port<span class="token operator">=</span><span class="token number">6379</span><span class="token punctuation">,</span> db<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>redis <span class="token operator">=</span> Redis<span class="token punctuation">(</span>host<span class="token operator">=</span>host<span class="token punctuation">,</span> port<span class="token operator">=</span>port<span class="token punctuation">,</span> db<span class="token operator">=</span>db<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>logger <span class="token operator">=</span> logging<span class="token punctuation">.</span>getLogger<span class="token punctuation">(</span>__name__<span class="token punctuation">)</span>

    @<span class="token builtin">classmethod</span>
    <span class="token keyword">def</span> <span class="token function">from_settings</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> settings<span class="token punctuation">)</span><span class="token punctuation">:</span>
    		host <span class="token operator">=</span> settings<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'REDIS_HOST'</span><span class="token punctuation">,</span><span class="token string">'localhost'</span><span class="token punctuation">)</span>
        redis_port <span class="token operator">=</span> settings<span class="token punctuation">.</span>getint<span class="token punctuation">(</span><span class="token string">'REDIS_PORT'</span><span class="token punctuation">)</span>
        redis_db <span class="token operator">=</span> settings<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'REDIS_DUP_DB'</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> cls<span class="token punctuation">(</span>host<span class="token punctuation">,</span> redis_port<span class="token punctuation">,</span> redis_db<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">request_seen</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> request<span class="token punctuation">)</span><span class="token punctuation">:</span>
        fp <span class="token operator">=</span> request<span class="token punctuation">.</span>url
        key <span class="token operator">=</span> <span class="token string">'UrlFingerprints'</span>
        <span class="token keyword">if</span> <span class="token operator">not</span> self<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>sismember<span class="token punctuation">(</span>key<span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>sadd<span class="token punctuation">(</span>key<span class="token punctuation">,</span> fp<span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>
        <span class="token keyword">return</span> <span class="token boolean">True</span>


    <span class="token keyword">def</span> <span class="token function">log</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> request<span class="token punctuation">,</span> spider<span class="token punctuation">)</span><span class="token punctuation">:</span>
        msg <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"已过滤的重复请求: %(request)s"</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>logger<span class="token punctuation">.</span>debug<span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">'request'</span><span class="token punctuation">:</span> request<span class="token punctuation">}</span><span class="token punctuation">,</span> extra<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">'spider'</span><span class="token punctuation">:</span> spider<span class="token punctuation">}</span><span class="token punctuation">)</span>
        spider<span class="token punctuation">.</span>crawler<span class="token punctuation">.</span>stats<span class="token punctuation">.</span>inc_value<span class="token punctuation">(</span><span class="token string">'dupefilter/filtered'</span><span class="token punctuation">,</span> spider<span class="token operator">=</span>spider<span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><h4 id="如何读取settings.py中的配置" style="font-size: 26px;">如何读取<code>settings.py</code>中的配置</h4>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">在上述代码中的<code>from_settings</code>方法就是用于从<code>settings.py</code>文件中读取配置值的，所有的配置都将被Scrapy自动读取并存到该方法的<code>settings</code>字典对象中，本示例为了使<code>RedisDupeFilter</code>可以变得更加通用，特意将Redis的连接信息放至到<code>settings.py</code>中。也就是说按上述代码的定义，这个网易爬虫的<code>settings.py</code>就多了三个可附加的配置项：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token comment"># settings.py</span>
REDIS_HOST <span class="token operator">=</span> <span class="token string">'localhost'</span> <span class="token comment"># 配置Redis的安装地址</span>
REDIS_PORT <span class="token operator">=</span> <span class="token number">6379</span>        <span class="token comment"># Redis的连接端口</span>
REDIS_DUP_DB <span class="token operator">=</span> <span class="token number">0</span> 			   <span class="token comment"># REdis去重过滤器的数据库</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><code>from_settings</code>还附带了一个装饰器<code>@classmethod</code>:</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python">@<span class="token builtin">classmethod</span>
<span class="token keyword">def</span> <span class="token function">from_settings</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>settings<span class="token punctuation">)</span><span class="token punctuation">:</span>
	 <span class="token keyword">pass</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">意思就是说这是一个类方法或者可以理解为"静态方法"，就是当类还没有被实例化时仍然可以被调用的方法类型。这个方法同时也是一个“工厂方法”用于实例化自已，在实例化的过程中将参数传给自己的构造函数<code>__init__</code>。</p>
</div><div class="cl-preview-section"><blockquote>
<p style="font-size: 20px; line-height: 38px;">Scrapy的其它插件都大量采用了这种模式来进行全局配置的传入。</p>
</blockquote>
</div><div class="cl-preview-section"><h4 id="log-与-stats-收集运行时输出信息" style="font-size: 26px;">log 与 stats 收集运行时输出信息</h4>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><code>RedisDupeFilter</code>过滤器中的最后个方法<code>log</code>用于将被过滤的信息添加到全局状态变量<code>crawler.states</code>中。这是个非常有意义的小处理。爬虫本身就是一个非可视化的服务，每次的爬取时间又非常的短暂，处理的问题越多、越复杂可能出现异常的机会也就越大，而且爬虫所面对的数据可以说是千奇百怪什么样的都有，如果没有一个集中的地方去收集每个处理中的状态，去记录每个关键操作，以后就很难去进行深入的数据分析工作了。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">由于这个<code>log</code>方法极为简单，所以就更容易理解与学习希望不要将其忽略，本专栏后续的章节中还会专门去讲述关于日志与状态收集的内容，所以在此暂时不作展开。</p>
</div><div class="cl-preview-section"><h4 id="配置并启用去重过滤器-redisdupefilter" style="font-size: 26px;">配置并启用去重过滤器 <code>RedisDupeFilter</code></h4>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">现在只要在<code>settings.py</code>中将<code>DUPEFILTER_CLASS</code>的配置指向<code>RedisDupeFilter</code>就可以使用这个高效的去重过滤器了。</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python">DUPEFILTER_CLASS <span class="token operator">=</span> <span class="token string">'netease_crawler.dupefilters.RedisDupeFilter'</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">完成配置后运行:</p>
</div><div class="cl-preview-section"><pre><code>$ scrapy crawl netease
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">仅仅通过控制台的LOG输出速度就明显感觉到整个爬虫的性能番了好几番！</p>
</div><div class="cl-preview-section"><h3 id="小结">小结</h3>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">至此我们已接触了两种去重过滤器，接下来将介绍一个更强大的布隆过滤器。在此之前有必要对去重过滤器的应用先做一个简单的小结，归纳它们适用的场合才能更好地发挥它们的作用。</p>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">当数据量不大时（大约在200MB内)，可以直接在内存中进行去重处理（例如，可以使用<code>set()</code>进行去重），而更省事又能对去重状态进行持久化的办法就是采用<code>scrapy.dupefilters.RFPDupeFilter</code>；</li>
<li style="font-size: 20px; line-height: 38px;">当数据量在5GB以内时，建议采用上文中的<code>RedisDupeFilter</code>进行去重，当然这要求服务器的内存必须大于5GB，否则Redis可能会将机器的内存耗光；</li>
<li style="font-size: 20px; line-height: 38px;">当数据量达到10~100GB级别时，由于内存有限，就必须用“位”来去重，才能够满足需求。而布隆过滤器就是将去重对象映射到几个内存“位”，通过几个位的0/1值来判断一个对象是否已经存在，以应对海量级的请求数据的重复性校验。</li>
</ul>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><img src="http://img.mukewang.com/5cf4fa8100018b6816000924.jpg" alt="图片描述" data-original="http://img.mukewang.com/5cf4fa8100018b6816000924.jpg" class="" style="cursor: pointer;"></p>
</div></div>
            </div>
                            <!-- 买过的阅读 -->
                <div class="art-next-prev clearfix">
                                                                        <!-- 已买且开放 或者可以试读 -->
                            <a href="/read/34/article/317">
                                                    <div class="prev l clearfix">
                                <div class="icon l">
                                    <i class="imv2-arrow3_l"></i>
                                </div>
                                <p>
                                    12 用 ItemLoader 解决网页数据多样性的问题
                                </p>
                            </div>
                        </a>
                                                                                            <!-- 已买且开放 或者可以试读 -->
                            <a href="/read/34/article/319">
                                                    <div class="next r clearfix">
                                <p>
                                    14 高效的布隆过滤器 - RedisBloomDupeFilter
                                </p>
                                <div class="icon r">
                                    <i class="imv2-arrow3_r"></i>
                                </div>

                            </div>
                        </a>
                                    </div>
                    </div>
        <div class="comments-con js-comments-con" id="coments_con">
        </div>



    </div>
    
    
    

</div>
 
<!-- 专栏介绍页专栏评价 -->

<!-- 专栏介绍页底部三条评价 -->

<!-- 专栏阅读页弹层目录和介绍页页面目录 -->

<!-- 专栏阅读页发布回复 -->

<!-- 专栏阅读页发布评论 -->

<!-- 专栏阅读页底部评论 -->

<!-- 专栏阅读 单个 评论 -->

<!-- 新增回复和展开三条以外回复 -->

<!-- 立即订阅的弹窗 -->












</div></body></html>