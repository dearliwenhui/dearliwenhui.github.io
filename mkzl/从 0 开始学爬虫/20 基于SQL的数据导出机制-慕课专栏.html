<html><head><meta charset="utf-8"><title>20 基于SQL的数据导出机制-慕课专栏</title>
			<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
			<meta name="renderer" content="webkit">
			<meta property="qc:admins" content="77103107776157736375">
			<meta property="wb:webmaster" content="c4f857219bfae3cb">
			<meta http-equiv="Access-Control-Allow-Origin" content="*">
			<meta http-equiv="Cache-Control" content="no-transform ">
			<meta http-equiv="Cache-Control" content="no-siteapp">
			<link rel="apple-touch-icon" sizes="76x76" href="https://www.imooc.com/static/img/common/touch-icon-ipad.png">
			<link rel="apple-touch-icon" sizes="120x120" href="https://www.imooc.com/static/img/common/touch-icon-iphone-retina.png">
			<link rel="apple-touch-icon" sizes="152x152" href="https://www.imooc.com/static/img/common/touch-icon-ipad-retina.png">
			<link href="https://moco.imooc.com/captcha/style/captcha.min.css" rel="stylesheet">
			<link rel="stylesheet" href="https://www.imooc.com/static/moco/v1.0/dist/css/moco.min.css?t=201907021539" type="text/css">
			<link rel="stylesheet" href="https://www.imooc.com/static/lib/swiper/swiper-3.4.2.min.css?t=201907021539">
			<link rel="stylesheet" href="https://static.mukewang.com/static/css/??base.css,common/common-less.css?t=2.5,column/zhuanlanChapter-less.css?t=2.5,course/inc/course_tipoff-less.css?t=2.5?v=201907051055" type="text/css">
			<link charset="utf-8" rel="stylesheet" href="https://www.imooc.com/static/lib/ueditor/themes/imooc/css/ueditor.css?v=201907021539"><link rel="stylesheet" href="https://www.imooc.com/static/lib/baiduShare/api/css/share_style0_16.css?v=6aba13f0.css"></head>
			<body><div id="main">

<div class="container clearfix" id="top" style="display: block; width: 1134px;">
    
    <div class="center_con js-center_con l" style="width: 1134px;">
        <div class="article-con">
                            <!-- 买过的阅读 -->
                <div class="map">
                    <a href="/read" target="_blank"><i class="imv2-feather-o"></i></a>
                    <a href="/read/34" target="_blank">从 0 开始学爬虫</a>
                    <a href="" target="_blank">
                        <span>
                            / 5-4 20 基于SQL的数据导出机制
                        </span>
                    </a>
                </div>

            


            <div class="art-title" style="margin-top: 0px;">
                20 基于SQL的数据导出机制
            </div>
            <div class="art-info">
                
                <span>
                    更新时间：2019-06-17 10:56:38
                </span>
            </div>
            <div class="art-top">
                                <img src="https://img1.mukewang.com/5cfe04c50001874006400359.jpg" alt="">
                                                <div class="famous-word-box">
                    <img src="https://www.imooc.com/static/img/column/bg-l.png" alt="" class="bg1 bg">
                    <img src="https://www.imooc.com/static/img/column/bg-r.png" alt="" class="bg2 bg">
                    <div class="famous-word">勤能补拙是良训，一分辛劳一分才。<p class="author">——华罗庚</p></div>
                </div>
                            </div>
            <div class="art-content js-lookimg">
                <div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">豆瓣读书的数据是结构化的，而且数据量并不像网易那样庞大所以更适宜采用SQL数据库作为爬取数据的后端存储。本节将深入 scrapy 的数据<strong>后处理</strong>机制，了解 scrapy 是怎样将<code>Item</code>数据导出成不同格式的数据文件。并巧妙地运用此机制为 scrapy 加装一个将<code>Item</code>数据直接导出至 sqlite,mysql,postgresql 这些流行的 SQL 数据库之中。</p>
</div><div class="cl-preview-section"><h2 id="采用-sql-存储的考虑与理由" style="font-size: 30px;">采用 SQL 存储的考虑与理由</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">在第4章我们就基于Scrapy<code>Pipline</code>(管道)技术实现将数据项存储到MongoDB的定义<strong>数据管道</strong>，采用MongoDB的最大好处是它的使用极为之简单，在python内与MongoDB的交互就是普通的JSON数据读写，这样可以让没有任何数据库基础的读者都能上手。而NoSQL数据库其实只在<strong>高频读</strong>的场景最合适并不适宜于<strong>高频写</strong>的应用；其次，对爬取后的数据要进行批量的统计与查询NoSQL并没有SQL方便。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">再者，数据库是后端开发人员永远绕不开的一个重要技术主题，我也想借此能为一些刚开始接触Python的读者打开一扇通向学习数据库技术的大门，在学习爬虫技术后也能将其中的内容应用到其它领域的开发中。</p>
</div><div class="cl-preview-section"><h2 id="什么是导出器feed-exportor" style="font-size: 30px;">什么是导出器(Feed Exportor)</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">前文我之所以用管道来实现一个MongoDB的数据存储是因为管道是Scrapy的一种标准插件，可以由Scrapy去调用它，只要实现一次以后就可以通过配置将它"插入"到其它的项目里面重用。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">其实Scrapy还有另一种机制是专门负责数据的输出的，还记得我们从第一章中就介绍过通过指令将数据输出到JSON文件：</p>
</div><div class="cl-preview-section"><pre><code>(venv) $ scrapy crawl &lt;蜘蛛名&gt; -o 数据文件.json
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">当我们需要将爬取后的数据项进行持久化存储或导出数据时，就可以采用导出器来完成这一步骤。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">导出器(Feed Exportor) 并不是一个具体的类，而是Scrapy中的一种数据导出的处理机制，这种机制由两个具体部分组成：</p>
</div><div class="cl-preview-section"><ol>
<li style="font-size: 20px; line-height: 38px;">数据项导出器（Item Exporter）</li>
<li style="font-size: 20px; line-height: 38px;">存储端 （Storage backends）</li>
</ol>
</div><div class="cl-preview-section"><h3 id="数据项导出器item-exporter">数据项导出器(Item Exporter)</h3>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">数据项导出器负责对数据项<code>Iitem</code>进行<strong>序列化</strong>处理，也就是将对象实例转化并保存到某一指定的可储格式的文件中。</p>
</div><div class="cl-preview-section"><blockquote>
<p style="font-size: 20px; line-height: 38px;"><strong>序列化</strong>——可以说是面向对象语言中必备的功能，一般意义上的序列化只是将对象实例与类型信息直接转化为二进制流的形式，这样就能将对象的“状态”存储起来，以后用的时候再通过反序列化将其从文件中恢复成对象实例，这个操作有点像科幻片中人类被冰冻与解冻的过程。</p>
</blockquote>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">Scrapy默认提供了可以输出至 XML、CSV、JSON及Python二进制对象文件的几种数据导出器。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">我们都可以通过 <code>scrapy crawl</code> 指令的<code>-o</code>参数来使用它们而无须编写任何的代码，例如我们可以把第2章中的新闻供稿爬虫的结果输出到xml中：</p>
</div><div class="cl-preview-section"><pre><code>$ scrapy crawl news -a url='http://www.chinanews.com/rss/scroll-news.xml' -o chinanews.xml
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">又或者输出成为 CSV:</p>
</div><div class="cl-preview-section"><pre><code>$ scrapy crawl news -a url='http://www.chinanews.com/rss/scroll-news.xml' -o chinanews.csv
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">上述的这个过程就Scrapy识别了输出文件的后缀名自动匹配了一种文件格式的数据项导出器将<code>Item</code>的数据实例转化为对应的文本格式，然后使用默的存储端(文件)将文件进行输出。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">我们可以将<code>-o</code>参数的内容写入到<code>settings.py</code>配置文件中，每次运行就不需要打输出文件名了:</p>
</div><div class="cl-preview-section"><pre class="  language-json"><code class="prism  language-json">FEED_URI<span class="token operator">=</span><span class="token string">'file:///export.csv'</span>
</code></pre>
</div><div class="cl-preview-section"><blockquote>
<p style="font-size: 20px; line-height: 38px;">Windows 下不能使用相对路径:</p>
<pre><code>FEED_URI='file:///c:\export.csv'
</code></pre>
</blockquote>
</div><div class="cl-preview-section"><h3 id="存储端-storage-backends">存储端( Storage backends)</h3>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">存储端就是将数据导出器输出结果保存到不同协议的输出上。Scrapy提供以下4种标准的存储端：</p>
</div><div class="cl-preview-section"><div class="table-wrapper"><table>
<thead>
<tr>
<th>协议</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>file://</code></td>
<td>本地文件系统</td>
</tr>
<tr>
<td><code>s3://</code></td>
<td>Amazon S3存储（URI中可带有用户名与密码参数）</td>
</tr>
<tr>
<td><code>ftp://</code></td>
<td>标准FTP的地址格式（URI中可指定FTP用户名与密码）</td>
</tr>
<tr>
<td><code>stdout:</code></td>
<td>标准输出</td>
</tr>
</tbody>
</table>
</div></div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">Scrapy是通过<code>FEED_URI</code>中指定的存储协议来匹配使用哪一种存储端的，例如我们可以将文件保存到FTP服务器的话就可以在<code>FEED_URI</code>上这样来指定:</p>
</div><div class="cl-preview-section"><pre><code>FEED_URI='ftp://username@password:/home/export.csv'
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">事实上，这些存储端都没有什么具体实用性。我们可以按需要来改造成为我们需要的存储端，例如将PostgreSQL作为存储端。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">我们能不能使用Scrapy的数据导出器机制在配置文件上这样定义就能将数据导入到SQL的数据库呢？</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">例如，用<code>FEED_URI</code>来指定连接数据库的连接串(Connection String)：</p>
</div><div class="cl-preview-section"><pre><code>FEED_URI = 'postgres://postgres:@localhost:10086/postgres' 
</code></pre>
</div><div class="cl-preview-section"><h2 id="设计基于sql的数据导出机制" style="font-size: 30px;">设计基于SQL的数据导出机制</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">在进行设计之前我们需要先学习一下在python中如何来访问数据库的基础知识。在Linux世界中比较流行的数据库有SQLite、MySQL、PostgreSQL等，那么是不是对每一种SQL数据库都要学习一种工具库呢？当然不是了！Python有一个非常著名的数据工具<a href="https://www.sqlalchemy.org/">SQLAlchemy</a>，掌握了它就能操控各种各样的SQL数据库了。</p>
</div><div class="cl-preview-section"><blockquote>
<p style="font-size: 20px; line-height: 38px;">如果你是一位完全没有数据库基础的读者，那么我建议你可以到<a href="https://www.runoob.com/sqlite/sqlite-tutorial.html">菜鸟学院的SQLite</a>栏目或<a href="https://www.runoob.com/mysql/mysql-tutorial.html">MySQL教程</a>栏目先学习一些数据库的基础知识然后再继续下面内容的阅读，这会对你对下面示例内容的理解有很大帮助。</p>
</blockquote>
</div><div class="cl-preview-section"><h3 id="sqlalchemy-的使用简介">SQLAlchemy 的使用简介</h3>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">由于本专栏的篇幅所限，而且数据库与SQLAlchemy的相关话题所涉及的范围极广，难以用短短的字数将其囊括。考虑到一些没有接触过SQLAlchemy的读者，在此会简单地以代码为例介绍SQLAlchemy的最基本用法，更具体的内容可以到<a href="https://www.sqlalchemy.org/">SQLArchemy的官网</a>中仔细学习。对于已经熟悉SQLAlchemy读者可以直接跳过本段进入下一部分的内容。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">SQLAlchemy是Python编程语言下的一款开源软件。提供了SQL工具包及对象关系映射<a href="https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84">（ORM）</a>工具。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">SQLAlchemy的设计理念是：SQL数据库的量级和性能重要于对象集合；而对象集合的抽象又重要于表和行。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">因此，SQLAlchmey采用了类似于Java里Hibernate的数据映射模型。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">安装SQLAlchmey</p>
</div><div class="cl-preview-section"><pre><code>(venv) $ pip install sqlalchmey
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">由于ORM是一种模式，也就是说，只要是ORM，其使用方法都是大同小异的，归纳起来有以下4步：</p>
</div><div class="cl-preview-section"><ol>
<li style="font-size: 20px; line-height: 38px;">建模 - 建立与数据库对等的数据对象模型。</li>
<li style="font-size: 20px; line-height: 38px;">建立数据连接并产生数据上下文——通过连接字符串与指定数据库建立连接并取得可操作当前数据库的上下文对象。</li>
<li style="font-size: 20px; line-height: 38px;">操作数据 - 通过数据库上下文对象对数据进行增加、删除、修改、查询等常规操作。</li>
<li style="font-size: 20px; line-height: 38px;">提交更改 - 将变更后的数据内容提交并永久性写入数据库。</li>
</ol>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><strong>第一步：建模</strong></p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">SQLAlchemy 定义对象模型后可以调用<code>db.create_all()</code>函数就可以自动在数据库中建立与模型对应的数据表。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">首先用<code>declarative_base()</code>建立数据表的基类，然后就实体就可以从此基类继承。这个类必须定义<code>__tablename__</code>用于声明该类与数据库中进行映射的表名。每个性属性将对应数据表的一个列(字段)。</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">from</span> sqlalchemy<span class="token punctuation">.</span>ext<span class="token punctuation">.</span>declarative <span class="token keyword">import</span> declarative_base
<span class="token keyword">from</span> sqlalchemy <span class="token keyword">import</span> Column<span class="token punctuation">,</span> Integer

<span class="token comment"># 创建对象的基类：</span>
db <span class="token operator">=</span> declarative_base<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">Book</span><span class="token punctuation">(</span>db<span class="token punctuation">)</span><span class="token punctuation">:</span>
    __tablename__ <span class="token operator">=</span> <span class="token string">'books'</span>
    <span class="token builtin">id</span> <span class="token operator">=</span> Column<span class="token punctuation">(</span>Integer<span class="token punctuation">,</span> primary_key<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">用<code>Column</code>类定义列，第一个参数为数据类型，上述代码中的<code>primary_key=True</code>表示<code>id</code>字段是一个主键，每个数据表都应该有一个唯一值的主键，当定义<code>Integer</code>类型的主键后该值性我们并不需要赋值，数据库会自动将其设置为<strong>自增值</strong>每次新增数据时这个字段将会被自动填充。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">以下是<code>Book</code>类的全部代码：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">from</span> sqlalchemy<span class="token punctuation">.</span>ext<span class="token punctuation">.</span>declarative <span class="token keyword">import</span> declarative_base
<span class="token keyword">from</span> sqlalchemy <span class="token keyword">import</span> Column<span class="token punctuation">,</span> Integer<span class="token punctuation">,</span> String<span class="token punctuation">,</span> Float<span class="token punctuation">,</span> Text<span class="token punctuation">,</span> DateTime

<span class="token comment"># 创建对象的基类：</span>
db <span class="token operator">=</span> declarative_base<span class="token punctuation">(</span><span class="token punctuation">)</span>


<span class="token keyword">class</span> <span class="token class-name">Book</span><span class="token punctuation">(</span>db<span class="token punctuation">)</span><span class="token punctuation">:</span>
    __tablename__ <span class="token operator">=</span> <span class="token string">'books'</span>

    <span class="token builtin">id</span> <span class="token operator">=</span> Column<span class="token punctuation">(</span>Integer<span class="token punctuation">,</span> primary_key<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    <span class="token comment"># 书名</span>
    name <span class="token operator">=</span> Column<span class="token punctuation">(</span>String<span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment"># 作者</span>
    authors <span class="token operator">=</span> Column<span class="token punctuation">(</span>String<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment"># 出版社</span>
    publishing_house <span class="token operator">=</span> Column<span class="token punctuation">(</span>String<span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment"># 出品方</span>
    publisher <span class="token operator">=</span> Column<span class="token punctuation">(</span>String<span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment"># 原名</span>
    origin_name <span class="token operator">=</span> Column<span class="token punctuation">(</span>String<span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment"># 译者</span>
    translators <span class="token operator">=</span> Column<span class="token punctuation">(</span>String<span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment"># 出版时间</span>
    pub_date <span class="token operator">=</span> Column<span class="token punctuation">(</span>DateTime<span class="token punctuation">)</span>
    <span class="token comment"># 页数</span>
    pages <span class="token operator">=</span> Column<span class="token punctuation">(</span>Integer<span class="token punctuation">)</span>
    <span class="token comment"># 定价</span>
    price <span class="token operator">=</span> Column<span class="token punctuation">(</span>Float<span class="token punctuation">)</span>
    <span class="token comment"># ISBN</span>
    isbn <span class="token operator">=</span> Column<span class="token punctuation">(</span>String<span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment"># 豆瓣评分</span>
    rates <span class="token operator">=</span> Column<span class="token punctuation">(</span>Float<span class="token punctuation">)</span>
    <span class="token comment"># 评价数</span>
    rating_count <span class="token operator">=</span> Column<span class="token punctuation">(</span>Integer<span class="token punctuation">)</span>
    summary <span class="token operator">=</span> Column<span class="token punctuation">(</span>Text<span class="token punctuation">)</span>
    <span class="token comment"># 作者简介</span>
    about_authors <span class="token operator">=</span> Column<span class="token punctuation">(</span>Text<span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><strong>第二步：建立连接</strong></p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">接下来我们可以先创建一个测试，在测试中来实践演练数据库的连接与操控。在测试环境我们可以使用SQLite这个小型的文件数据库。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><code>test_db.py</code>的代码如下所示：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token comment"># coding:utf-8</span>
<span class="token keyword">from</span> unittest <span class="token keyword">import</span> TestCase
<span class="token keyword">from</span> sqlalchemy <span class="token keyword">import</span> create_engine
<span class="token keyword">from</span> sqlalchemy<span class="token punctuation">.</span>orm <span class="token keyword">import</span> sessionmaker

<span class="token keyword">class</span> <span class="token class-name">DataBaseTestCase</span><span class="token punctuation">(</span>TestCase<span class="token punctuation">)</span><span class="token punctuation">:</span>

    <span class="token keyword">def</span> <span class="token function">test_add_data</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 初始化数据库连接：</span>
        engine <span class="token operator">=</span> create_engine<span class="token punctuation">(</span><span class="token string">'sqlite:///test.db'</span><span class="token punctuation">)</span>
        <span class="token comment"># 创建DBSession类型：</span>
        DBSession <span class="token operator">=</span> sessionmaker<span class="token punctuation">(</span>bind<span class="token operator">=</span>engine<span class="token punctuation">)</span>
        session <span class="token operator">=</span> DBSession<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><code>create_engine()</code>用来初始化数据库连接。SQLAlchemy用一个字符串表示连接信息,这个就是连接字符串（Connection String）它的标准格式如下所示：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token string">'数据库类型+数据库驱动名称://用户名:口令@机器地址:端口号/数据库名'</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><strong>第三步：操作数据对象</strong></p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">下面，我们看看如何向数据库表中添加一行记录。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">由于有了ORM，向数据库表中添加一行记录可以视为添加一个<code>Book</code>对象：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token comment"># 创建session对象：</span>
DBSession <span class="token operator">=</span> sessionmaker<span class="token punctuation">(</span>bind<span class="token operator">=</span>engine<span class="token punctuation">)</span>
session <span class="token operator">=</span> DBSession<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 创建新Book对象：</span>
book <span class="token operator">=</span> Book<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"解忧杂货店"</span><span class="token punctuation">,</span>authors<span class="token operator">=</span><span class="token string">"东野圭吾"</span><span class="token punctuation">)</span>

<span class="token comment"># 添加到session中：</span>
session<span class="token punctuation">.</span>add<span class="token punctuation">(</span>book<span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><strong>第四步：提交更改</strong></p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">SQLAlchamy 的操作依赖于<code>session</code>对象，当实例化<code>session</code>后就可以调用<code>add</code>方法将对象加入到到<code>session</code>中，此时SQLAlchamy并没有直正将数据保存到数据库中，直至我们调用<code>session.commit()</code>后SQLAlchamy才会一次性将<code>session</code>内的数据变更提交到数据库。最后使用完数据库后就要调用<code>session.close()</code>方法关闭数据库连接释放连接资源。</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token comment"># 提交即保存到数据库中：</span>
session<span class="token punctuation">.</span>commit<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 关闭session：</span>
session<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><strong>查询数据</strong></p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">如何从数据库表中查询数据呢？SQLAlchemy提供的查询接口如下：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token comment"># 创建Session:</span>
session <span class="token operator">=</span> DBSession<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 创建Query查询，filter是where条件，最后调用one()返回唯一行，如果调用all()则返回所有行：</span>
book <span class="token operator">=</span> session<span class="token punctuation">.</span>query<span class="token punctuation">(</span>Book<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">filter</span><span class="token punctuation">(</span>Book<span class="token punctuation">.</span><span class="token builtin">id</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>one<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 打印类型和对象的name属性：</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'type:'</span><span class="token punctuation">,</span> <span class="token builtin">type</span><span class="token punctuation">(</span>book<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'name:'</span><span class="token punctuation">,</span> book<span class="token punctuation">.</span>name<span class="token punctuation">)</span>

<span class="token comment"># 关闭Session:</span>
session<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">由于关系数据库的多个表还可以用外键实现一对多、多对多等关联，相应地，ORM框架也可以提供两个对象之间的一对多、多对多等功能。由于本示例中并没有使用到关系表，所以在此不作过多的表述。但作为扩展学习，你可以到SQLAlchamy的官网上仔细阅读相关的内容。</p>
</div><div class="cl-preview-section"><h3 id="安装数据库">安装数据库</h3>
</div><div class="cl-preview-section"><h4 id="安装-sqlite" style="font-size: 26px;">安装 SQLite</h4>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><strong>Windows</strong></p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">先下载以下的安装文件:</p>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;"><a href="https://www.sqlite.org/2019/sqlite-dll-win32-x86-3280000.zip">SQLite for Windows 32位运行库</a></li>
<li style="font-size: 20px; line-height: 38px;"><a href="https://www.sqlite.org/2019/sqlite-dll-win64-x64-3280000.zip">SQLite for Windows 64位运行库</a></li>
<li style="font-size: 20px; line-height: 38px;"><a href="https://www.sqlite.org/2019/sqlite-tools-win32-x86-3280000.zip">SQLite 工具</a></li>
</ul>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">创建文件夹 <code>C:\\sqlite</code>，并在此文件夹下解压上面两个压缩文件，将得到 <code>sqlite3.def</code>、<code>sqlite3.dll</code> 和 <code>sqlite3.exe</code> 文件。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">添加 <code>C:\\sqlite</code> 到 <code>PATH</code> 环境变量，最后在命令提示符下，使用 sqlite3 命令，将显示如下结果。</p>
</div><div class="cl-preview-section"><pre><code>C:\&gt;sqlite3
SQLite version 3.28.0 2019-03-02 15:25:24
Enter ".help" for instructions
Enter SQL statements terminated with a ";"
sqlite&gt;
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><strong>Linux</strong><br>
目前，几乎所有版本的 Linux 操作系统都附带 SQLite。所以，只要使用下面的命令来检查您的机器上是否已经安装了 SQLite。</p>
</div><div class="cl-preview-section"><pre><code>$ sqlite3
SQLite version 3.28.0 2019-03-02 15:25:24
Enter ".help" for usage hints.
sqlite&gt;
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">如果没有就直接下载 <a href="https://www.sqlite.org/2019/sqlite-tools-linux-x86-3280000.zip">sqlite-tools-linux-x86-3280000.zip</a> 到本地执行安装。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><strong>macOS</strong></p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">macOS上可以通过Home brew来安装，具体如下所示:</p>
</div><div class="cl-preview-section"><pre><code>$ brew install sqlite3
</code></pre>
</div><div class="cl-preview-section"><h4 id="安装-postgresql" style="font-size: 26px;">安装 PostgreSQL</h4>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">我们要以借助Docker避免安装数据库这样麻烦的过程，PostgreSQL的docker:</p>
</div><div class="cl-preview-section"><pre><code>$ docker run -p 5432:5432 -e POSTGRES_PASSWORD=&lt;你想设置的数据库密码&gt; -d postgres

</code></pre>
</div><div class="cl-preview-section"><h4 id="安装-mysql" style="font-size: 26px;">安装 MySQL</h4>
</div><div class="cl-preview-section"><pre><code>$ docker run -p 3306:3306 -e MYSQL_ROOT_PASSWORD=&lt;你想设置的数据库密码&gt; -d mysql
</code></pre>
</div><div class="cl-preview-section"><h3 id="sql数据项导出器与sql存储端的实现">SQL数据项导出器与SQL存储端的实现</h3>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">Scrapy的数据导出机制是由数据项导出器(<code>ItemExporter</code>)和存储端所组成（Storage backends)。<code>ItemExporter</code>负责数据格式的转换，存储端则负责对数据项进行存储。我们要实现基于SQL的数据导出机制就要同时提供以下两个类:</p>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;"><code>SQLItemExporter</code> - 将数据项转换为实体类，例如将<code>BookItem</code>转换为<code>Book</code></li>
<li style="font-size: 20px; line-height: 38px;"><code>SQLStorage</code> - 将数据实体写入到SQL数据库</li>
</ul>
</div><div class="cl-preview-section"><h4 id="sqlfeedstorage" style="font-size: 26px;"><code>SQLFeedStorage</code></h4>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">Scrapy的存储端技术虽然有很强的可扩充性，但官方只给出了文件形式的存储。如果仔细阅读上一节的内容，会发现存储后端仅限于文件类型使用，不能用作数据库，这是由于存储端需要实现的<code>IFeedStorage</code>接口所限定的，我们先来看看<code>IFeedStorage</code>的定义：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">class</span> <span class="token class-name">IFeedStorage</span><span class="token punctuation">(</span>Interface<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""所有的存储后端口都必须实现此接口"""</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>uri<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""通过指定的URI参数初始化存储"""</span>

    <span class="token keyword">def</span> <span class="token function">open</span><span class="token punctuation">(</span>spider<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""为指定的蜘蛛打开存储。此方法必须返回一个类似文件的对象，用作数据导出"""</span>

    <span class="token keyword">def</span> <span class="token function">store</span><span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""存储文件流"""</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">所有的存储后端口都必须实现此接口，如果想扩充成数据库方式，则要对<code>store(file)</code>方法进行一点<strong>活用</strong>，我们先将整个数据导出机制的运作过程撸一撸：</p>
</div><div class="cl-preview-section"><ol>
<li style="font-size: 20px; line-height: 38px;">调用<code>IFeedStorage.open()</code>打开数据文件，<code>open</code>必须返回一个<code>file</code>对象</li>
<li style="font-size: 20px; line-height: 38px;">Scrapy 会将<code>file</code>对象在构造ItemExporter作为构造参传递至ItemExporter</li>
<li style="font-size: 20px; line-height: 38px;">ItemExporter将数据项一条一条进行导出转换，然后后写入<code>file</code>对象。</li>
<li style="font-size: 20px; line-height: 38px;">完成所有数据项的导出后，Scrapy会调用<code>IFeedStorage</code>的<code>store(file)</code>保存数据。</li>
</ol>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">在<code>open</code>方法中返回的<code>file</code>与<code>store</code>中的<code>file</code>参数并没有规定具体的类型，所以我们可以设计一个类模拟<code>file</code>的写入行为，而实际上却是用于将数据实体写入到<code>session</code></p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">class</span> <span class="token class-name">EntityFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> session<span class="token punctuation">,</span> entity_cls<span class="token punctuation">)</span><span class="token punctuation">:</span>
    		<span class="token triple-quoted-string string">"""
    		构造函数
    		:param session: 数据库Session实例
    		:param entity_cls: 数据实体类
    		"""</span>
        self<span class="token punctuation">.</span>session <span class="token operator">=</span> session
        <span class="token keyword">if</span> entity_cls <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token keyword">raise</span> NotConfigured
        self<span class="token punctuation">.</span>entity_cls <span class="token operator">=</span> entity_cls

    <span class="token keyword">def</span> <span class="token function">write</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> keys<span class="token punctuation">,</span> values<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        将值写入到
        :param key: 实体的成员变量
        :param value: 实体字段值
        """</span>
        <span class="token comment"># 实例化数据实体</span>
        entity <span class="token operator">=</span> self<span class="token punctuation">.</span>entity_cls<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token comment"># 根据keys中声明的实体成员变量名称向实体实例赋值</span>
        <span class="token keyword">for</span> key <span class="token keyword">in</span> keys<span class="token punctuation">:</span>
            val <span class="token operator">=</span> values<span class="token punctuation">.</span>get<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
            <span class="token keyword">if</span> val <span class="token keyword">is</span> <span class="token operator">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
                entity<span class="token punctuation">.</span>__setattr__<span class="token punctuation">(</span>key<span class="token punctuation">,</span> val<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>session<span class="token punctuation">.</span>add<span class="token punctuation">(</span>entity<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">close</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>session<span class="token punctuation">.</span>commit<span class="token punctuation">(</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>session<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">如果频繁地向PostgreSQL提交变更（<code>commit()</code>），数据库的写入速度就会变得越来越慢，这是由于PostgreSQL在提交时会写入数据日志（很多数据库都有此功能）。又因为蜘蛛可能一次性爬取的数据量会非常庞大，解决这一问题的最佳方法是在蜘蛛开始爬网时先连接数据并产生数据库的会话上下文，每爬取一项数据就保存当前会话上下文的数据，当然这种保存是写入到会话缓存中的。当蜘蛛完成爬网后，利用PostgreSQL的批量写入功能一次性地将大量的数据变更存入数据库（批量写入是一种效率极高、数据库I/O消耗又很低的操作）并断开与数据库的连接以释放资源。所以我们在<code>close</code>方法中才对数据库执行一次全面提交更改的动作，以实现批量更新。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这个<code>EntityFile</code>是非常通用的，因为它并没有与数据模型产生任何的依赖，只有被实例化时才会具体指定的需要处理的实体类的类型。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">接下来就是设计<code>SQLFeedStorage</code>了，为了让这个存储端可以被重用，我们就需要将所有的依赖信息外置，例如：</p>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">数据模型的类型信息</li>
<li style="font-size: 20px; line-height: 38px;">连接字符串</li>
</ul>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">信息外置最好的办法当然就是放在<code>settings.py</code>文件内，然后定义一个<code>from_crawler</code>类方法从配置文件中将它们读入。具体代码如下所示：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">from</span> zope<span class="token punctuation">.</span>interface <span class="token keyword">import</span> Interface<span class="token punctuation">,</span> implementer
<span class="token keyword">from</span> scrapy<span class="token punctuation">.</span>extensions<span class="token punctuation">.</span>feedexport <span class="token keyword">import</span> IFeedStorage

@implementer<span class="token punctuation">(</span>IFeedStorage<span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name">SQLFeedStorage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""
    SQL存储端
    @uri - SQL的连接字符串
    """</span>
    @<span class="token builtin">classmethod</span>
    <span class="token keyword">def</span> <span class="token function">from_crawler</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> crawler<span class="token punctuation">,</span> uri<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> cls<span class="token punctuation">(</span>uri<span class="token punctuation">,</span>
                   crawler<span class="token punctuation">.</span>settings<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'ORM_MODULE'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                  crawler<span class="token punctuation">.</span>settings<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'ORM_METABASE'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                  crawler<span class="token punctuation">.</span>settings<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'ORM_ENTITY'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> uri<span class="token punctuation">,</span> mod_name<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> metabase_name<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> entity_name<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        初始化SQL的存储后端
        FEED_URI 作为连接字符串使用
        """</span>
        self<span class="token punctuation">.</span>connection_str <span class="token operator">=</span> uri
        self<span class="token punctuation">.</span>mod_name <span class="token operator">=</span> mod_name
        self<span class="token punctuation">.</span>metabase <span class="token operator">=</span> metabase_name
        self<span class="token punctuation">.</span>entity_name <span class="token operator">=</span> entity_name
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">接下来就是实现<code>open</code>方法,在这个方法中我们要实现连接到数据库、数据库的初始化(建表)、实例化<code>session</code> 这一系列的动作:</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">def</span> <span class="token function">open</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> spider<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token triple-quoted-string string">"""
  通过连接字符串打开SQL数据库并返回生成的数据库上下文
  """</span>
  engine <span class="token operator">=</span> create_engine<span class="token punctuation">(</span>self<span class="token punctuation">.</span>connection_str<span class="token punctuation">)</span>

  <span class="token comment"># 动态载入MetaData</span>
  mod <span class="token operator">=</span> import_module<span class="token punctuation">(</span>self<span class="token punctuation">.</span>mod_name<span class="token punctuation">)</span>
  metabase <span class="token operator">=</span> <span class="token builtin">getattr</span><span class="token punctuation">(</span>mod<span class="token punctuation">,</span> self<span class="token punctuation">.</span>metabase<span class="token punctuation">)</span>
  entity_cls <span class="token operator">=</span> <span class="token builtin">getattr</span><span class="token punctuation">(</span>mod<span class="token punctuation">,</span> self<span class="token punctuation">.</span>entity_name<span class="token punctuation">)</span>
  
  <span class="token comment"># 初始化数据库</span>
  metabase<span class="token punctuation">.</span>metadata<span class="token punctuation">.</span>bind <span class="token operator">=</span> engine
  metabase<span class="token punctuation">.</span>metadata<span class="token punctuation">.</span>create_all<span class="token punctuation">(</span><span class="token punctuation">)</span>
	
  <span class="token comment"># 产生Session实例并返回EntityFile对象</span>
  DBSession <span class="token operator">=</span> sessionmaker<span class="token punctuation">(</span>bind<span class="token operator">=</span>engine<span class="token punctuation">)</span>
  <span class="token keyword">return</span> EntityFile<span class="token punctuation">(</span>session<span class="token operator">=</span>DBSession<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> entity_cls<span class="token operator">=</span>entity_cls<span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">上述代码中应用了python编程的小技巧：动态加载块。</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token comment"># 从指定的模块字符串中导入类相当于import的作用</span>
mod <span class="token operator">=</span> import_module<span class="token punctuation">(</span>self<span class="token punctuation">.</span>mod_name<span class="token punctuation">)</span>
<span class="token comment"># 从模块中加载具体的metabase类与数据实体类</span>
metabase <span class="token operator">=</span> <span class="token builtin">getattr</span><span class="token punctuation">(</span>mod<span class="token punctuation">,</span> self<span class="token punctuation">.</span>metabase<span class="token punctuation">)</span>
entity_cls <span class="token operator">=</span> <span class="token builtin">getattr</span><span class="token punctuation">(</span>mod<span class="token punctuation">,</span> self<span class="token punctuation">.</span>entity_name<span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">最后要在<code>close</code>方法中关闭数据连接</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">def</span> <span class="token function">store</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token builtin">file</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token triple-quoted-string string">"""向数据提提交更改并关闭数据库"""</span>
  <span class="token builtin">file</span><span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">以下是<code>SQLFeedStorage</code>的完整代码:</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python">@implementer<span class="token punctuation">(</span>IFeedStorage<span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name">SQLFeedStorage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""
    SQL的存储后端
    @uri - SQL的连接字符串
    """</span>

    @<span class="token builtin">classmethod</span>
    <span class="token keyword">def</span> <span class="token function">from_crawler</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> crawler<span class="token punctuation">,</span> uri<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> cls<span class="token punctuation">(</span>uri<span class="token punctuation">,</span>
                   crawler<span class="token punctuation">.</span>settings<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'ORM_MODULE'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                   crawler<span class="token punctuation">.</span>settings<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'ORM_METABASE'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                   crawler<span class="token punctuation">.</span>settings<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'ORM_ENTITY'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> uri<span class="token punctuation">,</span> mod_name<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> metabase_name<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> entity_name<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        初始化SQL的存储后端
        FEED_URI 作为连接字符串使用
        """</span>
        self<span class="token punctuation">.</span>connection_str <span class="token operator">=</span> uri
        self<span class="token punctuation">.</span>mod_name <span class="token operator">=</span> mod_name
        self<span class="token punctuation">.</span>metabase <span class="token operator">=</span> metabase_name
        self<span class="token punctuation">.</span>entity_name <span class="token operator">=</span> entity_name

    <span class="token keyword">def</span> <span class="token function">open</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> spider<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        通过连接字符串打开SQL数据库并返回生成的数据库上下文
        """</span>
        engine <span class="token operator">=</span> create_engine<span class="token punctuation">(</span>self<span class="token punctuation">.</span>connection_str<span class="token punctuation">)</span>

        <span class="token comment"># 动态载入MetaData</span>
        mod <span class="token operator">=</span> import_module<span class="token punctuation">(</span>self<span class="token punctuation">.</span>mod_name<span class="token punctuation">)</span>
        metabase <span class="token operator">=</span> <span class="token builtin">getattr</span><span class="token punctuation">(</span>mod<span class="token punctuation">,</span> self<span class="token punctuation">.</span>metabase<span class="token punctuation">)</span>
        entity_cls <span class="token operator">=</span> <span class="token builtin">getattr</span><span class="token punctuation">(</span>mod<span class="token punctuation">,</span> self<span class="token punctuation">.</span>entity_name<span class="token punctuation">)</span>
        metabase<span class="token punctuation">.</span>metadata<span class="token punctuation">.</span>bind <span class="token operator">=</span> engine
        metabase<span class="token punctuation">.</span>metadata<span class="token punctuation">.</span>create_all<span class="token punctuation">(</span><span class="token punctuation">)</span>

        DBSession <span class="token operator">=</span> sessionmaker<span class="token punctuation">(</span>bind<span class="token operator">=</span>engine<span class="token punctuation">)</span>
        <span class="token keyword">return</span> EntityFile<span class="token punctuation">(</span>session<span class="token operator">=</span>DBSession<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> entity_cls<span class="token operator">=</span>entity_cls<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">store</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token builtin">file</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        向数据提提交更改并关闭数据库
        """</span>
        <span class="token builtin">file</span><span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><h4 id="sqlitemexporter" style="font-size: 26px;"><code>SQLItemExporter</code></h4>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">Scrapy 的数据项导出器都继承自<code>BaseItemExporter</code>，继承这个类必须重写<code>export_item</code>方法，代码如下：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">class</span> <span class="token class-name">SQLItemExporter</span><span class="token punctuation">(</span>BaseItemExporter<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""
    将Item中的数据写入转换成为实体
    """</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span><span class="token builtin">file</span> <span class="token operator">=</span> <span class="token builtin">file</span>
        self<span class="token punctuation">.</span>_configure<span class="token punctuation">(</span>kwargs<span class="token punctuation">,</span> dont_fail<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">export_item</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        将Item插入到数据库
        可以通过FEED_EXPORT_FIELDS设置要从Item中序列化至数据库的字段
        """</span>
        self<span class="token punctuation">.</span><span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span>self<span class="token punctuation">.</span>fields_to_export <span class="token keyword">if</span> self<span class="token punctuation">.</span>fields_to_export <span class="token keyword">is</span> <span class="token operator">not</span> <span class="token boolean">None</span> <span class="token operator">and</span> self<span class="token punctuation">.</span>fields_to_export<span class="token punctuation">.</span>__len__<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> item<span class="token punctuation">.</span>fields<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                        item<span class="token punctuation">)</span>

</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><code>fields_to_export</code>是继承自<code>BaseItemExporter</code>的，是在构造函中被<code>_configure</code>产生的，我们可以在配置文件中用<code>FEED_EXPORT_FIELDS</code>配置项来控制要将数据项中的哪些字段映射到实体对象上。</p>
</div><div class="cl-preview-section"><h4 id="配置项" style="font-size: 26px;">配置项</h4>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">最后我们要将自定义的<code>SQLItemExporter</code>和<code>SQLFeedStorage</code>加入到Scrapy的数据导出机制内。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">首先是新增的配置项：</p>
</div><div class="cl-preview-section"><pre><code>ORM_MODULE = 'douban.modals' # 数据模型所在的模块
ORM_METABASE = 'db' 			   # 数据元定义类
ORM_ENTITY = 'Book'  				 # 数据实体类
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">然后是对数据导出机制的相关配置项的修改：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python">FEED_FORMAT <span class="token operator">=</span> <span class="token string">'entity'</span>      <span class="token comment"># 数据导出的格式</span>
FEED_EXPORTERS <span class="token operator">=</span> <span class="token punctuation">{</span>          <span class="token comment"># 关联导出格式与数据项导出器</span>
    <span class="token string">'entity'</span><span class="token punctuation">:</span> <span class="token string">'douban.extensions.SQLItemExporter'</span>
<span class="token punctuation">}</span>

FEED_URI <span class="token operator">=</span> <span class="token string">'sqlite:///test.db'</span>  <span class="token comment"># 数据库的连接字符串</span>

<span class="token comment"># 增加对sqlite，postgresql和mysql内种协议的存储端支持</span>
FEED_STORAGES <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token string">'sqlite'</span><span class="token punctuation">:</span> <span class="token string">'douban.extensions.SQLFeedStorage'</span><span class="token punctuation">,</span>
    <span class="token string">'postgresql'</span><span class="token punctuation">:</span> <span class="token string">'douban.extensions.SQLFeedStorage'</span><span class="token punctuation">,</span>
    <span class="token string">'mysql'</span><span class="token punctuation">:</span> <span class="token string">'douban.extensions.SQLFeedStorage'</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><blockquote>
<p style="font-size: 20px; line-height: 38px;">注：如果要连接PostgreSQL的话需要在python中安装psycopg2。如果psycopg2不能安装要以安装psycopg2-binary，指令如下：</p>
<pre><code>pip install psycopg2-binary
</code></pre>
</blockquote>
</div><div class="cl-preview-section"><h2 id="小结" style="font-size: 30px;">小结</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">本节所介绍的数据导出机制是Scrapy中的一个比较大的技术主题，基于这个机制来实现SQL存储不知道你是不是会觉得非常复杂？确实，你还可以用另一个办法来实现SQL存储：管道(Pipline)，接下来试试自动手写一个SQLPipline来实现相同的功能如何？这将会是一个化繁为简的过程，而且到了本小节你应该可以具有一些基本的代码设计能力，对Scrapy也有一定的认知了，是时候脱离教程自己设计一下代码了。</p>
</div></div>
            </div>
                            <!-- 买过的阅读 -->
                <div class="art-next-prev clearfix">
                                                                        <!-- 已买且开放 或者可以试读 -->
                            <a href="/read/34/article/380">
                                                    <div class="prev l clearfix">
                                <div class="icon l">
                                    <i class="imv2-arrow3_l"></i>
                                </div>
                                <p>
                                    19 测试BookSpider
                                </p>
                            </div>
                        </a>
                                                                                            <!-- 已买且开放 或者可以试读 -->
                            <a href="/read/34/article/428">
                                                    <div class="next r clearfix">
                                <p>
                                    21 反爬之客户端仿真
                                </p>
                                <div class="icon r">
                                    <i class="imv2-arrow3_r"></i>
                                </div>

                            </div>
                        </a>
                                    </div>
                    </div>
        <div class="comments-con js-comments-con" id="coments_con">     <div class="number">精选留言 <span class="js-number">0</span></div>     <div class="comments">         <div class="input-fake js-showcommentModal">             欢迎在这里发表留言，作者筛选后可公开显示         </div>                      <div class="noData">                 <p>                     <i class="imv2-error_c"></i>                 </p>                 <p>目前暂无任何讨论</p>             </div>              </div>  </div>



    </div>
    
    
    

</div>
 
<!-- 专栏介绍页专栏评价 -->

<!-- 专栏介绍页底部三条评价 -->

<!-- 专栏阅读页弹层目录和介绍页页面目录 -->

<!-- 专栏阅读页发布回复 -->

<!-- 专栏阅读页发布评论 -->

<!-- 专栏阅读页底部评论 -->

<!-- 专栏阅读 单个 评论 -->

<!-- 新增回复和展开三条以外回复 -->

<!-- 立即订阅的弹窗 -->












</div></body></html>